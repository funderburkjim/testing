Python number theory modules. 
Begun March, 2022
* note on importllib
In interactive session,
import numtheory1
# make some change to numtheory1.py
import importlib
importlib.reload(numtheory1)
* numtheory1.py
** gcde(a, b, dbg=False)
 standard extended Euclidean algorithm for integers, to get Bezout coefficients.
 Reference Wikipedia
 a, b integers
 dbg is NOT used.
 returns: ((x,y,d),(u,v)) so that
 a*x + b*y == d  (and d = greatest common divisor of a and b)
 a*u + b*v == d
 x and u are of different signs, as well as y and v
*** example:
 gcde(10,7) -> ((-2, 3, 1), (5, -7))
 gcd(10,7) = 1
 10*-2 + 7*3 = 1 = 10*5 + 7*-7
** gcd(a,b)
   Returns just the gcd of a and b, without Bezout coefficients
** gcde2(a,b) 
 applies gcde(a,b) and prints the results in a useful way.
*** example
>>> gcde2(10,7)
gcd of 10 and 7 is 1
1 == 10 * -2 + 7 * 3 True
1 == 10 * 5 + 7 * -7 True
** a_divides_b(a,b)
  Use Python divmod to divide b by a.
  If the remainder is 0, return the quotient b/a.
  Otherwise return None.
** gcde3(a,b)
  Assume a,b are positive integers.
  return (x,y,d) where d is greatest common divisor or a,b
  and x,y are positive integers and
  a*x == b*y + d 
  This method uses the gcde function
*** example
>>> gcde3(20,6)
(1, 3, 2)
Note: 20*1 = 6*3 + 2
** gcde3a(a,b,dbg=False)
Similar to gcde, but does not always return the same solution
  Assume a,b are positive integers.
  return (x,y,d) where d is greatest common divisor or a,b
  and x,y are positive integers and
  a*x = b*y + d 
  This method does not use extended Eulidean algorith (gcde),
  but functionally is similar.
  The function is recursive.
  The answer returned may differ from the answer returned by gcde3.
   For example: gcde3(10,6) -> (2,3,2)  (10*2 = 6*3 + 2)
   gcde3a(10,6) -> (5,8,2)  (10*5 = 6*8 + 2).
  gcde3a does not use negative integers.
    It will use x-y but only in contexts where 0<=y<=x.
  Returns None if some problem occurs
*** example
>>> gcde3(10,6)
(2, 3, 2)  NOTE: 10*2 == 6*3 + 2
>>> gcde3a(10,6)
(5, 8, 2)  NOTE: 10*5 == 6*8 + 2
** solve_ax_eq_y(a,b,n)
solve a*x = b (mod n) for x. 
 Return None if no solution
 Intended for a,b,n all non-negative integers
 Uses gcde (extended Euclidean algorithm)
*** examples
 solve_ax_eq_y(10,6,4) -> 3
 10*3 == 6 (mod 4)   ( 30 (mod 4) == 2 and 6 (mod 4) == 2)
 solve_ax_eq_y(10,5,4) -> None
 There is no solution
** a_inverse(a,n)
Solution x of a*x = 1 (mod n). 
Returns None if no solution
 solve_ax_eq_y(a,1,n)
*** example
 a_inverse(11,6) -> 5    (11*5 = 55 == 1(mod 6))
** Nsolve0_ax_eq_b(a,b,n,dbg=False)
solve a*x = b (mod n) for x. 
 Return None if no solution
 Require a and n > 0 and b >= 0
 Intended for a,b,n all non-negative integers
 Uses gcde (extended Euclidean algorithm)
 a*x = b + n*y [ if dbg is True, also prints this]
 Return (x,y). If no solution, return None.

*** example
Nsolve0_ax_eq_b(26,4,6) -> (2, 8)
 Note 26*2 = 4 + 6*8
>>> Nsolve0_ax_eq_b(26,4,6,dbg=True)
26*2 == 4 + 6*8
(2, 8)

** Nsolve_ax_eq_b(a,b,n,dbg=False):
 solve a*x = b (mod n) for x. 
 Require a and n > 0 and b >= 0
 Intended for a,b,n all non-negative integers
 Uses gcde3a (version of extended Euclidean algorithm)
 a*x = b + n*y [print this if dbg is True]
 Return (x,y). If no solution, return None.
*** example
Nsolve_ax_eq_b(26,4,6,dbg=True)
26*2 == 4 + 6*8
(2, 8)

** Nmod_inverse(a,n,dbg=False):
 Solution x of a*x = 1 (mod n).
 Returns None if no solution
 else returns non-negative x,y so that a*x = 1 + n*y 
 Uses Nsolve_ax_eq_b
** Nmod(a,b):
 Remainder of division of a by b
 Require a,b to be integers with a>=0 and b>0 (otherwise return None)
 Uses Python divmod
** squares_mod(n)
 returns Python set of non-zero quadratic residues modulo n.
 Require n to be integer > 1 (otherwise return None).
 Uses Nmod
** squareroots_mod(n)
 returns a dictionary whose keys are non-zero quadratic residues modulo n
  and whose values are list of square roots modulo n
 Require n to be integer > 1 (otherwise return {})
 Uses Nmod
** pos_squareroots_mod(n)
 returns a dictionary whose keys are non-zero quadratic residues modulo n
  and whose values are list of square roots modulo n
 BUT only include numbers <= n/2  (n // 2)
 Require n to be integer > 1 (otherwise return {})
 Uses Nmod
*** examples
squares_mod(11) -> {1, 3, 4, 5, 9}
  Note that module 11:
  square(1) = 1, square(6) = 3, square(2) = 4,
  square(4) = 5, square(3) = 9
** relprimes(n)
  Assume 1 <= n
  return [k for k in range(1,n+1) and gcd(k,n) = 1]
** ephi(n) (Euler's phi function)
  assume 1<=n.
  len(relprimes(n))

** divisors(n)
   Assume 1<=n.
   List of d (1<=d<=n) such that d divides n. (i.e. python n % d == 0)
** divisorsum(f,n) 
  sum of f(d) for d in divisors(n) 
** gcdpartition(n)
** eltOrder(a,n):
 """ 'a' and 'n' integers; 1<=n
  gcd(a,n) = 1
  Return smallest k such that a**k == 1 (mod n)
** ordPartion(n):
 """ 'n' integer, 1<=n
  For a in relprimes(n), find eltOrder(a,n).
  return a dictionary ordpart.  A number d is a key of ordpart
  iff there is a in relprimes(n) with d = ordElement(a).
  ordpart[d] = Set of all a in relprimes(n) such that ordElement(a) = d.
 """
** eltsOfOrder(d,n):
 """ return list of elements of relprimes(n) whose order is d
 """
** eltsOfOrderSizeF(n):
 """ Return a function (Python dictionary) whose 
     domain is divisors(ephi(n)) and whose value at d is
     NCard(eltsOfOrder(d,n))
 """
** primRoots(n):
 """ Return list of primitive roots of n
 """
** primRootQ(x,n):
 """ Return True or False according to whether
  x is a primitive root of n
 """
** primRootIndex(a,r,n):
 """ Return the smallest k (1 <= k <= ephi(n)) and
  r**k = a (mod n)
  Requirements:
  primRootQ(r,n), gcd(a,n) = 1
  Otherwise, return None
 """
* gcde_coeff_sizes.py
** test2()
 reads 'n' from sys.argv[1]
 For each a (3<=a<=n) and for each b (2<=b<a),
  get the Bezout coefficients (x1,y1) and (x2,y2) using numtheory1.gcde(a,b)
  (so a*x1 +b*y1 = gcd(a,b)).
  Check that the magnitude of x1 (and x2) is < b and
  the magnitude of y1 (and y2) is < a.
  Print a message if this check fails.
 print a summary message for all the a,b pairs checked.
*** example
import sys
sys.argv.append(275)
test2()
37401 Hypothesis true
0 Hypothesis false

** test3()
 Similar to test2(), but uses numtheory1.gcde3a instead of gcde.
 reads 'n' from sys.argv[1]
 For each a (3<=a<=n) and for each b (2<=b<a),
  get the Bezout coefficients (x1,y1) using numtheory1.gcde3a(a,b)
  (so a*x1  = b*y1  + gcd(a,b)).
  Check that the magnitude of x1 (and x2) is < b and
  the magnitude of y1 (and y2) is < a.
  Print a message if this check fails.
 print a summary message for all the a,b pairs checked.

* prime.py
** isPrime_basic(n)
if n is not an integer, return False
if n is 0 or 1, return False
if n<0, return False
if n has no factor F (2 <= F, F*F <= n), return True
else return False
** genprimes(m)
m should be a positive integer.
By iteration, generate the set of all primes <= m  (use isPrime_basic).
Print this list to a python file.
*** example
>>> genprimes(20)
write to file primes_lt_20.py
The file has one line:
primes_lt_20 = {2, 3, 5, 7, 11, 13, 17, 19}
** primes_set
attribute whose value is (currently) primes_lt_1000 (see genprimes example)
** isPrime(n)
if n in prime_set, return True
else return isPrime_basic(n)
This for efficiency. Faster to use set membership than iteration.
** prime_factors(n):
  returns a dictionary 'd' or None
  The dictionary has as keys the prime divisors of 'n'
  and for each such prime 'p', d[p] is the maximum power of p that divides n.
  The 'fundamental theorem of arithmetic': 
  import math
  math.prod([p**d[p] for p in d]) == n 
*** example
 prime_factors(123456) -> {2: 6, 3: 1, 643: 1}
 Note: (2**6) * (3**1) * (643**1) == 123456
** ephi1(n)
 Euler's phi function computed from the prime factorization.
** qrinfo(p,q)
 Uses numtheory1.pos_squareroots_mod
      isPrime
 p and q distinct odd primes
 return a string with 4 parts:
 - p is semi-odd/semi-even
 - q is semi-odd/semi-even
 - p is a square of n mod q/p is not a square mod q
 - q is a square of n mod p/q is not a square mod p
This allows us to confirm the quadratic reciprocity theorem, which asserts:

 IF either p or q is semi-even, THEN
  p is a square mod q IFF q is a square mod p
 IF both p and q are semi-odd, THEN
  p is a square mod q IFF q is not a square mod p 
  AND
  p is not a square mod q IFF q is a square mod p

* Zmod.py
Models modular arithmetic with the Zmod class. Also polynomials.
** Zmod(n,base)
 n an integer (int class)
 base a positive integer (not checked)
** Zmod.generate(base)
 List Zmod(n,base) for 0<=n<base
** Zmod.zero(base)
 The zero element mod(base)
 Zmod(0,base)
** Zmod.one(base)
 Zmod(1,base)
 The one element mod (base)

** Zmod.relprimes(base)
   [Zmod(i,base) for i in numtheory1.relprimes(base)]

* ZmodPoly(numlist,base,numclass=int)
 (Class also defined in Zmod.py)
 models polynomials with coefficients modulo a base.
 The 'base' should be a positive integer (not necessarily a prime)
 When numclass is the default 'int', then
  numlist is a sequence of 'int' objects.
 example: ZmodPoly([-1,0,1],7) -> 
          6X0 + 0X1 + 1X2 (mod 7)
 Otherwise assume numlist is a sequence of Zmod objects with same base.
 example: ZmodPoly([Zmod(-1,7),Zmod(0,7),Zmod(1,7)],7,Zmod) -> 
          6X0 + 0X1 + 1X2 (mod 7)
** init:  ZmodPoly([c0,c1,...],base,numclass=int or Zmod)
   provide a list of coefficients; c0, etc are of type int or Zmod
   (the default is int).
   Example: ZmodPoly([1,2,3],7) represents 1 + 2*X + 3*X^2 in base 7

** ZmodPoly.one(base)  , ZmodPoly.zero(base)
   The mutliplicative identify and additive identity in ZmodPoly for the base
** ZmodPoly.monomial(n,base)
   X^n   0<=n
   Note: ZmodPoly.one(7) == ZmodPoly.monomial(0,7)  
** ZmodPoly.divstep(a,b)  and a.divmod(b)
   a and b assumed ZmodPoly instances with same base.
   Example: base = 7, one = ZmodPoly.one(base), X = ZmodPoly([0,1],base)
   a = X**3 - one, b = X - one
   ZmodPoly.divstep(a,b) -> (X**2, 6 + X**2) First step of polynomial division
   a.divmod(b) -> (q = 1 + X + X**2, r = 0)  
     So a = b*q + r and (r==0 or deg(r) < deg(b))
** a*b, a+b, a-b, -a, a**n   a*k, X
   X = ZmodPoly([0,1],base)
   k is an integer   (note k*a with k an integer is not defined)
** a.roots()
   Example 1: base = 7, X = ZmodPoly([0,1],base), one = ZmodPoly.one(base)
    a = X**3 - one  (note 3 divides base-1 and base is a prime)
    a.roots() -> [1 (mod 7), 2 (mod 7), 4 (mod 7)]
     It is no accident that there are 3 roots!
    Note X**6 - one has 6 roots.
   Example 2: base = 15.  note 2 divides base-1 (14), but base is not prime.
    a = X**2 - one.
    a.roots() -> [1 (mod 15), 4 (mod 15), 11 (mod 15), 14 (mod 15)]
      So there are 4 roots to this degree 2 polynomial.
    b = X**14 - one has 4 roots.  
* --------------------------------------
* Theory
* --------------------------------------
* N set of natural numbers
  informally, N = set of non-negative integers (0,1,2,3,...)
  But I use a set-theoretic definition, very close to the defintion
  proposed by John von Neuman. Ref: https://en.wikipedia.org/wiki/Natural_number
  A natural number is a certain set.
  The symbol '0' represents the empty set; the natural number named
    'zero' in English IS this empty set.
  list(a) is the singleton set containing 'a'. ['a' need not be a set]
  next(s) = union(s,list(s))  (the successor set to 's'; 's' assumed a set)
  'a' is an 'ordinal' iff 
   'a' is a set
   and every element of 'a' is a subset of 'a'
   and for any two elements x and y of 'a', 
     either (a) x=y, or (b) x is an element of y, or (c) y is an element of x.
  'a' is a 'natural number' iff
    'a' is an ordinal
     and if 'b' is a non-empty subset of 'a', there is an element 'x' of 'b'
         such that which is not an element of any element of 'b'
    NOTE?: 'x' is the largest element of 'b'.
  Finally, a form of the 'Axiom of Infinity' is used to assert the existence
   of a set containing precisely all natural numbers; this set we call N.
  The first few natural numbers are DEFINED 
   0 = empty set, 1 = next(0), 2 = next(1), 3 = next(2).   
  But no FORMAL naming process  (such as base 10) is used.
  e.g., 1776 is not 'defined'.  
* N* = set of positive integers (1,2,3,...)
* addition, multiplcation, ordering N
  All these have been defined by me 'pyfol4c/norm/06/06-prep.org'
  But they are used informally, with common notation (+, *, <, <=, >, >=)
  power also 2**3 or 2^3.
  Subtraction is only defined partially. i.e. if a>=b then a-b is the
  the element 'c' of N so that a = b+c.
  In particular we try to avoid
  talk about the sets Z of integers, Q of rationals, R of reals, C of complex.
  We also use 'informal' definitions for rings (such as integers mod 5,
  polynomials, etc.
* Division algorithm in N: a = b*q + r, r<b
  Assume 0<=a, 0<b. 
  S := {x, x in N and b*x <= a}
  b*0 = 0 <= a, so 0 is in S. So S is not empty.
  if x>a, then b*x > b*a since 0 < b;
   and b*a >=  1*a = a, since b >= 1;
   so b*x >a ;
   so x is not in S.
  thus if x is in S, then x<=a.  Thus S is a finite subset of N.
  set q = Max(S).  Then q is in S and x > q implies x is not in S.
  Thus, b*q <= a.
  There is r in N with b*q+r = a.
  Suppose r >= b.  Then there is c in N with b+c = r
   So a =  b*q + b+c = b*(q+1) + c.  Thus b*(q+1) <= a so q+1 is in S,
   contradicting that q is largest in S.
  Thus r<b.
  Now show uniqueness.
  Suppose a = b*q + r with r<b  and also a = b*u + v, with v<b.
  We aim to show q = u and r = v.
  Then b*q + r = b*u + v.  
  Suppose r < v (we will derive a contradiction).
   Choose d so r+d = v.  Also 0 < d and d<=v and d < b.
   Then b*q + r = b*u + r + d.
   Hence b*q = b*u + d. 
   So b*u < b*q, since 0 < d.
   So u < q, since 0 < b.
   So there is x with u+x=q and 0 < x.
   So b*u + d = b*q = b*(u+x) = b*u + b*x;
   So d = b*x.
   Now 0 < x, since 0 < d. 
   So x >= 1.
   Thus b*x >= b*1 = b.
   Thus d >= b, which contradicts that d < b.
  So !(r<v).
  Similarly, !(v<r).
  Thus, r = v.
  Now b*q = b*u.  
  Thus q = u, since 0 < b.
  Thus r=v and q=u, as was to be proved.
* Quo(a,n) and Rem(a,n), divalgF(n)
  For 0<=a and 1<=n in N.
  a = n*Quo(a,n) + Rem(a,n),  
  Quo(a,n) in N, Rem(a,n) in N, and Rem(a,n) < n.
  if 1<=n and  a = n*q + r and r<n, then q = Quo(a,n) and r = Rem(a,n)
  Note: Quo(a,0) and Rem(a,0) are not defined. ("Can't divide by 0")
  divalgF(n): carprod(N,n) -> N,  divalgF(n)(q,r) = n*q + r.
** if 1<=n, then divalgF(n) is a bijection from carprod(N,n) onto N.
   inverse(divalgF(n))(a) = (Quo(a,n),Rem(a,n))
** If a<n, then Quo(a,n) = 0 and Rem(a,n) = a
  a = n*0 + a,  By uniqueness of quotient and remainder,  conclude
  Quo(a,n) = 0 and Rem(a,n) = a.
** If a in N, then Quo(Rem(a,n),n) = 0 and Rem(Rem(a,n),n) = Rem(a,n)
   By previous applied to Rem(a,n), conclude
   Quo(Rem(a,n),n) = 0 and Rem(Rem(a,n),n) = Rem(a,n)
** Quo(c*n,n) = c and Rem(c*n,n) = 0
   c*n = c*n + 0.  Conclusion follows from uniqueness of division
** if a,b in N, then Rem(a+b,n) = Rem(Rem(a,n)+Rem(b,n),n)
  a = n*q + r (0<=r<n), b = n*s + t (0<=t<n), a+b = n*u + v (0<=v<n)
    q = Quo(a,n), r = Rem(a,n);  s = Quo(b,n), t = Rem(b,n);
    u = Quo(a+b,n), v = Rem(a+b,n).
  a+b = n*(q+s) + (r+t)
  r+t = n*c + d (0<=d<n) also by div algorithm.  
    c = Quo(r+t,n), d = Rem(r+t,n).
  a+b = n*(q+s+c) + d, and 0<=d<n.
  By uniqueness, q+s+c = u and d = v.
  i.e., Rem(Rem(a,n) + Rem(b,n),n) = Rem(a+b,n).
** if a,b in N, then Rem(a+b,n) = Rem(Rem(a,n)+b,n)
  Rem(Rem(a,n)+b,n) = Rem(Rem(Rem(a,n),n)+Rem(b,n),n) =
    = Rem(Rem(a,n)+Rem(b,n),n) 
    = Rem(a+b,n).
** if a,b in N, then Rem(a*b,n) = Rem(Rem(a,n)*Rem(b,n),n)
    a = n*q + r (0<=r<n), b = n*s + t (0<=t<n), a*b = n*u + v (0<=v<n)
    q = Quo(a,n), r = Rem(a,n);  s = Quo(b,n), t = Rem(b,n);
    u = Quo(a*b,n), v = Rem(a*b,n).
    Also, a*b = (n*q + r)*(n*s + t) = n*(q*n*s + q*t + r*s) + r*t.
  So Rem(a*b,n) = Rem(n*(q*n*s + q*t + r*s) + r*t,n)
                = Rem(Rem(n*(q*n*s + q*t + r*s),n) + Rem(r*t,n),n)
                = Rem(0 + Rem(r*t,n),n)
                = Rem(Rem(r*t,n),n)
                = Rem(r*t,n) which is Rem(R(a,n)*Rem(b,n),n)
** if a,b in N, then Rem(a*b,n) = Rem(Rem(a,n)*b,n) = Rem(a*Rem(b,n),n)
   Rem(Rem(a,n)*b,n) = Rem(Rem(Rem(a,n),n)*Rem(b,n),n)
                     = Rem(Rem(a,n)*Rem(b,n),n) 
                     = Rem(a*b,n)
   And similarly Rem(a*Rem(b,n),n) = Rem(a*b,n)
* cumulative product of an enumeration (abstraction)
  This abstracts NprodSeq, etc. of next section.
  A small idea.
  Let A be a non-empty set on which is defined a binary operation which
   is associative and commutative (Notation: x*y)
  Let m = Ncard(A). Let f: m -> A be a bijection.
  Define prod(f) to be cumulative product.
   
   Informally, if 
    m = 1,  prod(f) = f[0]
    m = 2,  prod(f) = f[0]*f[1]
    m = 3.  prod(f) = (f[0]*f[1])*f[2]
    etc.
  When the binary operation is commutative and associative, 
   and if f: m -> A and g: m -> A are bijections,
   Then prod(f) = prod(g).
  Thus, we may talk about cumprod(A), which is prod(f) where f is any
  bijection.

* NprodSeq, NprodSet,  NsumSeq, NsumSet 
  NprodSeq(f) 'product of a finite sequence of numbers'
  NprodSet(S) 'product of a finite subset of numbers'
  if k in N, f:k->N a function.  Then NprodSeq(f) can be definied recursively by
     NprodSeq(f) = 1 if k = 0
     NprodSeq(f) = NprodSeq(res(f,k))*f(k) if domain(f) = k+1.
  Since * is commutative and associative,
  If k in N and  if g:k->k is a bijection, then NprodSeq(f#g) = NprodSeq(f)  where domain(f) = k.

  If S is a finite subset of N, then NprodSet(S) is defined to be NprodSeq(f), where
    f:NCard(S)->S is any bijection.

  Similarly, NsumSeq(f) and NsumSet(S) can be defined.
** 0. If S is finite subset of N*, then 1 <= NprodSet(S).
** 1. If S is finite subset of N* and a in S, then a | NprodSet(S)
   Informal.
   Since a in S, then S!=0, so NCard(S) != 0.
   Choose m so the 0<=m and NCard(S) = m+1.
   Choose bijection s:NCard(S)->S so s(0) = a.
   Then NprodSet(S) = s(0)*(s(1)*...*s(m)) so s(0) | NprodSet(S)
** 2. If S1 and S2 are finite disjoint subsets of N, then ...
   NprodSet(union(S1,S2)) = NprodSet(S1)*NprodSet(S2)
   Not sure how to make 'formal'
** 3. If S and T are finite subsets of N* and leq(S,T), then NprodSet(S) | NprodSet(t)
  Choose bijection t:NCard(T) -> T so that image(t,NCard(S)) = S.
  Let m,n be chosen so m = NCard(S); NProdSet(S) = NprodSeq(res(t,m))
  Then NProdSet(T) = NprodSeq(t) = NprodSeq(res(t,m)) 
* NevenQ and NoddQ
  iff (NevenQ(n) (in(n,N) && NdivQ(2,n)))
  iff (NoddQ(n)  (in(n,N) && ! NdivQ(2,n)))
** 1. if in(n,N), then NevenQ(n) or NoddQ(n)
if in(n,N), then (NdivQ(2,n) or ! NdivQ(2,n))
** 2. Iff NevenQ(n) (in(n,N) && Rem(n,2) = 0)
 iff(NdivQ(2,n) (1<=2 && 0<=n && Rem(n,2) = 0))
 Iff (in(n,N), 0<=n)  definition of <= in N
  0 < 1 < 2, so 1<=2.

** 3. Iff NoddQ(n) (in(n,N) && Rem(n,2) = 1)
   1<=2.
   Assume n in N.
   Then, Iff (NdivQ(2,n) (Rem(n,2) = 0))
   So, Iff(!NdivQ(2,n) (Rem(n,2) != 0)).
   But Rem(n,2) < 2.
   So Rem(n,2) = 0 or Rem(n,2) = 1.
   Thus (Iff (Rem(n,2) != 0)  (Rem(n,2) = 1)).

** 4. 0 is even
   0 = 2*0, so 2 | 0
** 5. 1 is odd
   1 = 2*0 + 1, and 1 < 2.  So Rem(1,2) = 1. So NoddQ(1)
** 6 is even
   2 = 2*1 + 0 = 2.  So, 2 | 2. So 2 is even.
** 7. if p is prime and p!=2, then p is odd
** 8. if n is odd, then n-1 is even
   n = 2*Quo(n,2) + 1.
   Thus, (n-1) = 2*Quo(n,2)
    Thus 2 | (n-1).  Thus n-1 is even.
** 9. if n is even and n != 0, then n-1 is odd
  n is in N.
  n = 2*Quo(n,2).
  Since n != 0, Quo(n,2) != 0.
  Thus, 1<=Quo(n,2).  Thus 2<=n.
  Thus n-2 is in N.
  n-2 = 2*q - 2 = 2*(q-1) 
  n-1 = (n-2)+1 = 2*(q-1) + 1
  So Rem(n-1,2) = 1.
  Thus n-1 is odd
** 10. if n is even and m in N, then n*m is even
   n = 2*x, m = 2*y
   n*m = 2*(2*x*y) so n*m is even
** 11. if n is odd and m is odd, then n*m is odd
   n = 2*x + 1, m = 2*y + 1
   n*m = 2*x*2*y + 2*x + 2*y + 1*1 = 2*(x*2*y + x + y) + 1.
   So n*m is odd.
** 12. if n is even and 1<=k, then n**k is even
   By 10 and induction
** 13. if n is odd and 1<=k, then n**k is odd
   By 11 and induction induction
* NdivQ(d,a) and divisors(a), nondivisors, multiples, nonmultiples
 "d divides n"  iff(NdivQ(d,n) (1<=d && 0<=n && Rem(n,d) = 0))
 NOTATION d | n.

 if 1<=d, then 0 = d*0 + 0, so Rem(0,d) = 0 and Quo(0,d) = 0.
  Thus NdivQ(d,0).
 if in(n,N) and in(d,N*), then Iff(NdivQ(d,n), n = d*Quo(n,d))
 Iff(NdivQ(d,n), And(in(d,N*), E(q, n = d*q)))
 
 divisors(n) := {d : NdivQ(d,n)}.  
  Note: Iff(in(d,divisors(n)), NdivQ(d,n))
  Note: by this definitions, divisors(0) = diff(N,{0}) = N*.

 For rest of this article, assume 1<=n.
 
  a. divisors(n) is a finite non-empty subset of N*.
  b. divisors(n) contains elements 1 and n.
  c. leq(divisors(n),n+1).

 nondivQ(d,n) " d is a non-divisor of n" Iff 1<=d and 0<=n and Rem(n,d) != 0.  
 nondivisors(n) := {d : nondivQ(d,n)}
  Note: iff(in(d,nondivisors(n)), nondivQ(d,n))
  Note: isect(divisors(n),nondivisors(n)) = 0
  Note: union(divisors(n),nondivisors(n)) = N*
 
 1<=n, multiples(n) := image(divalgF(n),carprod(N,{0}))
       = {a: 0<=a and Rem(a,n) = 0}
       = {a: NdivQ(n,a)}  recall: NdivQ(n,a) Iff 1<=n and 0<=a and Rem(a,n) = 0
       = {a: in(n,divisors(a))}
  Note: in(0,multiples(n))  0 = n*0 + 0
  Note: in(n,multiples(n))  n = n*1 + 0
 1<=n, 1<=b multiples(n,b) := isect(multiples(n),b)

 1<=n, nonmultiples(n) := image(divalgF(n),carprod(N,diff(n,{0})))
       = {a: 0<=a and Rem(a,n) != 0}
       = {a: nondivQ(n,a)}
       = {a: in(n,nondivisors(a)) }
 1<=n, 1<=b nonumultiples(n,b) := isect(nonmultiples(n),b)
  Note: isect(multiples(n),nonmultiples(n)) = 0
  Note: union(multiples(n),nonmultiples(n)) = N

 Let Fn = divalgF(n)
 Let res = restriction
** iff in(a,multiples(n)) E(q in N and a = n*q)
** 1<=b, iff in a multiples(n,b) (a < b and E(q in N and a = n*q))
** res(Fn,carprod(N,{0})) is bijection onto multiples(n)
** if 1<=m , res(Fn,carprod(m,{0})) bijection onto multiples(n,n*m)
   Note: iff(in(q,m), q<m). 
   if q < m, then Fn(q,0) = n*q, and n*q < n*m. 
    Thus Fn(q,0) in multiples(n,n*m).
   If a in multiples(n,n*m) then a < n*m and there is q with a = n*q)
    Thus n*q < n*m.  Thus q < m, thus (q,0) in carprod(m,{0}).
** if 1<=m, NCard(multiples(n,n*m)) = m
   Let A = carprod(m,{0}). Let B = multiples(n,n*m).
   proof. Let g = res(Fn,A). g is bijection from A onto B.
   Thus NCard(B) = NCard(A) = NCard(m)*NCard({0}) = m*1 = m.
** --------------------------------------------------------------
** --------------------------------------------------------------
** iff in(a,nonmultiples(n)) E(q, E[r in q N, r in n, r!=0 and a = n*q+r))
** iff in(a,nonmultiples(n,b)) (a < b) and E(q, E[r in q N, r in n, r!=0 and a = n*q+r))
** if 1<=b, then Iff in(a,nonmultiples(n,b) (a < b AND  (not n|a))
** if 1<=b, then Iff in(a,nonmultiples(n,b) (a < b AND in(n,nondivisors(a))
** if 1<=m, res(Fn,carprod(m,diff(n,{0}))) bijection onto nonmultiples(n,n*m)
** if 1<=m, NCard(nonmultiples(n,n*m)) = m*(n-1).
   Let A = carprod(m,diff(n,{0})), let B = nonmultiples(n,n*m).
   Let g = res(Fn,A). Thus g is a bijection from A onto B.
   Thus NCard(B) = NCard(A) = NCard(m)*NCard(diff(n,{0})) =
     m * (NCard(n) - NCard({0})) = m*(n-1).
** if 1<=k, NCard(nonmultiples(n,n**k)) = (n**(k-1))*(n-1)
   m = (n**(k-1)).  So n**k = n*m.  
   Since 1<=n m and 1<=k, we have 1<=m.
   Thus the previous result applies

* d|a implies (d|(a+b) Iff d|b)
  Assume a, b > 0
  So also a+b > 0.
  Suppose a = d*x.
  if d|b, then there is y with  b = d*y;
   then a+b = (d*x) + (d*y) = d*(x+y), so d|(a+b)
  if d|(a+b), then there is so that a+b = d*z
  So d*x + b = d*z.
  Since b>0, then d*x < d*z.
  Thus, x < z (since 0<d).
  Thus there is 0<y with x+y = z
  so d*z = d*(x+y) = d*x + d*y.
  Thus, b = d*y.
  Then d|b.
* NgcdQ(a,b,d), gcd(a,b), comdivs(a,b) 
  "d is the greatest common divisor of a and b"
  iff (NgcdQ(a,b,d), And
    in(a,N*),in(b,N*),in(d,N*), NdivQ(d,a) ,NdivQ(d,b),
    A(k, implies(And(NdivQ(k,a) ,NdivQ(k,b)), Nleq(k,d))
  if a and b are in N*, then 
  Assume a and b are in N*, and consider the set of common divisors of
  a and b; i.e. D = S(d, NgcdQ(a,b,d)). 
?  Since Ngcd(a,b,d) = Solution(D)  (there is exactly one such d)
** gcd(a,b) defined in N*; comdivs(a,b)
  Assume 0<a and 0<b. 
  gcd(a,b) = Max(intersection(divisors(a),divisors(b))).
  So gcd(a,b) | a and gcd(a,b) | b  and
  A(d, d|a and d|b implies d<=gcd(a,b))
  Let comdivs(a,b) = intersection(divisors(a),divisors(b)).
    So, gcd(a,b) = Max(comdivs(a,b))
** gcd(a,b) = gcd(b,a)
  intersection(divisors(a),divisors(b)) = intersection(divisors(b),divisors(a))
  Apply max to both sides to get gcd(a,b) = gcd(b,a)
** if 0<r<a and 0<=q, then gcd(a*q+r,a) = gcd(a,r)
  Proof: Let b = a*q + r.
  Case q = 0.  Then b = r. So gcd(b,a) = gcd(r,a) = gcd(a,r) 
  Case q != 0.
  We show comdivs(b,a) = comdivs(a,r).
  Then a*q > 0. 
  if d in comdivs(b,a), then d|b and d|a, so d|b and d|a*q, so
   d|(a*q + r) and d|(a*q), so d|(a*q) and d|(a*q + r) so d|r, so
   d in comdivs(a,r)
  if d in comdivs(a,r), then d|a and d|r, so d|a*q and d*r, so d|b,
   so d in comdivs(b,a)
  Thus comdivs(b,a) = comdivs(a,r).
  Thus gcd(b,a) = gcd(a,r)
  
** gcd(a,1) = 1
  divisors(1) = {1} and divisors(1) is subset of divisors(a).
  comdivs(a,1) = intersection(divisors(a),divisors(1)) = divisors(1) 
  So NMax(comdivs(a,1) = Nmax({1}) = 1.
** FALSE: 1<=a, 1<=b => a = gcd(a,b)*Quo(a,gcd(a,b)) and gcd(gcd(a,b),Quo(a,gcd(a,b))=1
  a = 9, b = 15.  gcd(a,b) = 3. 9/3 = 3. gcd(3,3) = 3 != 1.
* Awkward Proof Bezout Theorem in N.  (See 'Bezout Theorem in N using NidealQ')
 thm(a,b) = if 1<=a and 1<=b, then 
   (E[x,E[y, 1<=x , 0<=y, a*x = b*y + gcd(a,b)]] and
    E[x,E[y, 1<=x , 0<=y, b*x = a*y + gcd(a,b)]])
** thm(a,b) IFF thm(b,a).
 thm(b,a) = if 1<=b and 1<=a, then 
   (E[x,E[y, 1<=x , 0<=y, b*x = a*y + gcd(b,a)]] and
    E[x,E[y, 1<=x , 0<=y, a*x = b*y + gcd(b,a)]])
  Since gcd(a,b) = gcd(b,a), thm(a,b) IFF thm(b,a)
** thm(a,1)
    So g = gcd(a,1) = 1. 
    (a) Take x = 1 and y = a-1. Note 1<=x and 0<=y.
        a*x = a*1 = a
        b*y + g = 1*(a-1) + 1 = 1*a = a
    (b) Take x = a+1, y = 1
        b*x = 1*(a+1) = a+1
        a*y + g = a*1 + 1 = a+1
** Case a = 1
   g = gcd(1,b) = 1
  (a) x = b+1, y = 1
      a*x = 1*(b+1) = b+1
      b*y + g = b*1 + 1 = b+1
  (b) x = b, y = b-1
     a*x = 1*b = b
     a*y + g = 1*(b-1) + 1 = b-1+1 = b
** Case a = b
    Then g = gcd(b,b) = b
    (a) x = 2, y = 1
       a*x = a*2 = b*2 = b+b
       b*y + g = b*1 + b = b+b
    (b) x = 2, y = 1
      b*x = b*2 = b+b
      a*y +g = b*1 + b = b+b
** Case a = b*q and 1<q
    g = gcd(b*q,b) = b
    (a) x = 1, y = q-1
      a*x = a*1 = a = b*q
      b*y + g = b*(q-1) + b = b*q -b + b = b*q  [Note arithmetic in Z!]
    (b) x = q+1, y = 1
     b*x = b*(q+1) = b*q + b
     a*y + g = a*1 + b = b*q + b
    b*x = b*q*y +b
** Case a = b*q + r, with 0 < r < b.
   Note g = gcd(a,b) = gcd(b,r) = gcd(r,b)
   (a) Choose (by induction on b, applied to r) u and v so
       1<=u and 0<=v and r*u = b*v + gcd(r,b) 
       Note r*u = b*v + g
      Then set  x = u and y = q*u + v, we have a*x = b*y + g.
      a*x = a*u = (b*q + r)*u = b*q*u + r*u = b*q*u + b*v + g = b*(q*u + v) + g
      b*y + g = b*(q*u + v) + g
  (b) Choose (by induction on by applied to r) u and v so
      1<=u and 0<=v and b*u = r*v + gcd(b,r)
      Note  b*u = r*v + g
      Let x = q*v + u , and y = v.
      b*x = b*(q*v + u)
      a*y + g = (b*q + r)*v + g = b*q*v + r*v + g = b*q*v + b*u = b*(q*v + u)
** All cases
    Proof from previous by induction on b.
* NidealQ(S)
 Iff(NidealQ(S), And(
  leq(S,N*),
  Not(eq(S,0)),  (i.e., S is not an empty set)
  A(t,A(u,Implies(And(in(t,S),in(u,S)),in(t+u,S))))
  A(t,A(u,Implies(And(in(t,S),in(u,N*),in(t+u,S)),in(u,S)))) 
 ))
** If NidealQ(S), then NMin(S) is in S
** If NidealQ(S), then S = {k*NMin(S), 1<=k}
 Theorem: If S is an ideal in N* then NMin(S) is in S and
 S is the set of all multiples of NMin(S), i.e.
 A(t,Implies(in(t,S),NDivQ(NMin(S),t))) and
 A(t,Implies(And(in(t,N*)),NDivQ(NMin(s),t)),in(t,S))
**  If NidealQ(S) and 1<=j, then Iff(in(j,S), 1<=j and NDivQ(NMin(S),j))
** NidealQ(N*)
  Let K = N*.
  K is not empty, as 1 is in N*.
  if c1 and c2 are in N*, then c1+c2 is in N*.
  if c1 and c2 are in N* and c1 > c2, then c1-c2 is in N*.
  Thus, NidealQ(N*).
  Note NMin(N*) = 1, and N* = {k*1, for 1<=k}.
* Bezout Theorem in N using NidealQ
  Given 1<=a and 1<=b.
  Let S = S(a,b) = S(d, 1<=d and E[x,E[y, 1<=x , 0<=y, a*x = b*y + d]]).
  Notation: gcdIdeal(a,b) official name of S
  We first prove that S is an Nideal, generated by gcd(a,b).
** S is a subset of N*.  True since 1<=d iff d is in N*.
** a is in S, and also b is in S.so S is not empty
  a*1 = b*0 + a, and 1<=a.  Thus, a is in S.
  a*b = b*(a-1) + b   (and 0<=a-1 since 1<=a; and 1<=b). so b is in S
** if t and u are in S, then t+u is in S.
   1<=t and choose x,y so 1<=x, 0<=y and a*x = b*y + t
   1<=u and choose z,w so 1<=z, 0<=w and a*z = b*w + u
   Thus a*(x+z) = b*(y+w) + (t+u), and 1<=x+z, and 0 <= y+w.
   And 1<=(t+u).
  Thus t+u is in S.
** If t in S and u in N* and t+u is in S, then u is in S.
   1<=t and choose x,y so 1<=x, 0<=y and a*x = b*y + t
   1<=u. 
   Choose m,n so 1<=m, 0<=n, and a*m = b*n + (t+u)
   To find: z,w so 1<=z, 0<=w and a*z = b*w + u.
   a*x = b*y + t
   a*m = b*n + (t+u)
   Motivation from Z: If 1<=(m-x) and 0<=(n-y), then we would be done.
    In Z, t = a*x - b*y
     a*m = b*n + (a*x - b*y) + u
     a*(m-x) = b*(n-y) + u.   
   There are many choices for x and y
   a*x = b*y + t
   a*(x+k*b) = b*(y+k*a) + t? for any k in N
    lhs = a*x + a*k*b = b*y + a*k*b + t
    rhs = b*(y+k*a) + t = b*y + b*k*a + t
    So, lhs = rhs.
   Similarly, for any k in N
   a*(m+k*b) = b*(n+k*a) + (t+u).
   Choose k so that x < m + k*b and y <= n + k*a.
   Take k = max(x,y)
   Set z = m + k*b and w = n + k*a.
   Then 1<=z and 0<=w.
   And a*z = a*(m + k*b) = a*m + a*k*b = b*n + a*k*b + (t+u)
   b*w + u = b*(n + k*a) + u =           b*n + b*k*a + u
           = a*z + t  
  Thus 
     1<=b and 1<=x so x <= x*b.
     1<=m, so x*b < m + x*b.  Thus x < z.
   set z = n + 
** NidealQ(S).
   We have established that S satisfies all conditions of NidealQ
** Let D = NMin(S). Then in(c,S) Iff E[u, 1<=u and c = D*u] Iff D|c
** Let G = gcd(a,b).  We show D = G.
*** Since D is in S, we may choose 1<=x, 0<=y so a*x = b*y + D.
*** If c|a and c|b, then c|D.
    Thus, c|a*x and c|b*y.  Since a*x = b*y + D, also c|D.
*** G<=D
  G|a and G|b. Thus G|a*x and G|b*y.  Thus, G|D.  
  Thus G<=D.
*** D|a and D|b
  Since a is in S, D|a.  Since b is in S, D|b.
*** Thus, D <= G 
  D is a common divisor of a,b and G is the largest such.
*** Thus, G = D.
  Since G<=D and D<=G.
** If c|a and c|b, then c|G.
  Since D is in S, we conclude c|D.
  Since G = D, we conclude c|G.

** S = all positive multiples of G.
   S = all positive multiples of D, and D = G.
** S(b,a) = S(a,b).
   S(a,b) = all positive multiples of gcd(a,b)
   S(b,a) = all positive multiples of gcd(b,a).
   But gcd(a,b) = gcd(b,a).
   Thus, S(a,b) = S(b,a).
** Why is y=0 allowed ?
  Suppose 0<d. 
  Suppose there is 0<x s.t. d=a*x.  (thus a*x = b*0 + d)
  
  Are there y,z with 0<y, 0<z, and a*y = b*z + d
  Suppose there are such y and z.
  Thus a*y = b*z + a*x
  Thus there is 0<=w with b*z = a*w.
  So a*y = a*w + a*x
  So y = w + x.   Thus x <= y
   If x = y, then b*z = 0 which is not possible since 0<b and 0<z.
   Thus, x < w.  Thus 0 < w
   Suppose 1 < w.
    
* Bezout Theorem corollaries
** 1. BC 1: if 1<=a, 1<=b, c|a and c|b, then c|gcd(a,b)
  This was a step in the proof of Bezout's theorem.
** 2. BC 2: if gcd(a,b) = 1, then there is x in N* so that a*x = 1(mod b)
  proof. By Bezout, choose x (1<=x) and y (0<=y) so that a*x = b*y + gcd(a,b).
  So, a*x = gcd(a,b) (mod b) = 1 (mod b)
** 3. DA 22a: 1<=a, 1<=b => gcd(Quo(a,gcd(a,b)), Quo(b,gcd(a,b))) = 1
 Let d = gcd(a,b). Let u = Quo(a,d),  v = Quo(b,d).
 To show: gcd(u,v) = 1.
 By Bezout theorem in N, there are 1<=x, 0<=y so  a*x = b*y + d.
 Since d|a and d|b, we conclude a = d*u, b = d*v.  
 So d*u*x = d*v*y + d. Thus, u*x = v*y + 1.
 Now e|u and e|v implies e|1 , so e=1.  Thus,gcd(u,v) = 1. QED.
** 4. DA 22a: 1<=a, 1<=b => gcd(Quo(a,gcd(a,b)), Quo(b,gcd(a,b))) = 1 (No Bezout)
  Let d = gcd(a,b) 
  To show gcd((a/d),(b/d)) = 1.
  d|a and d|b.
  a = d*(a/d), b = d*(b/d)
  Suppose e|(a/d) and e|(b/d). We show e = 1
   (a/d) = e*x, (b/d) = e*y. (where x = Quo((a/d),e) and y = Quo((b/d),e))
   a = d*e*x, b = d*e*y.
   Thus d*e|a and d*e|b.
   Thus d*e <= d.  Thus e = 1.
  Taking gcd((a/d),(b/d)) for e, we conclude gcd((a/d),(b/d)) = 1.
** 5. BC 5: 0<a, 0<b, 0<c implies gcd(a*c,b*c) = gcd(a,b)*c.
   gcd(a,b) | a and | b.  Thus gcd(a,b)*c | a*c and | b*c.  Thus (Bezout)
   (i) gcd(a,b)*c | gcd(a*c,b*c).
   Conversely, There are 0<x and 0<=y so that a*x = b*y + gcd(a,b).
   Thus, (a*x)*c = (b*y)*c + (gcd(a,b)*c)
   So (a*c)*x = (b*c)*y + (gcd(a,b)*c).
   Thus, (gcd(a,b)*c) is in GCDIdeal(a*c,b*c), which is generated by
   gcd(a*c,b*c).  i.e., 
   (ii) gcd(a*c,b*c) | (gcd(a,b)*c)
   From (i) and (ii),  gcd(a*c,b*c) = gcd(a,b)*c
* lcm(a,b)  least common multiple
  Assume 1<=a, 1<=b.
  multiples(a,b) = {c, 1<=c and a | c and b | c}
  a*b is in multiples(a,b), so multiples(a,b) is not the empty set.
  lcm(a,b) = NMin(multiples(a,b)).
  So lcm(a,b) in multiples(a,b) [ so 1<=lcm(a,b) and a | lcm(a,b) and b | lcm(a,b) ]
  And if c is in multiples(a,b), then lcm(a,b) <= c.
** a*b = lcm(a,b)*gcd(a,b).
  let l = lcm(a,b) and d = gcd(a,b). Let S = multiples(a,b)
  Let u = Quo(l,a) and v = Qul(l,b), so
  l = a*u and 1<=u
  l = b*v and 1<=v.
  d | a and a | a*b, so d | a*b.
  Let m = Quo(a*b,d).
  a*b = d*m and 1<=m.
  To show: m = l.
*** l <= m
  Let r = Quo(a,d) and s = Quo(b,d).
  a = d*r, 1<=r since d|a
  b = d*s, 1<=s since d|b
  d*r*b = a*b = d*m
  r*b = m
  b | m
  a*d*s = a*b = d*m
  a*s = m
  a | m
  Thus, m is in multiples(a,b).
  Thus, l <= m
   
*** m <= l
  d is in gcdIdeal(a,b)  (Bezout). Choose x and y with
  1 <= x, 0 <= y, and
  a*x = b*y + d.
  l*b = a*u*b = a*b*u = d*m*u
  l*a = b*v*a = a*b*v = d*m*v
  l*a*x = d*m*v*x
  l*a*x = l*b*y + l*d = d*m*u*y + l*d
  d*m*v*x = d*m*u*y + l*d
  (1) m*v*x = m*u*y + l  (cancel d, since 1<=d)
  Thus, m | l.
  Thus, m <= l
*** Thus, m = l
* =========================================================
* NprimeQ definition, and first properties
  NprimeQ(p)
  p is a prime iff 
   (1) p is in N and 1<p and
   (2) A(d,NdivQ(d,p) implies d=1 or d=p)
** 1. 0 is not prime
   since not (1 < 0)
** 2. 1 is not prime
   since not (1<1)
** 3. if p is prime, then 2<=p
   1+1 <= p, since p is in N and 1 < p, 
   and 2 = 1+1.
** 4. NprimeQ(2)
  Proof: 1<2.  NdivQ(d,2) => Nleq(1,d) and Nleq(d,2). Thus d = 1 or d = 2.
** 5. if p is prime and p!= 2 then 2<p
   since 2<=p and p!=2
** 6. if 1<d, then there is a prime p so that NdivQ(p,d)
Proof:  By induction on d. 
 Case d = 2.  Take p = 2 (known to be a prime).
 Make inductive assumption: 1<e<d implies there is prime p so that NdivQ(p,e)
 Take 1<d.
 If d is a prime, then take p = d.
 If d is not a prime, then by definition of prime,
  there is e (1 < e < d) so that NdivQ(e,d).
 By induction, there is prime p so that NdivQ(p,e). Also NdivQ(p,d).
 
QED by induction.
** 7. 1 < n implies E(p,NprimeQ(p) and NdivQ(p,n))
 Proof:
  By induction on n. 
  Case n = 2.  NprimeQ(2).  and NdivQ(2,2)
  Assume 2<=n and A(k,2<k<=n implies E(p,NprimeQ(p) and NdivQ(p,k))
  Let m = n+1. To show E(p,NprimeQ(p) and NdivQ(p,m))
  If m is a prime, choose p = m.
  If m is not a prime, then (by defn of prime), there is k such that
   NdivQ(k,m) and k!=1 and k!=m.
   So k <= n. and 2<=k.  Thus, by inductive assumption,
   E(p,NprimeQ(p) and NdivQ(p,k)).   Now also NdivQ(p,m). QED
** 8. If NprimeQ(p) and 0<a and p does not divide a, then gcd(p,a) = 1.
  Let d be a divisor of both p and a.
  Since p is a prime, d = 1 or d = p.
   If d = p, the p | a, contrary to assumption.
  Thus, d = 1.
  Thus, comdivs(p,a) = {1}.  So gcd(p,a) = 1.
* Euclid's Lemma: 1<=a, 1<=b, NgcdQ(n,a,1) and NdivQ(n,a*b) implies NdivQ(n,b)
** Euclid's Lemma:  NgcdQ(n,a,1) and NdivQ(n,a*b) implies NdivQ(n,b).
 Assume:  in(n,N*), in(a,N*), in(b,N*), NgcdQ(n,a,1) and NdivQ(n,a*b)
 To Prove:  NdivQ(n,b).
 Proof:
 Let S = S(t in N* such that NdivQ(n,t*b))
*** subproof: 1<=n and 1<=b implies NidealQ(S)
  (1) S is not empty.
    By assumption, in(a,S). Also, in(n,S) since NdivQ(n,n*b)
  (2) If t and u are in S, then t+u is in S
    t in N* and u in N*. So t+u in N*.
    NdivQ(n,t*b),  so t*b = n*x (for some x)
    NdivQ(n,u*b),  so u*b = n*y (for some y)
    so (t+u)*b = n*(x+y) thus NDivQ(n,(t+u)*b).
    so t+u is in S.
  (3) if t is in S and u is in N* and t+u is in S, then u is in S
   t in N*, NdivQ(n,t*b).  So t*b = n*x for some x
   NdivQ(n,(t+u)*b).  So (t+u)*b = n*z for some z
   so n*x + u*b = n*z . 
   Thus, n|u*b
     Since 1<=u, and 1<=b, also 1<=u*b. Thus n*x < n*z.
     Thus, Nlt(x,z)
     So, there is w in N* with x+w = z
     then n*(x+w) = n*x + n*w = n*z.
     So u*b = n*w (cancellation of addition in N)
     So Ndivq(n,u*b). 
   so u is in S.
   Therefore, S is an ideal in N*. 
*** Remainder of proof
 Let m = NMin(S).  m is in S. m is in N* and NdivQ(n,m*b)
 in(n,S) since NdivQ(n,n*b). Thus NdivQ(m,n) 
 in(a,S) since NDivQ(n,a*b) by assumption. Thus NdivQ(m,a)
 So m is a common divisor of n and a. 
 Since NgcdQ(n,a,1),  m <= 1.  Since m is in S, 1<=m.  Thus m = 1.
 Thus, 1 is in S.
 Thus, NdivQ(n,1*b) so NdivQ(n,b).
 QED.
*** Source of this proof
 The idea is from http://www.sci.brooklyn.cuny.edu/~mate/misc/euclids_lemma.pdf
 (saved in resources/euclids-lemma.pdf)
 The concept of NidealQ was thought of by me; no doubt many others have
 thought of this idea.

** DA 13. If p a prime and 0<a<p and 0<b<p, then p does not divide a*b.
Gauss, Disquisitiones Arithmeticae
  Fix prime p and 0<a<p. Set S = {b,1<=b<p and p|a*b}. To prove S is empty set.
  Assume S is not empty, and derive a contradiction.
  Show gcd(p,a) = 1.
  Let d be divisor of both p and a.
  Since p is a prime, d must be 1 or p.
  if p | a, then p<=a, contradicting a<p.
  Thus d must be 1.
  Thus gcd(p,a) = 1.
  Now suppose b is in S.  Then 0<b<p and p|a*b
   By Euclid's lemma implies p|b, hence p<=b, contradicting b<p. 
  Thus, S is empty, so p does not divide a*b
** DA 14. If p is a prime and 1<=a and 1<=b and p | a*b, then p|a or p|b.
Gauss proof.
  Let r = Rem(a,p), s = Rem(b,p).
  Then 0<=r<p and 0<=s<p.
  If r = 0, then p|a, so we are done.
  If s = 0, then p|b, so we are done.
  If 1<=r and 1<=s.
   a = r (mod p) and b = s (mod p). So, a*b = r*s (mod p).
   Thus, p|r*s, contradicting DA 13.
   
** DA 14 (proved from Euclid's Lemma)
   See 'Corollary 2 to Euclid's Lemma'
* Corollaries to Euclid's Lemma
** 1.  gcd(a,n)=1, 1<=x, a|x, n|x => a*n|x.
  If NgcdQ(a,n,1), 1<=x, and NdivQ(a,x) and NdivQ(n,x), then NdivQ(a*n,x).
  Proof:
  Let b = Nquo(x,a). So in(b,N*) and x = a*b.
  Thus, NdivQ(n,a*b).
  By Euclid Lemma, NdivQ(n,b).
  b = n*k (where k = Nquo(b,n))
  x = a*(n*k) = (a*n)*k.
  Thus, NdivQ(a*n,x). QED.
** 1a. gcd(a,n) = 1, a|x, n|x => n|Quo(x,a).
  By Cor. 1, a*n | x. Let y = Quo(x,a*n). 
  Then a*n*y = x.
  Let q = Quo(x,a) So q = n*y. Thus n|q.
** 1b. gcd(a,n) = 1 and x=y(mod a) and x=y (mod n) => x=y(mod a*n)
  Pf: case x = y. True.
  Case x > y:  Set z = x-y, so 1<=z.   and z = 0 (mod a) and z = 0 (mod n).
  So a|z and n|z.  By Cor. 1, a*n|z.  Thus z = 0 (mod a*n). 
  Thus x = y (mod a*n)
** 2. If p is prime and p|a*b, then p|a or p|b.
 If p is prime and 1<=a and 1<=b and p|a*b, then p|a or p|b.
 Proof: Special cases when a=1 or b=1.
 Suppose 1<a and 1<b.
  Suppose !NdivQ(p,a). 
   Suppose NdivQ(d,p) and NdivQ(d,a).
   Then d = 1 or d = p since NprimeQ(p). Since !NdivQ(p,a), d != p, so d = 1.
  Thus gcd(p,a) = 1.  Thus (Euclid's Lemma), NdivQ(p,b).
** 3. gcd(a,n)=1 & gcd(b,n)=1 =>  gcd(a*b,n) = 1
  Suppose gcd(a,n) = 1 and gcd(b,n) = 1
  Now, Suppose NdivQ(d,a*b) and NdivQ(d,n). 
  The assumption d!=1 leads to a contradiction, as follows.
   There is a prime p so that NdivQ(p,d) (defn of 'prime').
   Thus, NdivQ(p,a*b) and NdivQ(p,n)
   By Euclid's Lemma Corollary 2, p|a or p|b.
   But p does not divide a.
    If p|a, then p|a and p|n, so p<=gcd(a,n) = 1,
     but 1<p since p is a prime.  
     Thus, p does not divide 'a'.
   Similarly: p does not divide 'b'
   We have a contradiction.
 Thus, d = 1.  
 Thus gcd(a*b,n) = 1.
 QED.
  
** 4. if 1<=m and f:m->N* is a finite sequence and A(i, in(i,m) implies gcd(f(i),n) = 1), then
  gcd(NprodSeq(f),n) = 1.  Informally, gcd(f(1)*...*f(m),n) = 1.
  Proof by induction on m.
  Case m=1 trivial.
  Assume for 1<=m. To prove for f:m+1->N*.
   A(i, in(i,m+1) implies gcd(f(i),n) = 1)
  NprodSeq(f) = NprodSeq(restriction(f,m)) * f(m)
  Inductive assumption applies to restriction(f,m),
   so gcd(NprodSeq(restriction(f,m)),n) = 1>
  Also, gcd(f(m),n) = 1.
  Now Corollary 3 Implies gcd(NprodSeq(restriction(f,m)) * f(m),n) = 1.
  QED
** 5. if p and q are primes and p!=q, then gcd(p,q) = 1
      Suppose d in comdivs(p,q). So d|p, d|q. We show d = 1.
      p!=1 and q!=1.
      Since p is prime, d = 1 or d = p.
      Since q is prime, d = 1 or d = q.
      If d = p, then p|q so p = 1 or p = q, neither of which is possible.
      Thus d = 1.
      Thus gcd(p,q) = max(comdivs(p,q)) = max({1}) = 1. 
** 6. if 1<=n and 1<=k and 0<=i<=k, then n**i|n**k
      There is j in N with k = i+j.
      n**k = n**(i+j) = (n**i)*(n**j) by a 'law of exponents' in N.
      Thus n**i | n**k.
** 7. if n is prime and 1<=k and q is prime and q | n**k, then q = n.
      Induction on k.
      Case k = 1. Then n**k = n. So q | n. 
       Since n is prime, q = 1 or q = n.  
       Since q is prime, q != 1.  Thus, q = n.
      Inductive hypothesis: Assume 1<=k and that q|n**k implies q = n.
       Now assume q | n**(k+1).  
       n**(k+1) = (n**k)*n  (a law of exponents)
       So q | (n**k)*n. By Corollary2 to Euclid's lemma,
        q|n**k  or q |n.
        if q|n, then q|n**1, so q = n by case k=1
        and if q|n**k, then q = n by inductive hypothesis.
      By induction, if 1<=k and q|n**k, then q = n. QED.
** 8. if n is prime and 1<=k, then divisors(n**k) = {n**i, i<=k}
      Let A = divisors(n**k) and B = {n**i, i<=k}.
      By 6, B is a subset of A.
***   Use induction on k to prove that A is subset of B.
      For 1<=k, let A(k) = divisors(n**k) and B(k) = {n**i, i<=k}.
      To prove A(k) is subset of B(k) for all k in N with 1<=k.
      Case k = 1.
       n**1 = n. Since n is prime, A(1) = divisors(n) = {1,n} = B(1). So leq(A(1),B(1)).
      Inductive hypothesis: leq(A(k), B(k)).
      To show A(k+1) is subset of B(k+1).
       Let d be an element of A(k+1).  Thus d | n**(k+1).
       We must show d is in B(k+1).
       Choose a prime q such that q | d. So q | n**(k+1).
       By 7, q = n.
       Thus d = n*a (a = Quo(d,n))
       Thus n*a | n*(n**k).  
       Thus a | n**k.
       i.e, a is in A(k).  By inductive hypothesis, a is in B(k). Choose i<=k with
       a = n**i.
       Thus d = n*(n**i) = n**(i+1), and i+1 <= k+1.  Thus d is in B(k+1).
      By induction, A(k) is a subset of B(k) for all k.
***   Thus A = B.

** 9. if p and q are primes and p!=q and 1<=j and 1<=k, then gcd(p^j,q^k) = 1
   Let r be a prime which divides both p^j and q^k. We show r = 1.
    By 7, r = p.  And r = q.
    Thus p = q, contrary to assumption.
   Thus gcd(p^j,q^k) = 1
* Nprimes, NprimePowers, PrimePowerRep(n), Fundamental theorem of arithmetic
  Nprimes = {p:NprimeQ(p}  the set of all primes
  FTA informal 1: Any positive number but 1 is uniquely expressable as
    a product of positive prime powers.
  FTA informal 2: every integer greater than 1 can be represented uniquely as a product of 
    prime numbers, up to the order of the factors. (wikipedia)
  I'm unsure how to 'formalize' FTA.
  Let NprimePowers = {p^k where p is a prime and 1<=k}.  Here '^' is exponentiation operation.
  If p^j = q^k  (p,q prime  1<=j, 1<=k) then p = q && j=k.
    Let x be in NprimePowers.  Set PrimeBase(x) = p and PrimeExponent(x) = k, 
     where x = p^k.
  If S is a finite non-empty subset of NprimePowers, then 1 < NprodSet(S).
  Define: FTAQ(S) iff
    a) S is a finite non-empty subset of NprimePowers &&
    b) for all s1,s2 in S with s1!=s2 we have PrimeBase(s1) != PrimeBase(s2).
** If S is a finite subset of NprimePowers and prime p | NprodSet(S), then p|s where
   s is in A.
   Proof: Induction using corollary 2 of Euclid Lemma
** If FTAQ(S) and p prime and s1, s2 in S and p|s1 and p|s2, then s1 = s2.
   s1 = p1^k1,  s2 = p2^k2.  Thus p1 = PrimeBase(s1) and p2 = PrimeBase(s2).
   Also p1 and p2 are primes, and 1<=k1 and 1<=k2.
   Since p|p1^k1, then p = p1 (Corollary 7 of Euclid Lemma).
   Similarly, p = p2.
   Thus, PrimeBase(s1) = PrimeBase(s2).
   If s1 != s2, then  PrimeBase(s1) != PrimeBase(s2), since FTAQ(S).
   Thus s1 = s2.
** TODO If FTAQ(S) and FTAQ(T) and NprodSet(S) = NprodSet(T), then S = T
   Let x in S. Then x | NprodSet(S) so x | NprodSet(T).
   x = p^k where p is prime and 1<=k. T
   Further, if T is also a finite non-empty subset of NprimePowers, and
    if NprodSet(S) = NprodSet(T), then S = T.
  And if 1 < n, then there exists a unique finite non-empty subset S of NprimePowers 
   such that n = NprodSet(S).
   We can define PrimePowerRep(n) = S for 1<n.
  
  Let NprodSetF: NprimePowers -> N* be defined by the formula NprodSetF(S) = NprodSet(S).
  Then NprodSetF is a bijection.
  Given a finite subset S of NprimePowers, we can define one bijection f:NCard(S) -> S so
    so that i<j implies PrimeBase(f(i)) < PrimeBase(f(j))
  
* Quo properties with Division. Quo(a,b) == (a/b) NOTATION
  For 1<=a, 1<=b,   Quo(a,b) and Rem(a,b) are the unique q,r in N with
  (a) a = b*q + r and (b) 0<=r<b.
  If b|a, then a = b*Quo(a,b)
  If a|b|c, then Quo(c,a) = Quo(c,b)*Quo(b,a)
  
** DA 22: k|a, k|b, a=b (mod m), gcd(k,m) = 1 => Quo(a,k) = Quo(b,k) (mod m)
  Clear if a = b. Otherwise, assume a>b
  Let x = Quo(a,k), y = Quo(b,k). So 1<=x, 1<=y and
  a = k*x, b = k*y.
  Let z = x-y. So 1<=z, k*z = 0 (mod m). So m|k*z.  Thus, m|z (Euclid Lemma)
  So, z = 0 (mod m) So x = y (mod m).
 
** DA 22a  Corollary:
  If k|c and m|c and gcd(k,m) = 1, then Quo(c,k) = 0 (mod m)
  Proof:
  Thus, k*m | c (Corollary 1 to Euclid Lemma).
  k | k*m | c. 
  c = (c/k)*k = (c/m)*m.
  m | (c/k)*k and gcd(m,k)=1 implies m|(c/k).  Euclid Lemma.
** DA 22x: k|c and m|c and gcd(k,m) = 1  => m | Quo(c,k).
  By Euclid Lemma, k*m|c. So c = (k*m) * Quo(c,k*m) = k* (m*Quo(c,k*m))
  Since k|c, c = k*Quo(c,k).
  Thus  k*(m*Quo(c,k*m)) = k*Quo(c,k).
  So m*Quo(c,k*m) = Quo(c,k).
  Thus, m | Quo(c,k). QED.
  
** DA 22by:  k|c, m|c, d=gcd(k,m) => Quo(m,d) | Quo(Quo(c,d), Quo(k,d))
  d = gcd(k,m).   d|k and d|m.
  gcd((k/d), (m/d)) = 1 (DA 22a)
  Apply DA 22x: 
  (k/d)|(c/d) and (m/d)|(c/d) and gcd((k/d),(m/d)) = 1 implies
     (m/d) | Quo((c/d),(k/d))
  d|k|c thus: (c/d) = (c/k)*(k/d)  [so (k/d)|(c/d)]
  d|m|c thus: (c/d) = (c/m)*(m/d)  [so (m/d)|(c/d)]
  So, (m/d) | Quo((c/d),(k/d))).

** DA 22bx k|c, m|c => Quo(m,gcd(k,m)) | Quo(c,k)
   d = gcd(k,m)
   d|k|c Thus (c/d) = (c/k)*(k/d)
   d|m|c Thus (c/d) = (c/m)*(m/d).

   To show: (m/d) | (c/k)
   (m/d) | (c/k)*(k/d).
   gcd((k/d),(m/d)) = 1
   Quo(m,d) | Quo( Quo(c,d), Quo(k,d) )
   6 | 36, 12 | 36,  gcd(6,12)=6  => Quo(12,6) | Quo(36,6) [2 | 6]
   
** DA 22b: k|a, k|b, a=b (mod m) => Quo(a,k) = Quo(b,k) (mod Quo(m,gcd(k,m)))
   6 | 36, 6 | 0, 36 = 0 (mod 9) => Quo(36,6) = 0 (mod 3)  Check.
  Let d = gcd(k,m), x = Quo(a,k), y = Quo(b,k). 
  Let m1 = (m/d) d|m, so m = d*(m/d)
  To show: (a/k) = (b/k) (mod (m/d))

  k | a, so a = k*(a/k)
  k | b, so b = k*(b/k)

  By DA22a, gcd((k/d), (m/d)) = 1. 
  d|k|a Thus : (a/d) = (a/k)*(k/d)
  d|k|b Thus : (b/d) = (b/k)*(k/d)

  Assume a>b and c = a-b.   
  Thus c = 0 (mod m).
  d|k|c  Thus (c/d) = (c/k)*(k/d)
  To Show: (c/k) = 0 (mod (m/d)) i.e., (m/d) | (c/k)
 
  d|m|c. Thus (c/d) = (c/m)*(m/d)

  
  (k/d) | (a/d),  (k/d) | (b/d)
  
  (a/k) = (b/k) (mod (m/d)) ?
   a = b (mod m)
   
   m | c.  c = (c/m)*m
   k | c,  m | c.  
   To Show: (c/k) = 0 (mod (m/d))
   
   
  Suppose k1|a1 and k1|b1, and a1=b1 (mod m1)  TO SHOW
  Then by DA22, Quo(a1,k1) = Quo(b1,k1) (mod m1).
  Quo(a1,k1):   a = a1*d, k = k1*d, m = m1*d .

  a|b|c => Quo(c,a) = Quo(c,b)*Quo(b,a)
     Quo(c,b)|Quo(c,a)  and Quo(b,a) | Quo(c,a)
  Quo(Quo(c,a),Quo(b,a)) = Quo(c,b)
  ((c/a)/(b/a)) = (c/b).

   Proof:
   a|c.  Thus, c = a*Quo(c,a)
   b|c.  c = b*Quo(c,b)
   a|b.  b = a*Quo(b,a)
    c = a*Quo(b,a)*Quo(c,b)
   Thus Quo(c,a) = Quo(b,a)*Quo(c,b) = Quo(c,b)*Quo(b,a)
   (c/a) = (c/b)*(b/a)
   
  
* Legendre theorem on number of roots of a polynomial over a field
Let K be a field, and let f be a non-zero polynomial 'over' K.
Let d be the degree of f and let R be the set of roots of f in K.
Then R is a finite set with d or fewer elements.
Proof by induction.
 Proposition n for n in N:  For all non-zero polynomials f with degree(f) = n,
 Card(roots(f)) <= n.
Case n = 0.  Take f a non-zero polynomial with deg(f) = 0.  
For any
  a in K, f(a) = c0  (where c0 is the 0-th coefficient of f)
  Since f != zero polynomial, c0 != 0.  Thus a is not a root of f.
  So roots(f) = empty set, whose cardinality is 0. 
  Thus Card(roots(f)) <= deg(f)
Inductive hypothesis Assume for n.
  Let f be a non-zero polynomial with deg(f) = n+1.
  Case f has no roots, then roots(f) = 0 empty set; so Card(roots(f)) = Card(0) = 0,
   and 0 <= n+1, so Card(roots(f)) <= deg(f).
  Case f has a root.
  Let a be a root of f. Let g = X-a (polynomial in K). deg(g) = 1.
  Since K is a field, the division algorithm applies to division of f by g.
  Thus there are polynomials q and r in K[X] with
   f = g*q + r, and either r = 0 polynomial, or deg(r) < deg(g).
   Thus, deg(r) = 0.
   So f(a) = g(a)*q(a) + r(a).  = 0*q(a) + r(a) = r(a). Since a is a root
   of f, f(a) = 0, so r(a) = 0.  So, since r = 0 in K[X].
   Thus, f = g*q.
   Since f is not the zero polynomial, q also is not the zero polynomial.
   Now deg(f) = deg(g) + deg(q), so n+1 = 1 + deg(q), so deg(q) = n.
   By inductive hypothesis, Card(roots(q)) <= n.
   Suppose b is in K.  Then f(b) = g(b)*q(b).  So, b is a root of f if and
   g(b)*q(b) = 0; since K is a field, u*v = 0 iff (u=0 or v=0) in K.
   Thus either b is a root of g or b is a root of q.
   But there is just 1 root of g (namely 'a'). So
   card(roots(f)) = card(union(roots(g),roots(q))) 
                  <= card(roots(g)) + card(roots(q))
                  <= 1 + n = deg(f).
Now the proof is completed by induction.
* ring structures Nring(n)  (NSum(n), NProd(n))
** The set N*
  Let N* = 1,2,3,... (positive integers)
  By one definition, for n in N*,  n = S(k,in(k,N) and Nlt(k,n)).
  e.g., 1 = {0}, 2 = {0,1}, 3 = {0,1,2}, etc.  
  This definition due to Von Neumann (ref: https://en.wikipedia.org/wiki/Natural_number)
** For n in N, the cardinality of the set n is n:  NCard(n) = n.
  This has been proved in pyfol4c.  Specific reference?
** Nring(n), NSum(n), NProd(n), NPower(n)
  Let n be in N*.
  Nring(n) is the ring of integers modulo n.  Its underlying set is n.
  For a, b in n define modular product and sum,
   NSum(n)(a,b)  = Rem(a+b,n).
   NProd(n)(a,b) = Rem(a*b,n)
   NPower(n)(a,k) = Rem(a**k,n)  for k in N. If a = 0, should  we take 0**0 = 1 ?
  By defining properties of Rem, we have NProd(n)(a,b) and NSum(n)(a,b) in 'n'.
  Let R(a) = Rem(a,n).  
** commutativity of NSum(n)
  Let f(a,b) = R(a+b)
  Let lhs = f(a,b), rhs = f(b,a)
  lhs = R(a+b)
      = R(b+a)
      = rhs
** associativity of Nsum(n)
  Let f(a,b) = R(a+b)
  lhs = f(f(a,b),c) = R(f(a,b)+c) = R(R(a+b)+c) = R((a+b)+c)
  rhs = f(a,f(b,c)) = R(a+f(b,c)) = R(a+R(b+c)) = R(a+(b+c))
  Since (a+b)+c = a+(b+c)  (associativity in N addition),
  conclude R((a+b)+c) = R(a+(b+c)).
  So, lhs = rhs.
** commutativity of NProd(n)
  Let f(a,b) = R(a*b)
  Let lhs = f(a,b), rhs = f(b,a)
  lhs = R(a*b)
      = R(b*a), since a*b = b*a in N
      = rhs
** associativity of NProd(n)
  a,b,c in N  
  Let f(a,b) = R(a*b).
  lhs = f(f(a,b),c) = R(f(a,b)*c) = R(R(a*b)*c) = R((a*b)*c)
  rhs = (a,f(b,c)) = R(a*f(b,c)) = R(a*R(b*c)) = R(a*(b*c))
  (a*b)*c = a*(b*c) by associativity in N.
  so R((a*b)*c) = R(a*(b*c))
  so lhs = rhs.

** distributivity of NProd(n) over NSum(n)
  Let f(a,b) = R(a+b),  Let g(a,b) = R(a*b).
  Let a,b,c in set 'n'. [Roughly, to show (a+b)*c = (a*b) + (a*c)]
  lhs = g(f(a,b),c) 
      = R(f(a,b)*c) 
      = R(R(a+b)*c)
      = R((a+b)*c)
      = R((a*c)+(b*c)) by distributivity in N,+,*
  rhs = f(g(a,c),g(b,c))
      = f(R(a*c),R(b*c))
      = R(R(a*c)+R(b*c))
      = R((a*c)+(b*c))
  lhs = R((a+b)*c) 
** 0 in n is the additive identity for NSum(n)  (Since 0<n)
  Since 0<n,  0 is in n.
  Let f(a,b) = R(a+b) for a,b in N.
  Now, let 'a' be in the set 'n'. Then a is also in N. So
  Then f(a,0) = R(a+0) = R(a)
   = a, since a in 'n'.
** If 1<n, then 1 is the multiplicative identity in 'n', and and 0 != 1 in 'n'.
  Let f(a,b) = R(a*b) for a,b in N.
  Since 1 < n, we have 1 is an element of set 'n'.
  Let 'a' also be in set 'n'. (i.e., a is in N and a<n)
  f(a,1) = R(a*1) = R(a) = a.
* RemF(n): N -> n  compatible with sums and products
  RemF(n)(x) = Rem(x,n), by definition.
  Let x, y in N.
** RemF(n)(x+y) = NSum(n)(RemF(n)(x),RemF(n),y)
  lhs = Rem(x+y,n)
  rhs = NSum(n)(Rem(x,n),Rem(y,n)) 
      = Rem(Rem(x,n)+Rem(y,n),n)
  Apply division of x by n and of y by n. 
  x = a*n + Rem(x,n)
  y = b*n + Rem(y,n)
  Also divide Rem(x,n)+Rem(y,n) by n
  Rem(x,n)+Rem(y,n) = c*n + Rem(Rem(x,n)+Rem(y,n),n) = c*n + rhs
  Thus,
   x+y = (a+b+c)*n + rhs.
  Since rhs < n, we conclude rhs = Rem(x+y,n) = lhs.
** RemF(n)(x*y) = NProd(n)(RemF(n)(x),RemF(n),y)
  lhs = Rem(x*y,n)
  rhs = NProd(n)(Rem(x,n),Rem(y,n)) 
      = Rem(Rem(x,n)*Rem(y,n),n)
  Apply division of x by n and of y by n. 
  1) x = a*n + Rem(x,n)
  2) y = b*n + Rem(y,n)
  Also divide Rem(x,n)*Rem(y,n) by n
  3) Rem(x,n)*Rem(y,n) = c*n + Rem(Rem(x,n)*Rem(y,n),n) = c*n + rhs
  Also, divide x*y by n:
  4) x*y = e*n + lhs where lhs < n 
  Now apply 1-3 to get another expression for x*y:
  5) x*y = (a*n)*(b*n) + (a*n)*Rem(y,n) + (b*n)*Rem(x,n) + Rem(x,n)*Rem(y,n)
  Also, divide Rem(x,n)*Rem(y,n) by n:
  6)  Rem(x,n)*Rem(y,n) = c*n + rhs where rhs < n
  Apply 6) to 5), 
  7) x*y = d*n + rhs  (where d = a*n*b + a*Rem(y,n) + b*Rem(x,n) + c
  Compare expressions 4 and 7; 
  By uniqueness of Quotient and remainder, lhs = rhs  (and also e = d)
  QED.
** restriction(RemF(m),n) function from Nring(n) to Nring(m)  (1<=n, 1<=m)
  h = Res(RemF(m),n) is a function from Nring(n) to Nring(m) ,
   where 'Res' means 'restriction''
  This makes sense since : If in(n,N), then 'n' is a subset of N.
  for x in n, h(x) = Rem(x,m).
** Lemma 1: if NDivQ(m,n) and x in N, then Rem(Rem(x,n),m) = Rem(x,m)
  Write n = m*k.
  Divide x by n:  x = n*q + r (r <= n).   r = Rem(x,n)
  Divide r by m:  r = m*u + s (s <= m)    s = Rem(r,m)
  x = (m*k)*q + m*u + s = m*(k*q + u) + s (s <= m)
    So s = Rem(x,m).
  QUED
** if NDivQ(m,n), then h is compatible with sums
  Take x,y in n.  
  h(NSum(n)(x,y)) = NSum(m)(h(x),h(y)) ?
  lhs = rhs ?
  NSum(n)(x,y) = Rem(x+y,n)
  lhs = Rem(Rem(x+y,n),m)
  h(x) = Rem(x,m), h(y) = Rem(y,m)
  rhs = Rem(h(x)+h(y),m)
      = Rem(Rem(x,m) + Rem(y,m),m)
      = Rem(x+y,m)  Since RemF(m) is compatible with NSum and NSum(m)
  By lemma 1, 
  lhs = Rem(x+y,m)
  Thus, lhs = rhs.
** if NDivQ(m,n), then h is compatible with products
  Completely analogous proof
  
** If m divides n, then Res(RemF(m),n) is a ring homomorphism
* If p is a prime, then Nring(p) is a field
  It remains to show the existence of multiplicative inverse for non-zero elements of 'p'.
  Let a in p and a != 0. Thus 1<=a<p. 
  We search for 'z' in p with Nring(a,z) = 1.
  Since p is a prime, gcd(a,p) = 1.
  Thus, by Bezout corollary 2 there is x with 1<=x and Rem(a*x,p) = 1.
  Let z = Rem(x,p). Then z is in p.
  To show: NProd(p)(a,z) = 1.
   NProd(p)(a,z) = Rem(a*z,p) = Rem(a*Rem(x,p),p).
                 = Rem(a*x,p)  [property of Rem]
                 = 1.
  Thus z is a multiplicative inverse of 'a' in Nring(p).
  if also w is a multiplicative inverse of 'a' in Nring(p), then
   Nring(p)(a,w) = Rem(a*w,p) = 1.
  (incomplete)  a*z = a*w, so a*(z-w) = 0 (mod p). Since a!=0, we must have z-w = 0 or z=w. 
  So we may speak of 'the' multiplicative inverse of 'a' in Nring(p)
* Wilson's theorem: If p is a prime, then (p-1)! = -1 (mod p).

Proof:
 Consider the set A of numbers from 1 to p-1.
 Recall that Nring(p) is a field.
 For x in A, there is y in A with x*y = 1 (mod p)
 Define function f from A to subsets of A by
 f(x) = union({x},{inverse(x)}), where inverse(x) in A is the multiplicative
 inverse of x modulo p (inverse(x) exists since Nring(p) is a field).
   (e.g. if p = 5, inverse(2) = 3 since 2*3 = 6 == 1 (mod 5)).
** f(1) = {1}
 inverse(1) = 1.
** f(p-1) = {p-1}
  (p-1)*(p-1) = p*p -2*p + 1 = 1(mod p).
  Thus, inverse(p-1) = p-1.
  So, f(p-1) = {p-1}
** if 1 < x < (p-1),  then inverse(x) != x:
   Proof: Let y = inverse(x), so x*y = 1 (mod p). Suppose y = x.
   Then x*x = 1 so (x-1)*(x+1) = 0 (mod p). Thus, since p is a prime,
   x = 1 (mod p) or x = p-1 (mod p).  But by assumption, x is neither 1 nor
   p-1.  Thus, y != x.
** Let P = range(f). Then P is a partition of A
 Then P consists of two one-element sets {1) and {p-1} and,
 any other subsets have 2 elements.
 Further, the elements of P are disjoint.
  Proof.  Tedious but believed elementary.
 And Further, any element a in A is a member of some element of P.
 Thus, P is a partition of A.
** (p-1)! = p-1 (mod p)
 Thus, (p-1)! = product(prod(s) for s in P). Weak notation!
   prod({1}) = 1,
   prod({p-1}) = p-1, 
   if x !=1 and x!= p-1  then f(x) = {x,inverse(x)} 
     So,  prod(f(x)) = x*inverse(x) mod(p) = 1.
  Thus, (p-1)! = p-1 (mod p)
** Example: p = 7
  A = {1,2,...,6}
  P = {{1},{2,4},{3,5},{6}}
  (p-1)! = 1*(2*4)*(3*5)*6 = 1*6 (mod p) = p-1

* cumulative products and set products
   For any binary operation (G,e,*) with neutral element we can define the
   notion of a 'cumulative' product of a finite sequence s in G.
   s is a function whose domain is in N.
   This can be made precise via recursion.
   If domain(s) is empty, we set cumprod(s) = e.
   if domain(s) = n + 1, cumprod(s) = cumprod(restriction(s,n))*s(n).
   
   When the operation is commutative and associative, if 
    f is any bijection (permutation) of domain(s), then
    s#f is also a finite sequence in G and cumprod(s#f) = cumprod(s).

   Now suppose U is a finite subset of (G,e,*).
   There are bijections s: NCard(U) -> U. Any such bijection is a
   finite sequence in G, so cumprod(s) is defined as an element of G.
   And, If t is any other bijection t: NCard(U) -> U, then
   there is a permutation f of NCard(U) so that t = s#f; and
   cumprod(t) = cumprod(s).
   Thus, we may define setProd(U) = cumprod(s) for any such s:NCard(U)->U.
   
   Let's call finsets(G) to be the set of finite subsets of G.
   Thus, there is a function setProdF: finsets(G) -> G such that
     setProdF(U) = setProd(U) for any finite subset of G.
   Suppose u is a finite sequence in finsets(G).
   Then setProdF#u is a finite sequence in G.
   Thus cumprod(setProdF#u) makes sense.
   
   etc. etc.
* Wilson's theorem in context of finite abelian groups
  Let G,e,* be a finite abelian group. (We use multiplicative notation for
  the group operation.)
  Wilson Theorem:  setProd((x: x in G}) = setProd({x: x in G and x*x = e}).
 Proof idea:
  Let w = prod  the product of all the elements of G.
  Let G0 = {x: x in G and x*x = e}
  Let G1 = {x: x in G and x*x != e}
  Then {G0,G1} is a partition of G.
  prod {x: x in G} = prod(G0)*prod(G1),Since the group operation
   is commutative and associative.
  prod(G1) = e. The following sketches a proof.
   For x in G1, let p(x) = {x,inverse(x)}.  This is a two-element set,
    since for x in G1, inverse(x) != x.
   Let P = {p(x): x in G1}.   P is a partition of G1.
   Let m1 = NCard(P). Let f: m1 -> P be a bijection.
   Let g: m1 -> g be defined by g(i) = prodSet(f(i)).
    For i in m1, there is x in G with f(i) = {x,inverse(x)} and inverse(x)!= x.
    Thus g(i) = x*inverse(x) = e.
   Thus, prod(g) =  e.
   Also, prod(G1) = prod(g).
   Thus, prod(G1) = e. 
  Thus prod{x:x in G} = prod(G0)*e = prod(G0).
  QED.
* Fermat's little theorem: If p is prime and gcd(p,a) = 1, then a^(p-1) = 1 (mod p).
i.e. p does not divide a, and a != 0.
Let A be the set of integers x such that 1 <= x <= p-1.
We can assume a is in A.
  other wise, replace a with its remainder upon division by p.
Let f be the function from A to A defined be f(x) == a*x (mod p).
  (i.e., f(x) is the remainder mod p of a*x).
Now if f(x) = f(y), then a*(x-y) = 0 (mod p). Since p is a prime,
Euclid's lemma applies to show p divides a or p divides x-y.
But p does not divide a (since 1<=a<=p-1), so p divides x-y.  
Since x and y are both in A,  x is identical to y.
Thus, the function f is an injection.
Further, since A is finite, f is therefore a bijection.  i.e., 
f is a permutation of A.
Now, consider the product(f(x) for x in A) = (p-1)!.
But, on the other hand, it is (a*1)*(a*2)*(a*3)...*(a*(p-1)) 
Now by associativity and commutativity of multiplication this is
 (a^(p-1)) * (p-1)!.  Then, again since we are in mod p arithmetic with p
a prime, we can cancel (p-1)! to get a^(p-1) = 1 (mod p). QED
* Fermat little theorem in context of finite abelian group
  Let G,e,* be a finite abelian group. (We use multiplicative notation for
  the group operation.) Let m = order (cardinality) of G.
  Theorem: if a is in G, then a**m = e.
** Proof: Let a1,...,am denote the elements of G.
  Let p = product of elements of G  (p = a1*...*am).
  Let f: G->G be translation by a  (f(x) = a*x).
  Then f is a permutation of G.
  Let q = f(a1)*...f(am).  Thus q = p.
  But also q = (a*a1)*...*(a*am) = 
    (a*...*a)*(a1*...*am) =
    (a**m)*(a1*...*am) = (a**m)*p
  Thus (a**m)*p = p.  Thus a**m = e. QED.
** Comment on proof.  A complete proof requires notions:
   - sequence of elements
   - cumulative product of a sequence of elements w.r.t. a binary operation
   - stability of a product under a permutation
   - finite power of an element w.r.t. a binary operation (a**m).
** Corollary 1: Fermat little theorem (another proof)
   G = {1,...,p-1}.  * = multiplication mod p, e = 1.
** Corollary 2: Euler totient theorem
   with G = relprimes(n), * = multiplication mod n, e = 1
   By definition, NCard(G) = ephi(n).
   * = multiplication mod n.
   e = 1.
   If a is in G, then a**ephi(n) = 1 (mod n)
   Example 1: If n is a prime, then relprimes(n) = {1,...,n-1} so this
     is Fermat's little theorem.
   Example 2: n = 8.  Relprimes(8) = {1,3,5,7}
    ephi(8) = 4.  3**4 = 9*9 = 1*1 = 1 (mod 8)
              5**4 = 25*25 = 1*1 = 1 (mod 8)
              7**4 = 49*49 = 1*1 = 1 (mod 8)
** Corollary 3: 1<=n, G = {0,...,n-1}, * = addition mod n, e = 0.
   Not particularly interesting.
   0+1+...+(n-1) = 0 (mod n)
   note (0+1+...+(n-1)) = (n-1)*n/2.  If n is odd, then n divides 0+...+(n-1)
   Gauss's trick:
    0+1+...+100 = 
    (1+100) + (2+99) + ... + (50+51) =
    101*50 

* if p is a prime and d divides p-1, then x^d - 1 = 0 (mod p) has d solutions in field on p
  When d = p-1, there are p-1 solutions to a^(p-1) - 1 = 0 (mod p) [Fermat Little Theorem]
  Also clear when d = 1.
  Let d be some other divisor of p-1: p-1 = d*k  (1<d<p-1 and 1<k<p-1).
  Let F = the field of residues mod p: {0,1,...,p-1}
  Let h = X^(p-1) - 1  (a polynomial in F[X]). deg(h) = p-1
  Let f = X^d - 1 (also in F[X]). deg(f) = d
** Preliminary: 1<=n implies Y-1 divides Y^n - 1 in R[Y].
 Assume R is a ring with unit [Not sure of minimal assumptions on R].
 Work in R[Y] (polynomials with coefficients in R).
 n = 1:  Y-1 divides Y^1 - 1  (Y-1)*1 = Y^1 - 1 
 Induction:There is f in R[Y] so that (Y-1)*f = Y^n -1
 Y^(n+1) - 1 = Y*Y^n - 1 = Y*(Y^n - 1) + (Y - 1) = 
        Y*(Y-1)*f + (Y-1) = (Y-1)*(Y*f + 1)  [so Y-1 divides Y^(n+1)]
 QED by induction.
 If we define g(1) = 1, g(k+1) = Y*g(k) + 1, then for all n>=1,
  Y^n - 1 = (Y-1)*g(n).  
 In fact, g(n+1) = 1 + Y + ... + Y^n  
** Alternately: y-1 divides y^n - 1 for n>=1 and y in R with y!=1
 If R is a ring with unit, and y is in R and y-1!=0 in R, and
 if n>=1, then y-1 divides y^n - 1.
 Define sequence g in R (starting at 1) by :
  g(1) = 1, g(k+1) = y*g(k) + 1 (1<=k)
 Then for n>=1, y^n - 1 = (y-1)*g(n)  Proof is by induction
** If a in R and 1<=d and 1<=k and a^d != 1, then a^d - 1 divides a^(d*k)- 1 in R.
 Proof: Set y = a^d and n = k in the prior theorm.
 Thus (a^d - 1) divides (a^d)^k - 1
 Note (a^d)^k = a^(d*k) (one of the laws of exponents)
 Result follows.
** If a in R and d|n in N and a^d != 1 then a^d - 1 divides a^n - 1 in R.
 Proof:  Assume R a ring. 
 Suppose d | n where 1<=n. Choose k>=1 so that n = d*k.
 From previous result, a^d - 1 divides a^(d*k)- 1 in R.
 The result follows since n = d*k.

** If d|n in N , then X^d - 1 divides X^n - 1 in K[X]
   Possible conditions on K:  K a field.  
   We need the assumptions to imply X^d != 1 in K[X].
   Take R = K[X] in prior theorem.  
   Result follows from prior theor
** if d|n in N and (X^n - 1) has n distinct roots in field K, then (X^d - 1) has d distinct roots
   Let f = X^d - 1 and h = X^n - 1.
   By prior theorem, f | h in K[X].
   Let g in K[X] be the quotient h/f, so h = f*g.
   deg(h) = deg(f) + deg(g).  fact about deg in K[X]
   NCard(roots(h)) = deg(h).  Assumption
   NCard(roots(f)) <= deg(f). Legendre's theorem, since K is a field
   NCard(roots(g)) <= deg(g). Ditto
   roots(h) = union(roots(f),roots(g)) 
   Thus NCard(roots(h)) <= NCard(roots(f)) + NCard(roots(g)) 
        deg(h) <=   NCard(roots(f)) + NCard(roots(g))  <= deg(f) + deg(g) == deg(h)
   Thus,  NCard(roots(f)) + NCard(roots(g))  = deg(f) + deg(g)   (*1)
   If NCard(roots(f)) < deg(f), then
      NCard(roots(f)) + NCard(roots(g)) < deg(f) + NCard(roots(g)) <= deg(f) + deg(g)
      Thus NCard(roots(f)) + NCard(roots(g)) < deg(f) + deg(g),
           which contradicts (*1)
   Thus NCard(roots(f)) = deg(f), as was to be proved.
   Similarly, NCard(roots(g)) = deg(g)
   QED
** If p is a prime and d|p-1, then (X^d - 1) has d distinct roots in Field (p)
   Proof: p has a field structure (NSum(p), etc.).
   We want to apply previous theorem with K = Field(p), n = p-1
   Let d | n.
   By Fermat's little theorem for any a in relprimes(p), a^(p-1) = 1 (mod p),
    i.e. a is a root of X^n - 1 == 0 (in F[X])
   Conversely, if a in p is a root of X^n - 1, then a^n = 1 (mod p);
        furthermore a != 0, and relprimes(p) = {1,...,p-1} since p is prime.
        Thus a is in relprimes(p)
   Thus roots(X^n - 1) = relprimes(p)
      Thus NCard(roots(X^(p-1) - 1)) = NCard(relprimes(p)) = p-1.
   So previous theory applies, and gives the conclusion.
**
   
** Unused
*** Preliminary: For 1<=d and 1<=n, X^d - 1 divides X^(d*n) - 1 in F[X]
 Take R = F[X] and take X for 'a'. 
 Note deg(X^d) = d and deg(1) = 0 and d != 0
 Thus  X^d - 1 != 0 in R. 
 Thus, X^d - 1 divides X^n - 1 (by the previous )
*** There is g in F[X] with h == f*g.  
   Apply the previous with n = k. 
  
*** There is g in F[X] with h == f*g.  deg(g) = (p-1-d)
  g = 1 + X^(d*1) + ... + X^(d*(k-1))
  roots(h) = {1,...,p-1} in F  (Fermat's little theorem)
           = union(roots(f),roots(g))  since F is an integral domain
  Let nh = Card(roots(h)).  So nh = p-1
  Let nf = Card(roots(f)), ng = Card(roots(g)).
  Now nf <= deg(f) and ng <= deg(g)  By Legendre theorem for field F.
  Suppose nf < deg(f) OR ng < deg(g), Then
   p-1 == nh <= Card(union(roots(f),roots(g))) 
             <= nf + ng 
             < deg(f) + deg(g) = p-1, A contradiction.
  Thus nf == deg(f) == d, and ng == deg(g) == (p-1-d).
  QED.
*** f has d distinct roots, and g has (p-1-d) distinct roots.
   deg(f) == d, and deg(g) == (p-1-d).
   By Fermat little theorem, h has p-1 distinct roots : {1,2,...,p-1}.
   So deg(h) = Card(roots(h))
   And deg(h) = deg(f) + deg(g).
   Also roots(h) = union(roots(f),roots(g))  since F is a field.
   So Card(roots(h)) <= Card(roots(f)) + Card(roots(g))
   and Card(roots(f)) <= deg(f), and Card(roots(g)) <= deg(g) (Legendre thm.)
   If Card(roots(f)) < deg(f), then 
     deg(h) < deg(f) + Card(roots(g)) <= deg(f) + deg(g),
     So deg(h) < deg(h), which is false.
   Thus, Card(roots(f)) == deg(f).
   Similarly, Card(roots(g)) == deg(g).
   QED
* =========================================================
* legendre_sym(a,p)  Also denoted (a|p)
 a is an integer, p is an odd prime. 
 Then legendre_sym(a,p) = 
  0 if p divides a
  1 if p does not divide a and there is integer x with x*x == a (mod p)
 -1 if p does not divide a and there is NO integer x with x*x == a (mod p)
 
 if a == b (mod p), then (a|p) = (b|p) 
 if x != 0 (mod p), then (x*x|p) = 1
 
** (p-1)/2 is a positive integer
 Since p is an odd prime, hence (a) an odd positive number, and (b) != 1.
** If 1 <= x < y <= (p-1)/2, then x^2 != y^2 (mod p)
  Let n = (p-1)/2.
  y^2 - x^2 = (y-x)*(y+x)
  if p divides (y-x)*(y+x), then by Euclid's lemma, p divides (y-x) or
  p divides (y+x)
  1 <= (y-x) < y < p.  Since p is prime, p does not divide y-x
  1 <= (y+x) < (n+n), and n+n = p-1.  So, p does not divide y+x.
  Thus, p does not divide (y^2 - x^2), thus y^2 != x^2 (mod p),
  Thus x^2 != y^2 (mod p).

** (p-1)/2 is the number of quadratic residues
 Let n = (p-1)/2
 Proof: If 1 <= x < y <= n, then x^2 != y^2 (mod p)
 Let R = {x^2 (mod p) (for 1 <= x <= n)}.
 Thus R is a subset of {1,...,p-1} with exactly n elements.
** Euler criterion: legendre_sym(a,p) = a^((p-1)/2) (mod p)
 Assume p is an odd prime number, and a is an integer not divisible by p.
 Let R = {a such that (a|p) = 1 (and 1<=a<=p-1)},
 Let n = (p-1)/2.  Then n = Card(R).
 Consider the polynomial f = X^n - 1 
  with coefficients in the integers mod p.
 Then for 1<=x<=n, f(x^2) = x^(p-1) - 1 (mod p)
 By Fermat Little theorm, x^(p-1) = 1 (mod p) (since p does not divide x).
 Thus, x^2 (mod p) is a root of f.
 Thus, R is a subset of the roots of f.
 But f has at most n roots, by Legendre's theorem in the field of integers
 mod p (since p is prime).
 Thus R = roots(f).
 Thus, {a such that 1<=a<=p-1 and a not in R} =
       {a such that (a|p) = -1 (and 1<=a<=p-1)} = 
       {a such that a is not in roots(f) (and 1<=a<=p-1)}
 So, take such an a not in R.  Then a^n != 1 (mod p)
 But (a^n)^2 = 1 (mod p) (Fermat's little theorem).
 Let g[X] = X^2 - 1  (polynomial with coefficients mod p)
 then a^n is a root of g.   But by Legendre's theorem applied to g,
 There are at most 2 roots for g; in fact the two roots are 1 and -1 (mod p)
 So a^n must be 1 or -1 (mod p). We have already ruled out a^n = 1 (mod p),
 so a^n = -1 (mod p)

** (a*b | p) = (a|p)*(b|p) 
 By Euler's criterion, in Z/Zp, (with n = (p-1)/2)
 (a*b | p) = (a*b)^n = (a^n)*(b^n) = (a|p)*(b|p)
** (-1|p) = 1 IFF p=1(mod 4)
 Let n = (p-1)/2. Then in Z/Zp,
 (-1|p) = (-1)^n. But both sides are either 1 or -1, and p is odd, so
 the two sides are equal in Z. (-1)^n is 1 IFF n is even IFF p == 1 (mod 4).
* =========================================================
* relprimes(n) 
  For 1<=n, 
  Define relprimes(n) = S(x,1<=x<=n and gcd(x,n) == 1)

  Note:
  For the rest of this section, Assume 1<n
  if 1<n, then relprimes(n) = S(x,1<=x<n and gcd(x,n) == 1).
   Thus, relprimes(n) is a subset of 'n' when 1<n
** 0.  relprimes(1) = {1}
** 0a. if 1<=a<n, then a is in relprimes(n) iff  and E[x,E[y, and 1<=x and 1<=y and a*x = n*y + 1]]
   If 1<=a and 1<=n, there are x and y with 0<=x and 1<=y and a*x = n*y + gcd(a,n).
   If a is in relprimes(n), then gcd(a,n) = 1, so a*x = n*y + 1.
   Conversely, Suppose a*x = n*y + 1 
    If  d|a and d|n, then d|1.  Thus gcd(a,n) = 1.
** 0b. if 1<=a<=n, then a is in relprimes(n) iff E[x, 1<=x with a*x = 1 (mod n)]
   Restatement of 0a.
   Note: we may replace x by Rem(x,n), so that x is also in relprimes(n).
   Also x is unique for a, and may be referred to as inverse(x) 
   i.e. the multiplicative inverse of a in Nring(n)
** 0c. If a and b are in relprimes(n), then Rem(a*b,n) is in relprimes(n)
   gcd(a,n) = 1 There is x so that a*x = 1 (mod n)
   gcd(b,n) = 1 There is y so that b*y = 1 (mod n)
   Then (a*b)*(x*y) = 1 (mod n).  Thus, Rem(a*b,n)*Rem(x*y,n) = 1 (mod n)
   And  1<=Rem(a*b,n)<=n  so Rem(a*b,n) in relprimes(n).
** 0d. Nring(n) if 1<n, then the set n (with elements 0,1,...,n-1) is a ring under (mod n) operations.
** 0e. If 1<n, relprimes(n) with (mod n) multiplication is a subgroup with (mod n) multiplication.
** 0f. if 1<=a<=n, then a in relprimes(n) iff comdivs(a,n) = {1}.
       Assume 1<=a<=n.
       gcd(a,n) = max(comdivs(a,n)) (one defintion of gcd)
       relprimes(n) = {b, 1<=b<=n and gcd(b,n) = 1}. 
       Now, 1 is in comdivs(a,n) (since 1<=a and 1<=n).
       So leq({1},comdivs(a,n))
***    if a is in relprimes(n), then comdivs(a,n) = {1}.
        Then gcd(a,n) = 1. Thus max(comdivs(a,n)) = 1.
        Suppose d is in comdivs(a,n). Then 1<=d.
         if d != 1,  then 1 < d <= max(comdivs(a,n)), a contradiciton.
        Thus d = 1. So leq(comdivs(a,n), {1}).
        Since also leq({1},comdivs(a,n)), we conclude comdivs(a,n) = {1}
***    if comdivs(a,n) = {1}, then a is in relprimes(n).
       Then gcd(a,n) = max(comdivs(a,n)) = max({1}) = 1.
       Thus, a is in relprimes(n)
** -------------------------------------------------------------
** 1. if x and y are in relprimes(n), then NProd(n)(x,y) is in relprimes(n)
   Corollary 3 to Euclid's Lemma (see above)

** 2. If 1<=x<=n, then x in relprimes(n) iff E[y,1<=y<=n and x*y = 1 (mod n)]
  a. If 1<=x<=n and 1<=y<=n and x*y = 1 (mod n), then x is in relprimes(n).
   Since 1<=x*y,  n divides x*y-1. So there is q: x*y = n*q + 1.
   If d divides both x and n, then d divides 1, so d = 1.
   Thus, comdivs(x,n) = {1}, so gcd(x,n) = Nmax(comdivs(x,n)) = Nmax({1}) = 1.
   So x is in relprimes(n)
  b. Suppose x is in relprimes(n).
    Define f(k) = Rem(x*k,n), for k in relprimes(n).
    From lemma 0c above, f(k) is also in relprimes(n).
    So, f is a function from relprimes(n) to relprimes(n).
     Now, suppose k<=j and j and k are in relprimes(n), and f(j) == f(k). 
     Thus x*j == x*k (mod n). So there is 1<=c with x*j = x*k + n*c.
     Thus, NdivQ(n,x*(j-k)). By Corollary to Euclid's Lemma, NdivQ(n,j-k), since gcd(x,n)=1.
     But 1 <= j-k < n  (since 1 <= k < j <= n), So NdivQ(n,j-k) is false.
    Conclude, f is injective.
    Since relprimes(n) is finite,  conclude f is bijection.
    Now 1 is in relprimes(n). So, there is y in relprimes n with Rem(x*y,n) ==1.
    Thus, x*y == 1 (mod n) (definition of mod n).
  2. now follows from a. and b.

** 3. If 1<=x<n, then x is in relprimes(n) iff E[y,y in relprimes(n) and x*y = 1 (mod n)]
   Trivial from 2
** 4. If 1<n, then relprimes(n) is the group of multiplicative units in ring Nring(n).
   This is a matter of definitions.
   This is a finite group.  
** 5. if n is prime, then relprimes(n) = {x in N: 1<=x<n}
   Let A = relprimes(n)
   Let B = {x: 1<=x<n}
   if x in A, then 1<x<n, so x in B.
   if x in B, then 1<=x<n.
    if d | x and d | n, then
     d = 1 or d = n, since n is prime.
     Also d<=x, so d<n.  Thus d = 1.
    Thus the set of common divisors of x and n is {1}. Thus gcd(x,n) = 1
    Thus, x in A.
   Thus A = B.
** 6. if 1<=n and 1<=k and 0<=i<=k, then n**i|n**k
      See Corollary 6 of Euclid's Lemma
** 7. if n is prime and 1<=k and q is prime and q | n**k, then q = n.
   See Corollary 7 to Euclid's Lemma
** 8. if n is prime and 1<=k, then divisors(n**k) = {n**i, i<=k}
   See Corollary 9 of Euclid's Lemma
** -------------------------------------------------------------
** 9. if n is prime and 1<=k, then relprimes(n**k) = nonmultiples(n,n**k)
    Let m = n**k
    note 1<=n and 1<=m. In fact 1 < m.
    A = relprimes(m), B = nonmultiples(n,m). We must show A = B.
    Since 1 < m, 
    iff (in(x,A) 1<=x<m && gcd(x,m) = 1)
    iff (in(x,B),  (x < m && (not n|x)))
      Since 1<=n, n | 0.  Thus,
    iff (in(x,B), (1<=x<m && (not n|x))
*** Now suppose 1<=x<m. to show:  iff(gcd(x,m) = 1, (not n|x)).
     
     equivalently to show: iff(gcd(x,m) != 1, n|x).
      First, suppose gcd(x,m) != 1, and show n | x.
       Now gcd(x,m)|x and gcd(x,m)|m.
       Since n is prime, statement 8 above implies there is i (0<=i<=k) such that gcd(x,m) = n**i.
       Since gcd(x,m) != 1, in fact 0 < i, so 1<=i.
       Thus, n | n**i.  thus n | gcd(x,m). 
       Since gcd(x,m) | x, we conclude n | x
      Next, suppose n|x and show gcd(x,m) != 1.
       Since 1<=k, we also have n|m.
       Thus, n is in comdivs(x,m). 
       Since n is prime, 1 < n.
       Since gcd(x,m) = max(comdivs(x,m), n <= gcd(x,m).
       Thus 1 < gcd(x,m). So gcd(x,m) != 1
     Thus, iff(gcd(x,m) != 1, n|x).
     Thus, iff(gcd(x,m) = 1, (not n|x))
     QED
*** Thus Iff( in(x,A), in(x,B). So A = B
** 10. If n is prime and 1<=k, then NCard(relprimes(n**k)) = (n**(k-1))*(n-1)
   By 9, relprimes(n**k) = nonmultiples(n,n**k). Thus
   NCard(relprimes(n**k)) = NCard(nonmultiples(n,n**k))
   Since n is prime, 1<=n.
   Since 1<=n and 1<=k, we may have the general fact about nonmultiples that
   NCard(nonmultiples(n,n**k)) =  (n**(k-1))*(n-1) 
   Thus, NCard(relprimes(n**k)) = (n**(k-1))*(n-1)
   QED.
* divisorsum(f,n), number-theoretic function, multiplicative function
 These are functions defined on N*. See numtheory1.py
 The function values could be in  Z, Q, R, or C. But usually are in N.
** number-theoretic function
 Ref: https://en.wikipedia.org/wiki/Arithmetic_function
  A number-theoretic function or number-theoretic function 
  is for most authors any function f whose domain is the positive integers 
  and whose range is a subset of the complex numbers. 
** divisorsum(f,n), divsorsumF(f)
  This is also represented in numtheory1.py.
  Let f be a number-theoretic function.
  divisorsum(f,n) is sum of f(d) over all divisors d of n.
   = f(d1) + f(d2) + ... + f(dk) where {d1,...,dk} 
     is an enumeration of the divisors of n.
  Let divisorsumF(f) be the function with domain N* with 
   val(divisorsumF(f),n) = divisorsum(f,n)
  Then divisorsumF(f) is also a number-theoretic function.

  In one sense this is a simple notion.
  A more exact definition requires some background, which is rarely discussed.
  For n in N*,  Card(divisors(n)) in N be the number of divisors of n;
  Assume f(d) is in N, for each divisor d of n.
  Let D(n): Card(divisors(n)) -> divisors(n) be any bijection;
    there are such bijections since divisors(n) is a finite set.

  Let f#D(n) denote the composition function from Card(divisors(n)) to N.
  Then divisorsum(f#D(n)) is f(D(n)(0)) + ... + f(D(n)(n-1)).
  Since addition in N is commutative and associative, if  
  D1(n):  Card(divisors(n)) -> divisors(n)
  is any other bijection, then divisorsum(f#D1(n)) == divisorsum(f#D(n)).
** multiplicative number-theoretic function
 f: N* -> C is multiplicative if gcd(m,n) = 1 implies f(m*n) == f(m)*f(n).
 (for 1<=m, 1<=n)

* relprimeSeqQ(s) and multiplicative function
  s is a relatively prime sequence 
   iff s is a finite sequence in N*  (s a function k->N*)
       and gcd(s(i),s(j)) = 1 for all i,j in k with i!=j.
    We probably assume 1<=k (i.e., exclude the empty sequence)
  S is a relatively prime set 
   iff S is a finite subset of N* 
       and gcd(a,b) = 1 for a,b in S with a!=b.
   NOTE: relprimeSetQ(S) does not seem useful.
  If relprimeSetQ(S) and s:NCard(S)->S is a bijection, then
   relprimeSeqQ(s)
  Assume f: N* -> C is multiplicative
** 1. if relprimeSeqQ(s), then f(NprodSeq(s)) = NprodSeq(f#s)
   (# is composition of functions)
   s: k->N*. Also f#s:k->C
   When k=1, this is trivial as NprodSeq(s) = s(0) and NprodSeq(f#s) = f(s(0)).
   When k=2, this is a restatement of the definition of multiplicativity of f:
    gcd(s(0),s(1)) = 1
    NprodSeq(s) = s(0)*s(1). 
    NprodSeq(f#s) = f(s(0))*f(s(1))
   Suppose k = 3.
    NprodSeq(s) = s(0)*s(1)*s(2) = (s(0)*s(1))*s(2)
    Since gcd(s0,s2)=1 and gcd(s1,s2)=1, then gcd(s0*s1,s2) = 1,
       by Corollary 3 to Euclid's Lemma.
    Thus, f((s0*s1)*s2) = f(s0*s1)*f(s2) since f is multiplicative.
    But then also f(s0*s1) = f(s0)*f(s1) since f is multiplicative.
    Thus f(NprodSeq(s)) = f(s0*s1*s2) 
      = f((s0*s1)*s2) = f(s0*s1)*f(s2) = 
      (f(s0)*f(s1))*f(s2) = f(s0)*f(s1)*f(s2) = NProdSeq(f#s)
    An inductive argument *could* generalize this to any 'k'.
** 2. if relprimeSeqQ(s), then f(s(0)) | f(NprodSeq(s))
   Suppose domain(s) = m+1, 0<=m.
   Then f(NprodSeq(s)) = f(s(0))*f(s(1))*...*f(s(m)).
** 3. NO if s is an injective finite sequence in NprimePowers, then relprimeSeqQ(s)
   Take two indices i != j in domain(s).
     s(i) = p^k, s(j) = q^l  (p,q prime, 1<=k, 1<=l)
   Since i != j and s 1-1, then p!=q
** 4. Let 1<n and S = PrimePowerRep(n). Then relPrimeSetQ(S).
    So leq(S,NprimePowers), S is finite, S is not empty, and
       n = NprodSet(S).
    Let s be an enumeration of S.
    Then NprodSeq(s) = NprodSet(S) 
    If f is multiplicative, then  f(NprodSeq(s)) = NprodSeq(f#s).
     Thus f(n) = NprodSeq(f#s)
** 5. if 1<n, then there is s such that relprimeSeqQ(s) and n = NprodSeq(s).
   This is one aspect of the Fundamental theorem of arithmetic.
   We have the finite non-empty subset PrimePowerRep(n) of NprimePowers,
     so that NprodSet(PrimePowerRep(n)) = n.
     Let s: NCard(PrimePowerRep(n)) -> PrimePowerRep(n) be any bijection.
     Then relPrimeSeqQ(s) and NprodSeq(s) = NprodSet(PrimePowerRep(n)) = n.
     PrimePowerRep(n) = {p1^k1, ..., pm^km} where m = NCard(PrimePowerRep(n)).
     p1,...,pm are distinct prime numbers, and 1<=ki.
     Then n = p1^k1 * ... * pm^km
* ephi(n) definition and first properties
  When 1<=n, define ephi(n) = NCard(relprimes(n))  (Euler totient function)
** 1. if 1<=n, 1<=ephi(n)<=n.
   relprimes(n) is subset of (n+1), hence finite.
   Also 0 is not in relprimes(n). Thus leq(relprimes(n), diff(n+1,{0}))
   Thus ephi(n) <= n.
   Since in(1,relprimes(n), Ncard({1}) <= NCard(relprimes(n)).
   And NCard({1}) = 1.
   Thus, 1 <= ephi(n)
** 2. if 1 < n, then ephi(n) < n.
   Since n | n and 1 <= n, gcd(n,n) = n.
   Since 1 < n, gcd(n,n) != 1.
   Thus n is not in relprimes(n). Thus,
    leq(relprimes(n), diff(n+1,{0,n})).
    Thus NCard(relprimes(n)) <= NCard(diff(n+1,{0,n})) = (n+1) - 2 = n-1.
    Thus ephi(n) < n.
** 3. ephi(1) = 1, since relprimes(1) = {1}
** 4. ephi(2) = 1, since relprimes(2) = {1}
** 5. ephi(3) = 2, since relprimes(3) = {1,2}
** 6. ephi(4) = 2, since relprimes(4) = {1,3}
** 7. ephi(5) = 4, since  relprimes(5) = {1,2,3,4}
** 8. if n is prime and 1<=k, then ephi(n**k) = (n**(k-1))*(n-1)
   Statement 10 under relprimes is
     NCard(relprimes(n**k)) = (n**(k-1))*(n-1); Apply definition of ephi.
** 9. if n is prime, then ephi(n) = (n-1).
   Assume n is prime.
*** Proof 1:
    Apply 8 with k = 1.  ephi(n**1)  = (n**0)*(n-1)
    n**1 = n and n**0 = 1.
    Thus ephi(n) = n-1
*** Proof 2
   From statement 5 of relprimes above,
    relprimes(n) = {x in N: 1<=x<n}
    Thus, NCard(relprimes(n)) = NCard({x in N: 1<=x<n}) = n-1
    Thus ephi(n) = n-1
** 10. if n is prime and n != 2 and 1<=k, then ephi(n**k) is even.
   Since n is prime, 2<=n.  Thus 2<n by assumption.
   since n is prime, 2 does not divide n.
   Thus NoddQ(n).  Thus NevenQ(n-1).
   By 8, ephi(n) = (n**(k-1))*(n-1). Thus NevenQ(ephi(n)).
** 11. ephi(2**k) = 2**(k-1), so is even if 2<=k.
    ephi(2**k) = 2**(k-1)*(2-1)  by 8
       1<=k-1, so 2|2**(k-1),  this ephi(2**k) is even
** Two important theorems (to be proved later)
***   - divisorsum(ephi,n) = n
     Example: n = 15. divisors(15) = {1,3,5,15}
      divisorsum(ephi,15) = 
       ephi(1) + ephi(3) + ephi(5) + ephi(15) = 
       1 + 2 + 4 + 8 = 15
***   - gcd(m,n) = 1 implies ephi(m*n) = ephi(m)*ephi(n)
     Example: gcd(3,5) = 1
     relprimes(15) = {1,2,4,7,8,11,13,14}. ephi(15) = 8
     ephi(3)*ephi(5) = 2*4 = 8.
* gcdpartitionF(n), gcdpartition(n)
 These are introduced to prove that divisorsum(ephi,n) = n 
 This partition of [1..n] is usually un-named. 
 Its properties are used in proving that ephi is a multiplicative function.
 Fix 1<=n. Let X(n) = S(m, 1 <= m <= n). 

 Define a function gcdpartitionF(n) from divisors(n) to subsets of X(n) by
  gcdpartitionF(n)(d) = S(m, m in X(n) and gcd(m,n) == d) 
 Let f = gcdpartitionF(n). So
 Define function F: divisors(n) -> N* by F(d) = NCard(f(d))

 Note that f(1) = relprimes(n) and f(n) = {n} .
 Define gcdpartition(n) = range(f). 
 Let P = gcdpartition(n).
 Let s = X(n). Note NCard(s) = n

** P is a partition of s
  f is a function from divisors(n) to subsets(s).
  Thus, P is a collection of subsets of s.
  if d is in divisors(n), then 1<=d<=n, and gcd(d,n) == d;
    So d is in f(d), so f(d) is not empty.
  Suppose both d and e are in divisors(n). 
   We show intersection(f(d),f(e)) is empty set unless d = e.
   Suppose this intersection is not empty; 
   Choose m in both f(d) and f(e).
   Then 1<=m<=n, and gcd(m,n) = d and gcd(m,n) = e; so d = e.
  Also 1 is in divisors(n), so f(1) is in P, so P is not empty.
  Now take m with 1<=m<=n.  Then gcd(m,n) is in divisors(n) and
   so m is in f(gcd(m,n)). 
   Thus, union(P) = s.
  Thus, P is a partition of S.
** sum(NCard(e), e in P) = n
   Since P is a partition of the finite set s,
  sum(NCard(e), e in P) = NCard(s),
  and NCard(s) = n  
  Proof: 
  For any k in N, k = {j: j in N and j < k}.
  So n+1 = {j: j in N and j < n+1} = {0,...,n}.
  So s = diff(n+1,{0}) 
  NCard(s) = NCard(n+1) - NCard({0}) = (n+1) - 1 = n.
 So, sum(NCard(e), e in P) = n.
** f is an injection from divisors(n) to Subsets of N
   Take divisors d, d1 of n such that f(d) = f(d1). To show d = d1
   f(d) = S(m, 1 <= m <= n and gcd(m,n) == d)
   f(d1) = S(m, 1 <= m <= n and gcd(m,n) == d1)
   Now since 1<=d<=n and gcd(d,n) = n (since d divides n), we conclude d is in f(d)
   Similarly, d1 is in f(d1).
   so d = gcd(m,n) = d1.
** Thus, f is a bijection from divisors(n) onto range(f) == P
** divisorsum(F,n) = n
   Suppose k = Card(divisors(n)) and d1,...,dk is an enumeration of divisors(n)
   Then f(d1), ..., f(dk) is an enumeration of P
   Thus sum(NCard(e), e in P) = divisorsum(F,n) = F(d1) + F(d2) + ... + F(dk)
   So, Since n = sum(NCard(e), e in P), we get divisorSum(F,n) = n.

* Python code illustrating divisorsum(ephi,n) = n.
** code example  n = 15
  Recall notation: gcdpartitionF(n)(d) = S(m, 1 <= m <= n and gcd(m,n) == d) 
  numtheory1.gcdpartition(15)
  {1: [1, 2, 4, 7, 8, 11, 13, 14], 3: [3, 6, 9, 12], 5: [5, 10], 15: [15]}
  divisors(15) = {1,3,5,15}
  f(1) = S(m, 1<=m<=15 and gcd(m,15) = 1) = [1, 2, 4, 7, 8, 11, 13, 14] = relprimes(Quo(15,1))
  f(3) = S(m, 1<=m<=15 and gcd(m,15) = 3) = [3, 6, 9, 12] ~ relprimes(Quo(15,3))
  f(5) = S(m, 1<=m<=15 and gcd(m,15) = 5) = [5, 10] ~ relprimes(Quo(15,5))
  f(15) = S(m, 1<=m<=15 and gcd(m,15) = 15) = [15]  ~ relprimes(Quo(15,15))
  The '~' symbol means 'has same cardinality as'.
* Theorem: If 1<=n, then divisorsum(ephi,n) == n.
  This theorem is attributed to Gauss.
  In this section, 
  1 <= n. 
  set f = gcdpartitionF(n).
  When d is in divisors(n), 
    f(d) = S(m, 1 <= m <= n and gcd(m,n) == d)
  Let Quo(x,y) be the quotient of x divided by y (for 1<=x, 1<=y).
    x = Quo(x,y)*y + Rem(x,y)  and Rem(x,y) < y.
  So if y divides x, then 1<=Quo(x,y) and x = y*Quo(x,y)
 for d in divisors(n), define 
 function G: f(d) -> N* by G(m) = Quo(m,d) (where gcd(m,n) = d)
 function h: divisors(n) -> N* by h(d) = Quo(n,d)
 function F: divisors(n) -> N* by F(d) = NCard(f(d))
** a) If 1<=m<=n and d divides both m and n, then Quo(m,d)<=Quo(n,d)
   m = d*Quo(m,d) since d | m
   n = d*Quo(n,d) since d | n.
   d*Quo(m,d) <= d*Quo(n,d)  since m <= n.
   0<d since d | m.
   Thus, Quo(m,d) <= Quo(n,d)
** b) If 1<=m and 1<=n, then gcd(Quo(m,gcd(m,n)),Quo(n,gcd(m,n))) = 1
   Let g = gcd(m,n). 
   Let a = Quo(m,g), b = Quo(n,g)
   To show: gcd(a,b) = 1.

   Since g | m, then 1<=a and m = g*a.
   Since g | n, then 1<=b and n = g*b.
   
   Suppose e divides both a and b. So 1<=e. We show e == 1
    Set u = Quo(a,e), v = Quo(b,e). Then 
    a = e*u and b = e*v.
    So, m = g*(e*u) and n = g*(e*v).
    Thus g*e divides both m and n.  Thus g*e <= gcd(m,n).
    i.e,  g*e <= g.  Thus, e <= 1.  Thus, e == 1
   Thus, divisors(a,b) = {1}.
   Thus gcd(a,b) = Max(divisors(a,b)) = Max({1}) = 1.
** c) If 1<=k, 1<=q, and 1<=d, then gcd(d*k,d*q) = d*gcd(k,q)
  See above (Bezout Theorem corrolaries, BC 5) .
** d) If 1<=k and 1<=d, then Quo(k*d,d) = k
   k*d = d*Quo(k*d,d) since d | k*d
   Since 0 < d, k = Quo(k*d,d).
** e) If d | n, then G is a bijection from f(d) onto relprimes(Quo(n,d))
 Note 1<=d.
*** if m is in f(d), then Quo(m,d) is in relprimes(Quo(n,d))
 Assume m is in f(d)
 Let g = gcd(m,n). 
 1<=m<=n and g = d, Since m is in f(d).
 Let a = Quo(m,g), b = Quo(n,g)
 Note Quo(m,d) = a  and Quo(n,d) = b, since g = d.
 
 Since g divides m, 1<=a.
 By (a), a <= b.
 From (b), gcd(a,b) = 1.
 Thus, a is in relprimes(b).
 Thus, Quo(m,d) is in relprimes(Quo(n,d))
*** Thus, G is a function from f(d) to relprimes(Quo(n,d))
*** If k is in relprimes(Quo(n,d)), then k*d is in f(d) and Quo(k*d,d) = k
 We must show 1 <= k*d <= n and gcd(k*d,n) = d.
 Let b = Quo(n,d). 
 1 <= d and n = b*d, since d | n.
 1 <= k <= b and gcd(k,b) = 1, since k is in relprimes(b).
 1 <= k*d since 0<k and 0<d.
 k*d <= b*d since k <= b and 0 <= d,
 so k*d <= n.
 By (c), gcd(k*d,b*d) = d*gcd(k,b) = d*1 = d.
 Thus, gcd(k*d,n) = d.
 By (d), Quo(k*d,d) = k.
*** if k is in relprimes(Quo(n,d)), then G(k*d) = k.
    By previous, k*d is in f(d).  
    Thus, G(k*d) = Quo(k*d,d) = k.
*** Thus, G is a surjection from f(d) onto relprimes(Quo(n,d))
*** G is an injection from f(d) to relprimes(Quo(n,d)).
    Suppose m and j are in f(d) and G(m) = G(j).
    1 <= m <= n and gcd(m,n) = d, since m is in f(d).
    1 <= j <= n and gcd(j,n) = d, since j is in f(d).
    Quo(m,d) = Quo(j,d), since G(m) = G(j).
    d | m, since gcd(m,n) = d
    d | j, since gcd(j,n) = d
    m = d*Quo(m,d) since d | m.
    j = d*Quo(m,j) since j | m.
    d*Quo(m,d) = d*Quo(j,d), since Quo(m,d) = Quo(j,d).
    Thus m = j.
  Thus, G is an injection.
*** Thus, g is a bijection f(d) -> relprimes(Quo(n,d))
** f) If d in divisors(n), then NCard(f(d)) = ephi(Quo(n,d)) 
 From (e), G is a bijection between the sets f(d) and relprimes(Quo(n,d)).
 And these are finite sets.
 Thus, NCard(f(d)) = NCard(relprimes(Quo(n,d))) 
 Thus, NCard(f(d)) = ephi(Quo(n,d)), by definition of ephi (Euler phi function)
** g) h is a permutation of divisors(n)
 if NdivQ(d,n), then n = d*Quo(n,d) = d*h(d),  so NdivQ(h(d),n).
 Thus h(d) is in divisors(n).
 Suppose e is in divisors(n).  Then there is d with n = e*d.
 And d is in divisors(n) and e = Quo(n,d) = h(d). 
 So, h is a surjection from divisors(n) onto divisors(n). 
 Since divisors(n) is finite, h is a bijection. 
   (alternately, h(d) = h(e) => Quo(n,d) = Quo(n,e),
    n = d*Quo(n,d), and n = e*Quo(n,e).
    and d*Quo(n,d) = d*Quo(n,e), so
    and d*Quo(n,e) = e*Quo(n,e) ,so d = e. So h is injection.)
** h) divisorsum(ephi,n) = n  
 For d in divisors(n),
  NCard(f(d)) = ephi(Quo(n,d)) (by (e))
  i.e., F(d) = val(ephi#h)(d)
 So F = ephi#h  as functions from divisors(n) into N*.
 divisorsum(F,n) = divisorsum(ephi#h,n)
                 = divisorsum(ephi,n) (by (g))
 divisorsum(F,n) = n by the 'sum(NCard(e), e in P) = n' theorem under
          gcdpartitionF(n) section above.
 So divisorsum(ephi,n) = n.
 QED.
** Two additional statments:
*** i) If 1<=k, 1<=q, gcd(k,q) = 1, and 1<=d, then gcd(d*k,d*q) = d.
  From c), gcd(d*k,d*q) = d*gcd(k,q)
  = d*1  (by assumption gcd(k,q)=1)
  = d.

*** l) divisorsum(ephi,n) = divisorsum(ephi#h,n).
    Let D be an enumeration of divisors(n). Let k = Card(divisors(n)).
    Let D1 = h#D.
    Then also D1 is an enumeration of divisors(n), since h permutes divisors(n).
    lhs = ephi(D(1)) + ephi(D(2)) + ... + ephi(D(k))
    rhs = ephi(h(D(1)) + ... + ephi(h(D(k)) =
        = ephi(D1(1)) + ... + ephi(D1(k))
        = lhs.

* TODO Python code to illustrate divisorsum(ephi,n) == n 
** Test gcd(a*n,b*n) == gcd(a,b)*n
 for positive integers a,b,n
*** code
def test0(m):
 # Test gcd(a*n,b*n) == gcd(a,b)*n
 from numtheory1 import gcd
 nfound = 0 # number of counterexamples
 ncase = 0 # total number of cases
 for a in range(1,m+1):
  for b in range(1,m+1):
   for n in range(1,m+1):
    ncase = ncase + 1
    x = gcd(a*n,b*n)
    y = gcd(a,b)*n
    if x != y:
     print('counterexample: a=%s, b=%s, n=%s' %(a,b,n))
     nfound = nfound + 1
 print(nfound,"counterexamples found with m=",m)
 print(ncase,"cases examined")
*** results
test0(10)
0 counterexamples found with m= 10
1000 cases examined
>>> test0(20)
0 counterexamples found with m= 20
8000 cases examined
>>> test0(100)
0 counterexamples found with m= 100
1000000 cases examined
** Local notation S(c,b) = S(m for 1<=m<=c and gcd(m,b) = b)
** Test a -> a*b is isorphism from relprimes(a) to S(a*b,b) 
*** code
def test1(a,b):
 from numtheory1 import relprimes,gcd
 def S(c,b):
  return [m for m in range(1,c+1) if gcd(m,c) == b]
 rp = relprimes(a)
 v1 = [x*b for x in rp]
 v2 = S(a*b,b)
 print('relprimes(%s) = %s' %(a,rp))
 print('v1 = relprimes(%s)*%s = \n  %s' %(a,b,v1))
 print()
 print('v2 = S(x, 1<=x<=%s and gcd(x,%s) == %s) = \n  %s' %(a*b,a*b,b,v2))
 print('v1 == v2 is',v1 == v2)
*** results
**** test1(5,6)
relprimes(5) = [1, 2, 3, 4]
v1 = relprimes(5)*6 =
  [6, 12, 18, 24]

v2 = S(x, 1<=x<=30 and gcd(x,30) == 6) =
  [6, 12, 18, 24]
v1 == v2 is True
**** test1(15,20)
relprimes(15) = [1, 2, 4, 7, 8, 11, 13, 14]
v1 = relprimes(15)*20 =
  [20, 40, 80, 140, 160, 220, 260, 280]

v2 = S(x, 1<=x<=300 and gcd(x,300) == 20) =
  [20, 40, 80, 140, 160, 220, 260, 280]
v1 == v2 is True

** gcdpartition(n) is a partition of [1,...,n] (1<=n)
f(d) is non-empty iff NdivQ(d,n) iff d is in divisors(n)
d1 and d2 are divisors of n, and m is in in S(n,d1) and S(n,d2), then d1 == d2.
And if 1<=m<=n, then m is in S(n,gcd(m,n)).
Thus {S(n,d) for d in divisors(n)} is a partition of n.
In particular, let f(d) = len(S(n,d)). Then divisorsum(f,n) == n.

Example: [S(6,d) for d in divisors(6)]
 [ [1,5], [2,4], [3], [6] ]   a partition of [1,2,3,4,5,6]
** if NdivQ(d,n), then ephi(d) = len(S(n,n//d))
[len(S(6,d)) for d in divisors(6)]
 [2, 2, 1, 1]  Sum is 6.
In general:
 sum(len(S(n,d)) for d in divisors(n)) == n

def test2(n):
 divs = divisors(n)
 print('divisors(%s) = %s' %(n,divs))
 
 for d in divs:
  k = n // d
  print('divisor %s of %s, Quotient = %s' %(d,n,k))
  gcdk = S(n,k) 
  rpd = relprimes(d)
  print(' (%s) %s = relprimes(%s)' %(len(rpd),rpd,d))
  print(' (%s) %s = S(%s,%s)' %(len(gcdk),gcdk,n,k))
  print()

* Chinese remainder theorem  CRF(m,n)
  This discusses chinese remainder theorem for 2 moduli.
  Let carprod(a,b) = cartesian product of a and b.
  Statement: Take 1<=m, 1<=n
   Define CRF(m,n): m*n to carprod(m,n) by h(x) = (Rem(x,m),Rem(x,n)) for x in m*n.
  i.e.,
   h(x) = (Res(RemF(m),m*n)(x),Res(RemF(n),m*n)(x))
  Since m divides m*n, Res(RemF(m),m*n) is a ring homomorphism.
  Since n divides m*n, Res(RemF(n),m*n) is a ring homomorphism.
  By definition of direct product of rings, conclude h is a ring homomorphism..
  
  if gcd(m,n) = 1, then h is a bijection.

** (1) ring structure on carprod(m,n).
   Sumc((x,y),(z,w)) 
   = (NSum(m)(x,z), NSum(n)(y,w))
   = (Rem(x+z,m),Rem(y+w,n))
   Prodc((x,y),(z,w)) = (NProd(m)(x,z), NProd(n)(y,w))
   c1 = (1,1) is multiplicative identity in carprod(m,n).
   c0 = (0,0) is additive identity in carprod(m,n).
** (2) h preserves multiplication and addition
  Straightforward, but details are omitted.
** (3) h preserves multiplicative identity (provided 1<m and 1<n)
   1 in m*n is multiplicative identity (relative to NProd(m*n)).
   h(1) = (Rem(1,m),Rem(1,n)) = (1,1)  since 1<m and 1<n
** (4) h preserves additive identity
   0 in m*n (since 1<=m*n). 0 in m since 1<=m, and 0 in n since 1<=n
   h(0) = (Rem(0,m),Rem(0,n)) = (0,0)
** (5) If gcd(m,n) = 1 and x is in m*n and h(x) = (0,0), then x = 0.
   Since h(x) = (Rem(x,m),Rem(x,n)), then Rem(x,m) = 0 and Rem(x,n) = 0.
   Thus m divides x, and n divides x.
   By corollary 1 to Euclid's Lemma, we conclude m*n divides x.
   Thus Rem(x,m*n) = 0.  Since x is in m*n, then x < m*n, so x = 0.
** (6) If gcd(m,n) = 1 then h is an injection.
   A special case of theorem that a ring homomorphism g:R1->R2 is injective
    provided A(z, if z in R1 and g(z)=0 then z=0).
   Suppose x and y are in m*n and h(x) = h(y). We want to show x = y.
   Since x and y are in N, either x<=y or y<=x.
   We show proof assuming x<=y.  The proof for y<=x is analogous.
   There is z in N so that x+z = y. Since x<m*n and y<m*n, then also z<m*n.   
   So z is in m*n.  
   NSum(m*n)(x,z) = Rem(x+z,m*n) = x+z  since x+z < m*n
   h(y) = h(NSum(m*n)(x,z)) = Sumc(h(x),h(z)).
   Since carprod has additive inverses  (carprod is a group under addition),
   and since h(x) = h(y), we may conclude h(z) = zero = (0,0).
   Since gcd(m,n) = 1, prior statement implies z = 0.
   Thus, x = y.
** (7) Card(m*n) = Card(carprod(m,n))
   For k in N, Card(k) = k.  (this is proved elsewhere when Card is introduced)
   So, Card(m*n) = m*n, Card(m) = m, and Card(n) = n.
   Since m and n are finite, Card(carprod(m,n)) = Card(m)*Card(n) = m*n.
** (8) if gcd(m,n) = 1 then h is bijection.
   h is injection from m*n to carprod(m,n), and these two sets are finite
   with the same cardinality.
   We have a theorem such as 'if h is an injection from finite set 'a' into
   finite set 'b', and if Card(a) = Card(b), then h is a surjection'.
   Thus, h is a surjection.
   Thus, h is a bijection.
** (9) if gcd(m,n) = 1 then image(h,relprimes(m*n)) = carprod(relprimes(m),relprimes(n))
  Assume gcd(m,n) = 1  (Do some statements require also 1<m and 1<n?)
  h is function m*n to carprod(m,n) by h(x) = (Rem(x,m),Rem(x,n)) for x in m*n.
  h is m ring homomorphism.
  Since gcd(m,n) = 1 h is m ring isomorphism.
  Let rp(a) = relprimes(a)
  To show:
   image(h,rp(m*n)) = carprod(rp(m),rp(n))
  And from this conclude that 
   Card(rp(m*n)) = Card(rp(m))*Card(rp(n)).
  Thus, ephi(m*n) = ephi(m)*ephi(n).
  Proof:
  Choose x in rp(m*n). Since 1<m and 1<n, then also 1<m*n,
  and x!= m*n, so 1<=x<m*n (so x is 'in' m*n) 
  h(x) = (Rem(x,m),Rem(x,n)).  We will show Rem(x,m) is in rp(m),
   and, similarly, Rem(x,n) is in rp(n).
  Since x is in rp(m*n), we may, by Lemma3 under rp, choose
  y in rp(m*n) so that x*y = 1 mod(m*n).  
  Also, since 1<m*n, then also y < m*n, so y is in m*n.
  
  Now h(x*y) = (Rem(x*y,m),Rem(x*y,n)) and, since h preserves
  multiplication from Zmod(m*n), we have
  h(x*y) = h(1) = (1,1).
  We now show: Rem(x,m) is in rp(m)
   Then h(Rem(x*y,m*n)) = h(1) = (Rem(1,m),Rem(1,n)) = (1,1) and
   h(Rem(x*y,m*n))  = (Rem(x*y,m),Rem(x*y,n)) 
   So Rem(x*y,m) = 1 and Rem(x*y,n) = 1.
   and  Rem(x*y,m) = Rem(Rem(x,m)*Rem(y,m),m) = 1
   and Rem(x,m) is in m and Rem(y,m) is in m. So by Lemma 3 under rp,
   Rem(x,m) is in rp(m).
  Similarly, Rem(x,n) is in rp(n)
 
  So h(x) is in carprod(rp(m),rp(n)).
  Conversely, if (u,v) in carprod(rp(m),rp(n)), then
   (u,v) is in cardprod(m,n), so there is x in m*n with h(x) = (u,v);
   such an x exists since h is m bijection.
   Choose (r,s) in carprod(m,n) so that Rem(u*r,m) = 1 and Rem(v*s,n) = 1.
   And choose y in m*n so that h(y) = (r,s). (since h is known bijective)
   Then h(Rem(x*y,m*n)) = (1,1) and also h(1) = (1,1)
    so Rem(x*y,m*n) = 1.  Thus x has the inverse y in ring m*n, and
    So again, by Lemma 3 of rp, x is in rp(m*n).
* ephi is a multiplicative function
  Assume gcd(m,n) = 1.
  Thus, the restriction of CRF(m,n) to relprimes(m*n) is a bijection between
    relprimes(m*n) and carprod(relprimes(m),relprimes(n)).
   Thus these two sets have the same cardinality.
   i.e. ephi(m*n) = Card(relprimes(m*n)) 
           = Card(carprod(relprimes(m),relprimes(n))
           = Card(relprimes(m))*Card(relprimes(n)) 
           = ephi(a)*ephi(b).
** 1. generalization to multiple factors
   Suppose relprimeSeqQ(f). Then ephi(NProdSeq(f)) = NprodSeq(ephi#f).
   This relation is true for any multiplicative function, such as ephi.
   1<=m, f:m -> N* and 
     A(i,A(j) i,j in m and i!=j  implies gcd(f(i),f(j) = 1.))
   Then 
   i.e.
   ephi(f(0)*f(1)*...*f(m-1)) = ephi(f(0))*ephi(f(1))*...*ephi(f(m-1))
  
** 2. Let 1 < n. Let S = PrimePowerRep(n), Then ...
  Let m = NCard(S), Let f:m->S be a bijection. 
    i.e. n = p1^k1 * ... * pm^km  
  Thus n = f(1)*f(2)*...*f(m) = NprodSeq(f)
  So ephi(n) = ephi(f(1)*f(2)*...*f(m)).
   And this is equal to ephi(f(1))*ephi(f(2))*...*ephi(f(m)) =
** 3. If 2<n and 2 does not divide n, then NevenQ(ephi(n)).
  Let S = PrimePowerRep(n), m = NCard(S), s: m->S a bijection.
  Thus relprimeSeqQ(s). n = s1*...*sm.  and
  ephi(n) = ephi(s1)*...*ephi(sm).
  each factor si = p^k for some prime p and some 1<=k., And p!=2.
  and ephi(p^k) = (p^(k-1)) * (p-1).
  And p is odd and 1<p, so (p-1) is even. Thus ephi(si) is even.
  Thus ephi(n) is a product of even numbers, hence is even.
* Euler's generalization of Fermat's little theorem (Euler totient theorem)
  Note: See proof under Fermat little theorem for finite abelian group.
  For 1 < n, and for x in relprimes(n),  x^ephi(n) = 1 (mod n).
  Note: since ephi(p) = p-1 for p a prime, this generalizes Fermat's little thm.
  The proof is quite similar to that of Fermat's little theorem.
  Let k = ephi(n). 
  Let f(a) = Rem(a*x,n) define a function for a in relprimes(n).
  Then, f is a permultation of relprimes(n). 
  Let a1,...,ak name the elements of relprimes(n)
  Let a = product of all numbers in relprimes(n) = a1*...*ak
  and f(a1),...,f(ak) is a permutation of relprimes(n)
  f(a1)*...*f(ak) = a1*...*ak

  But also f(a1)*...*f(ak) = (a1*x)*...*(ak*x) = (a1*...*ak)*(x^k).
  Now in Nring(n), Nrem(x^k,n) = 1.
  QED
** Question is a1*...*ak = -1 (mod n)?  NO
  We can separate a1,...,ak into 3 parts: 1, -1, and the set of pairs
  {x,y} with x in relprimes(n) and y in relprimes(n) and x*y = 1 (mod n) and
  x != y.
  Conjecture: if x,y in relprimes(n), and x*y = 1 (mod n) and x = y,
  then x is either 1 or (n-1).
  Proof?  x*x == 1 (n) => (x-1)*(x+1) ==  (n)
  Example: n = 8.  relprimes(8) = 1,3,5,7.  3*3 = 9 = 1(mod 8) and
  5*5 = 25 = 1 (mod 8).
  Thus, 1*3*5*7 = 1*-1*-1 = 1 (mod 8). So a1*...*ak = 1(mod 8)
  
* rpprod(n) defined. Gauss-Wilson Theorem. numerical experiments
 Given n (1<n), compute the remainder  of the
  product of the numbers x such that x<=n and gcd(x,n) = 1
  And also show the prime factorization of n.

  1<=n. rpprod(n) = Rem(NprodSet(relprimes(n)),n).
   i.e. multiply the finite set of numbers in relprimes(n), and take remainder
   upon division by n.
   Note: often people do all the arithmetic in Nring(n).
    So we will see statements like rpprod(n) = -1, 
    instead of (by our definitions)
    the more accurate rpprod(n) = n-1.

   e.g.  rpprod(5) = Rem(NprodSet(relprimes(5)),5)
           = Rem(NprodSet({1,2,3,4}),5)
           = Rem(1*2*3*4,5)
           = Rem(24,5)
           = 4.
** code
   def rpprod(n):
 import math
 import numtheory1
 rps = numtheory1.relprimes(n) # list of numbers relatively prime to n
 p = math.prod(rps)  # cumulative product
 q,r = divmod(p,n)
 return r

def rpprod1(n):
 r = rpprod(n)
 # for convenience of perusal, when r = n-1,  replace it with -1
 if r == (n-1):
  r = -1
 import prime
 return (n,r,prime.prime_factors(n))

for i in range(100):
 n = i+2
 n,r,rps = rpprod1(n)
 print(n,r,rps)

** results of first 100
2 -1 {2: 1}
3 -1 {3: 1}
4 -1 {2: 2}
5 -1 {5: 1}
6 -1 {2: 1, 3: 1}
7 -1 {7: 1}
8 1 {2: 3}
9 -1 {3: 2}
10 -1 {2: 1, 5: 1}
11 -1 {11: 1}
12 1 {2: 2, 3: 1}
13 -1 {13: 1}
14 -1 {2: 1, 7: 1}
15 1 {3: 1, 5: 1}
16 1 {2: 4}
17 -1 {17: 1}
18 -1 {2: 1, 3: 2}
19 -1 {19: 1}
20 1 {2: 2, 5: 1}
21 1 {3: 1, 7: 1}
22 -1 {2: 1, 11: 1}
23 -1 {23: 1}
24 1 {2: 3, 3: 1}
25 -1 {5: 2}
26 -1 {2: 1, 13: 1}
27 -1 {3: 3}
28 1 {2: 2, 7: 1}
29 -1 {29: 1}
30 1 {2: 1, 3: 1, 5: 1}
31 -1 {31: 1}
32 1 {2: 5}
33 1 {3: 1, 11: 1}
34 -1 {2: 1, 17: 1}
35 1 {5: 1, 7: 1}
36 1 {2: 2, 3: 2}
37 -1 {37: 1}
38 -1 {2: 1, 19: 1}
39 1 {3: 1, 13: 1}
40 1 {2: 3, 5: 1}
41 -1 {41: 1}
42 1 {2: 1, 3: 1, 7: 1}
43 -1 {43: 1}
44 1 {2: 2, 11: 1}
45 1 {3: 2, 5: 1}
46 -1 {2: 1, 23: 1}
47 -1 {47: 1}
48 1 {2: 4, 3: 1}
49 -1 {7: 2}
50 -1 {2: 1, 5: 2}
51 1 {3: 1, 17: 1}
52 1 {2: 2, 13: 1}
53 -1 {53: 1}
54 -1 {2: 1, 3: 3}
55 1 {5: 1, 11: 1}
56 1 {2: 3, 7: 1}
57 1 {3: 1, 19: 1}
58 -1 {2: 1, 29: 1}
59 -1 {59: 1}
60 1 {2: 2, 3: 1, 5: 1}
61 -1 {61: 1}
62 -1 {2: 1, 31: 1}
63 1 {3: 2, 7: 1}
64 1 {2: 6}
65 1 {5: 1, 13: 1}
66 1 {2: 1, 3: 1, 11: 1}
67 -1 {67: 1}
68 1 {2: 2, 17: 1}
69 1 {3: 1, 23: 1}
70 1 {2: 1, 5: 1, 7: 1}
71 -1 {71: 1}
72 1 {2: 3, 3: 2}
73 -1 {73: 1}
74 -1 {2: 1, 37: 1}
75 1 {3: 1, 5: 2}
76 1 {2: 2, 19: 1}
77 1 {7: 1, 11: 1}
78 1 {2: 1, 3: 1, 13: 1}
79 -1 {79: 1}
80 1 {2: 4, 5: 1}
81 -1 {3: 4}
82 -1 {2: 1, 41: 1}
83 -1 {83: 1}
84 1 {2: 2, 3: 1, 7: 1}
85 1 {5: 1, 17: 1}
86 -1 {2: 1, 43: 1}
87 1 {3: 1, 29: 1}
88 1 {2: 3, 11: 1}
89 -1 {89: 1}
90 1 {2: 1, 3: 2, 5: 1}
91 1 {7: 1, 13: 1}
92 1 {2: 2, 23: 1}
93 1 {3: 1, 31: 1}
94 -1 {2: 1, 47: 1}
95 1 {5: 1, 19: 1}
96 1 {2: 5, 3: 1}
97 -1 {97: 1}
98 -1 {2: 1, 7: 2}
99 1 {3: 2, 11: 1}
100 1 {2: 2, 5: 2}
101 -1 {101: 1}

** product of 2 or 3 odd primes
Experiments suggest that rpprod(n) = 1 when 
a) n = p1*p2  (two distinct primes)
b) n = p1*p2*p3 (three distinct primes)

def rpprod_2_primes(mtrials):
 from primes_lt_1000 import primes_lt_1000 # 168
 primes = [x for x in primes_lt_1000 if 2 < x < 100] # 24
 import random
 nfound = 0
 for _temp in range(mtrials):
  p = random.choice(primes)
  while True:
   q = random.choice(primes)
   if q != p: 
    break
  n = p*q
  n,r,rps = rpprod1(n)
  if r != 1:
   print(n,r,rps)
   nfound = nfound + 1
 print('%s trials' % mtrials)
 print('%s pairs of primes < 100 found with rpprod1(n) != 1' % nfound)

rpprod_2_primes(50)
50 trials
0 pairs of primes < 100 found with rpprod1(n) != 1

def rpprod_3_primes(mtrials):
 from primes_lt_1000 import primes_lt_1000 # 168
 primes = [x for x in primes_lt_1000 if 2 < x < 100] # 24
 import random
 nfound = 0
 for _temp in range(mtrials):
  p1 = random.choice(primes)
  while True:
   p2 = random.choice(primes)
   if p2 != p1: 
    break
  while True:
   p3 = random.choice(primes)
   if p3 not in (p1,p2):
    break
   
  n = p1*p2*p3
  n1,r,rps = rpprod1(n)
  if r != 1:
   print(n,r,rps)
   nfound = nfound + 1
 print('%s trials' % mtrials)
 print('%s triples of primes < 100 found with rpprod1(n) != 1' % nfound)

** observations
  rp(n) = the product of relprimes(n)  is always 1 or -1 (mod n)
  For n a prime, the product is -1 (Wilson's Theorem)
  ('r' = rp(n) (mod n))
  for n = 2**k, r is 
    -1 = 1 for k=1,   (1 = -1 modulo 2)
    -1 for k=2, 1*3 = 3 = -1 (mod 4)
    +1 for k=3..11
  for n = 3**k, r is -1 for k=1..10
  for n = 5**k, r is -1 for k=1..8  (compute time long for 7<=k).
  for n = 7**k, r is -1 for k=1..6  (compute time long for 7<=k).

  Conjecture: If p is a prime, p!=2, and 1<=k, then rpprod1(p**k) = -1 (p**k)

  What conjecture for composites?

** solutions of x**2 = 1 (mod n)
*** non_trivial_squareroots_1 code
def non_trivial_squareroots_1(n):
 import numtheory1
 rps =  numtheory1.relprimes(n)
 ans = []
 for x in rps:
  if x in [1,n-1]: # trivial roots
   continue
  q,r = divmod(x*x,n)
  if r == 1:
   ans.append(x)
 return ans
*** powers of 2
 [(k,non_trivial_squareroots_1(2**k)) for k in range(2,11)]
 [(2, []), (3, [3, 5]), (4, [7, 9]), (5, [15, 17]), (6, [31, 33]), (7, [63, 65]),
 (8, [127, 129]), (9, [255, 257]), (10, [511, 513])]
  n = 2**k
  m = 2**(k-1)
  m+1, m-1 are the non-trivial roots of x**2 = 1 (n)

  x = m-1;  n - x = 2*m - (m-1) = m+1
  x = m+1; n - x = 2*m - (m+1) =  m-1.

  x*(n-x) = -(x**2) (mod n).
  If x**2 = 1 (mod n), then x*(n-x) = -1 (mod n).
  if 2 < k, and x**2 = 1 (n), then n-x != x (mod n)
  
*** powers of prime != 2
 [(k,non_trivial_squareroots_1(3**k)) for k in range(2,11)]
  no non-trivial square roots of 1 mod 3**k
 [(k,non_trivial_squareroots_1(5**k)) for k in range(2,11)]
 [(k,non_trivial_squareroots_1(7**k)) for k in range(2,7)]
 [(k,non_trivial_squareroots_1(11**k)) for k in range(2,7)]

** conjecture: 2 | (p**k), 1<=k, p an odd prime
 conjecture: x != inverse(x) unless x is 1 or n-1
*** test_autoinverses_2_pk(10,[1,2,3]) confirms conjecture
[] {2: 1, 11: 3}
[] {2: 1, 79: 1}
[] {2: 1, 73: 3}
[] {2: 1, 97: 2}
[] {2: 1, 31: 3}
[] {2: 1, 7: 2}
[] {2: 1, 89: 1}
[] {2: 1, 59: 2}
[] {2: 1, 89: 2}
[] {2: 1, 19: 1}
[] {2: 1, 73: 2}
*** code
def autoinverses(n):
 import numtheory1
 rps = numtheory1.relprimes(n)
 ans = []
 for x in rps:
  if x in [1,n-1]:
   continue
  y = numtheory1.a_inverse(x,n)
  if y == x:
   ans.append(x)
 return ans

def test_autoinverses_2_pk(mtrial,ks):
 from primes_lt_1000 import primes_lt_1000 # 168
 primes = [x for x in primes_lt_1000 if 2 < x < 100] # 24
 import random
 ntrial = 0
 while True:
  if ntrial > mtrial:
   break
  ntrial = ntrial + 1
  k = random.choice(ks)
  p = random.choice(primes)
  n = 2*(p**k)
  autos = autoinverses(n)
  pfacts = prime.prime_factors(n)
  if pfacts == None:
   pfacts = (None,p,k)
  print(autos,pfacts)

** conjecture: 4*(p**k), 1<=k, p an odd prime
 n = 4*(p**k)
 conjecture: 
 a) there are two (non-trivial) solutions to x**2 = 1 (mod n).
 b) The product of these two = -1 (mod n)
 In fact these two are 2*(p**k) + 1 and 2*(p**k) - 1
*** test result
test_autoinverses_4_pk(10,[1,3])
[121, 123] {2: 2, 61: 1} -1
[24333, 24335] {2: 2, 23: 3} -1
[45, 47] {2: 2, 23: 1} -1
[453961, 453963] {2: 2, 61: 3} -1
[59581, 59583] {2: 2, 31: 3} -1
[145, 147] {2: 2, 73: 1} -1
[4393, 4395] {2: 2, 13: 3} -1
[453961, 453963] {2: 2, 61: 3} -1
[9825, 9827] {2: 2, 17: 3} -1
[410757, 410759] {2: 2, 59: 3} -1
[2661, 2663] {2: 2, 11: 3} -1
*** code
def test_autoinverses_4_pk(mtrial,ks):
 # n = 4*(p**k). Expect there to be 2 non-trivial x with x**2 = 1 (mod n)
 # also, the product of these 2 is -1 (mod n)
 from primes_lt_1000 import primes_lt_1000 # 168
 primes = [x for x in primes_lt_1000 if 2 < x < 100] # 24
 import random, math
 ntrial = 0
 while True:
  if ntrial > mtrial:
   break
  ntrial = ntrial + 1
  k = random.choice(ks)
  p = random.choice(primes)
  n = 4*(p**k)
  autos = autoinverses(n)
  pfacts = prime.prime_factors(n)
  if pfacts == None:
   print(autos,(None,p,k))
  else:
   prodautos = math.prod(autos) % n
   if prodautos == (n-1):
    prodautos = -1
   print(autos,pfacts,prodautos)

** rpprod(n) for some composite numbers
For p a prime,  the product of relprimes(p) = p-1 mod (p).
But this does not hold for the general non-prime n.
e.g. relprimes(8) = {1,3,5,7}, product = 1 != -1 (mod 8). (wilson theorem false)
and  relprimes(9) = {1,2,4,5,7,8}, product = 8 = -1(mod 9). (wilson true)

from numtheory1 import relprimes
import functools,operatory
def g(n):
 x = functools.reduce(operator.mul,relprimes(n)) % n
 return(n,x == n-1)

So g(8) = (8,False),  g(9) = (9,True)
Here are the numbers less than 100 for which Wilson's conclusion fails
[n for n in range(3,100) if g(n)[1] == False]
[8, 12, 15, 16, 20, 21, 24, 28, 30, 32, 33, 35, 36, 39, 40, 42, 44, 45, 48, 51,
52, 55, 56, 57, 60, 63, 64, 65, 66, 68, 69, 70, 72, 75, 76, 77, 78, 80, 84, 85,
87, 88, 90, 91, 92, 93, 95, 96, 99]

Nonprimes < 100 for which Wilson theorem conclusion holds:
[n for n in range(3,100) if (not isPrime(n)) and g(n)[1] == True]
[4, 6, 9, 10, 14, 18, 22, 25, 26, 27, 34, 38, 46, 49, 50, 54, 58, 62, 74, 81, 82
, 86, 94, 98]

We also conjecture that product(relprimes(n)) mod n is either 1 or n-1.
This is verified for 3<=n<1000: 
f = lambda n: functools.reduce(operator.mul,relprimes(n)) % n
[n for n in range(3,1000) if f(n) not in [1,n-1]]
>>> []   

* Canonical enumeration of carprod(m,n)
  Assume 0<m, 0<n.
  Let p = carprod(m,n) 
  We know Ncard(m) = m, Ncard(n) = n
  Define g: p -> N by g(i,j) = i + m*j, for (i,j) in p.
   Note: g(i,j) = divalgF(m)(j,i) for (i,j) in p.
  
  Define function h0 on N by h(k) = (Rem(k,m),Quo(k,m)).
  Define h = restriction(h0,m*n)
  To show: h is bijection from m*n to p.
  h is 'the canonical enumeration' from NCard(carprod(m,n)) to carprod(m,n)
  h could be called a 'lexicographical' ordering of carprod(m,n)
** Example h: 6 -> carprod(2,3)
   (0,0), (1,0), (0,1), (1,1), (0,2), (1,2)
** Example h: 6 -> carprod(3,2)
   (0,0), (1,0), (2,0), (0,1), (1,1), (2,1)
** The proof follows.
** g : p -> m*n is a bijection and h = inverse(g)
   Suppose i < m, j < n and k = g(i,j) = i + m*j.
   By division algorithm,
    i = Rem(k,m) and j = Quo(k,m).
   Thus, g is a 1-1 function from p to N.
   Next, show range(g) is a subset of m*n.
    i + m*j < m + m*j = m*(1+j) <= m*n
    Thus g(i,j) < m*n, so g(i,j) is an element of m*n.
   Finally, we know NCard(p) = m*n -
    Assumed general fact about cardinality of cartesian product of finite sets.
   Thus, g must also be surjective (since it is injection from one finite set
    to another finite set of the same cardinality -- Another fact about finite sets.)
   i.e., g is a bijection.
   If (i,j) in p, then h(g(i,j)) = h(i + m*j) = (i,j).  
** TODO ---- the following steps are probably redundant.  Better to clean this up and
   make it shorter
** if k is in N, Rem(k,m) < m, and Quo(k,m) is in N.
   Basic properties of Euclidean division
** h0 is function from N to carprod(m,N).
   Immediate from preceding and definition of h0.
** if k is in N, then k = m*Quo(k,m) + Rem(k,m)
   Basic property of Euclidean division.
** if k is in m*n, then Quo(k,m) < n.
   k is in N, and k < m*n.
   By Euclidean division of k by m,
    k = m*Quo(k,m) + Rem(k,m)
   0 <= Rem(k,m) < m
   So m*Quo(k,m) <= k.
   So m*Quo(k,m) < m*n.  (since k < m*n)
   0 <= Quo(k,m)
*** If Quo(k,m) = 0, then Quo(k,m) < n 
    since we assume 0 < n
*** if Quo(k,m) != 0, then Quo(k,m) < n
    0 < Quo(k,m) and (by assumption) 0 < m.
    Thus m*Quo(k,m) < m*n implies Quo(k,m) < n.
*** Thus Quo(k,m) < n
    From two preceding cases
**
   
  Then if k is in m*n, 
** h is function from m*n to p
   Since m*n is in N, Also m*n is a subset of N (by our definition of N)
   Thus, h is a function from m*n to carprod(m,N).
   By preceding, if k is in m*n, then Quo(k,m) is in n.
   Thus, h is function from m*n to carprod(m,n)
** For (i,j) in p,  h(g(i,j)) = (i,j).
   By assumption, 0 <= i < m, and 0 <= j < n
   Let k = g(i,j) = i + m*j.
   Since i < m, we know that i = Rem(k,m) and j = Quo(k,m).
   We also have h(k) = (Rem(k,m),Quo(k,m)) = (i,j).
** for k in m*n, g(h(k)) = k.
   g(h(k)) = g(Rem(k,m),Quo(k,m))
     = Rem(k,m) + m*Quo(k,m)
   Since k is in m*n, k is in N. So by Euclidean division
   k = m*Quo(k,m) + Rem(k,m)
   Thus g(h(k)) = k.
** g = inverse(h) and h = inverse(g) and g is a bijection and h is bijection.
  Playing with definitions of 'inverse function' and 'bijection'
** h is an enumeration of p, and Ncard(p) = m*n
  m*n is in N.
  h is a bijection from m*n to p.

  An 'enumeration' of a finite set 's' is, by definition, a bijection 
  f: Ncard(s) -> s.

  Thus, Ncard(p) = m*n. and h is an enumeration of p.
* carprodF : cartesian product of functions.
  Let f: m -> a and g : n -> b be two functions (m and n are just sets).
  Assume m and n are non-empty.  (therefore, also 'a' and 'b' are non-empty)
  We can define a function carprodF(f,g) : carprod(m,n) -> carprod(a,b) by
    carprodF(f,g)((i,j)) = (f(i),g(j)) for i in m, j in n.
  Let h = cardprodF(f,g).
  If f and g are bijections, then h is a bijection.
  and inverse(carprodF(f,g)) = carprodF(inverse(f),inverse(g)).
  Proof should be routine.
* prodSet(carprod(A,B)) = (prodSet(A)**NCard(B), prodSet(B)**Ncard(A))
  The proof below is close to complete. But not quite complete.
  Can this be improved so more understandable ?
  Assume: 'A' is a finite nonempty set, 
          'B' is a finite nonempty set.
  prod is some associative, commutative binary operation on A, with identity,
  and similarly for B.  
  E.g., A  and B are finite nonempty subsets of N* and Nprod is the binary operation.
  Example1: A is subset of a in N, prod on A is NProd(a).
            B is subset of b in N, prod on B is NProd(b).
     
  Let m = Ncard(A), n = Ncard(B).
  Choose bijection f: m -> A, and bijection g: n -> B.
  Let H = carProdF(f,g). So H is bijection carprod(m,n) -> carprod(A,B).
  Let P : m*n -> carprod(m,n) be the canonical enumeration of carprod(m,n).
  Let G = H#P: m*n -> carprod(A,B), composition of H with P. 
  For k<m*n,
    G(k) = H(P(k))
         = H((Rem(k,m),Quo(k,m)))
         = (f(Rem(k,m)) , g(Quo(k,m)))

  Then G is a bijection (since a composition of bijections).
  Let C = carprod(A,B).
  Then prod(C) = prod(G) (since G is an enumeration of C).
   = G(0)*...G(m*n - 1).
  
  Define a partition E of C as follows.
    Let section2 be function from B to powerset(c), whose value at b in B is
      section2(b) = {(a,b) where a is in A}.
    Let E = range(section2).
    E is a partition of C.
    Let e in E.  Choose b in B so e = section2(b).
     Pick j in n (0 <= j < n) so  b = g(j).
     Define a function q with domain 'm', whose value at 'i' in 'm' is
      q(i) = (f(i),b).
     Then q is a bijection from m to e.
     Thus prod(e) = prod(q) = (f(0),b)*...*(f(m-1),b) =
       ( f(0)*...*f(m-1), b*...*b) =
       (prod(A), b**m)  = (prod(A),g(j)**m)

    Thus, prod(E) = (prod(A),g(0)**m) *...* (prod(A),g(n-1)**m) 
                  = (prod(A)*...*prod(A), g(0)**m * ... * g(n-1)**m )
                  = (prod(A)**n , (g(0)*...*g(n-1))**m)
                  = (prod(A)**n , prod(B)**m)
     
* Square roots of 1 mod prime powers (preparatory to Gauss-Wilson theorem)
  Take 1<=n. 
   Let roots(n) = {x: 0<=x<n and  x^2 = 1 (mod n)} are the square roots 
    of 1 mod n.
  {1,n-1} are in roots(n).  Of course, x*x = x^2.
  Let T(n) = {1,n-1,n/2-1,n/2+1} (assuming (2 | n) and (n != 2) 
  Let eqn(k):  roots(2^k) = T(2^k).
** if 4 | n, then T(n) is subset of roots(n).
   Let m = Quo(n,4), so n = 4*m.
   So n/2 = 2*m. 
   Let x = 1 or n-1. Then x is in roots(n)
   Let x = n/2 - 1 = 2*m - 1
    x^2 - 1 = (2*m - 1)^2 - 1 = 4*m^2 - 4*m = 4*m*(m - 1)
    So n | (x^2 - 1), so x is in roots(n).
   Let x = n/2 + 1 = 2*m + 1
    x^2 - 1 = (2*m + 1)^2 - 1 = 4*m^2 + 4*m = 4*m*(m + 1)
    So n | (x^2 - 1), so x is in roots(n).
   Thus, T(n) is a subset of roots(n)
** if 4 | n, then NprodSet(T(n)) = 1 (mod n)
 m = Quo(n,4). So n = 4*m.
 NprodSet(T(n)) = 1*(n-1)*((2*m) - 1)*((2*m) + 1)
   = (n-1) * (4*m*m - 1) 
   = (n-1) * (n*m - 1)
   = -1 * -1 (mod n) = 1 (mod n).
** if 2|n and x is in T(n), then n-x is in T(n)
   x = 1:     n-x = n-1
   x = n-1:   n-x = 1
   x = n/2-1: n-x = n - n/2 + 1 = n/2+1
   x = n/2+1: n-1 = n - n/2 - 1 = n/2-1
** eqn(2)
   roots(4) = {1,3} = T(4) 
** If 2<=k and eqn(k), then eqn(k+1).
   Let n1 = 2^(k+1). We know 4|n1. So leq(T(n1),roots(n1)).
   It remains to show leq(roots(n1),T(n1)).
   Let n = 2^k. We know roots(n) = T(n).
   Let m = Quo(n,4). So n = 4*m.
   Let n1 = 2*n = 8*m.
   T(n1) = {1, n1 - 1, n - 1, n + 1}
*** Lemma: If 0<x<n and x is in roots(n1) then x is in T(n1).
    Suppose 0<x<n.
    Suppose x is in roots(n1)
     So x^2 - 1 = 0 (mod n1)
     Since n | n1, we also have x^2 - 1 = 0 (mod n).
     Thus, (since 0<x<n), x is in roots(n).
     By the inductive hypothesis, we conclude x is in T(n)
     Four cases: x = 1, x = n-1, x = Quo(n,2) - 1, x = Quo(n,2) + 1.
****  (a) If x = 1, then x is in T(n1).
****  (b) If x = n-1, then x is in T(n1).
****  (c) if x = Quo(n,2) - 1 = 2*m - 1, then x is not in roots(n1)
       x^2 - 1 = (4*m^2 - 4*m) = 4*m*(m-1).
       Thus x is in roots(n1) iff n1 | 4*m*(m-1) 
        iff 8*m | 4*m*(m-1)  
        iff 2*m | (m-1) . But m-1 < m < 2*m,  So 2*m could not divide m-1.
        thus x is NOT in roots(n1)
****  (d) if x = Quo(n,2) + 1 = 2*m + 1 and 2 < k, then x is not in roots(n1)
       x^2 - 1 = (4*m^2 + 4*m) = 4*m*(m+1).
       Thus x is in roots(n1) iff n1 | 4*m*(m+1) 
        iff 8*m | 4*m*(m+1)  
        iff 2*m | (m+1) . 
        4 < n, since 2 < k).
        So 1 < m, since m = Quo(n,4).
        So m + 1 < m + m, 
        So m + 1 < 2*m.
        Thus 2*m does not divide m+1.
        Thus x is not in roots(n1)
****  (e) if x = Quo(n,2) + 1 = 2*m + 1 and 2 = k, then x is in T(n1).
        n1 = 2^(2+1) = 8.
        n = 4.
        x = Quo(4,2) + 1 = 2 + 1 = 3.
        T(n1) = T(8) = {1,7,4-1,4+1} = {1,7,3,5}
        Thus x is in T(n1)
****  Thus, in all cases x is in T(n1)
*** if x = n, then x is not in roots(n1)
   x^2 - 1 = n^2 - 1. 
   n is even.  n^2 is even. Thus x^2 - 1 is odd.
   n1 is even.  Thus n1 does not divide x^2 - 1.
   So x is not in roots(n1)
*** if n < x and x is in roots(n1), then x is in T(n1).
   Let y = n1 - x = 2*n - x.
   Also, 0 < x < n1.
   y^2 - 1 = (n1*n1 - 2*n1*x + x^2) - 1
   Since x is in roots(n1). n1 | (x^2 - 1).  
   Thus n1 | y^2 - 1.
   Also we can show 0 < y < n1
    0 < y since x < n1
    y < n1 since 0 < x.
   Thus y is in roots(n1).
   Also, y < n:
    -x < -n NOTE USES Z arithmetic!
    y = 2*n - x < 2*n - n = n
   Thus, by preceding, y is in T(n1).
   Thus, n1-y is in T(n1). But, n1 - y = n1 - (n1 - x) = x.
   So, x is in T(n1)
*** if x is in roots(n1), then x is in T(n1)
   0 < x < n1, since x is in roots(n1).
   So, either 0<x<n or x=n or n<x
   If any of these cases, x is in T(n1)
** if n=2^k and 2<=k, then roots(n) = T(n) = {1,n-1,n/2-1,n/2+1}
  By induction: if 2<=k, then eqn(k).
** if n=2^k and 2<=k, then NprodSet(roots(n)) = 1 (mod n)
** OLD PROOF of prior statement
*** 2<=k and eqn(k) implies eqn(k+1).
  Let n = 2**((k+1)+1) = 2**(k+2)
  Let m = 2**(k+1).  
  So, n = 2*m
  Let s1 = S(x, 1<=x<n and Rem(x*x,n) = 1)
  Let s2 = {1, n-1, n/2 - 1, n/2 + 1} = {1,n-1,m-1,m+1}
  To show s1 = s2.
**** If x is in s2, then x is in s1.
  (a) 1*1 = 1, so Rem(1*1,n) = 1
  (b) (n-1)*(n-1) = n*n - 2*n + 1. So Rem((n-1)**2,n) = 1.
  (c) x = n/2 - 1. x**2 = (n/2)*(n/2) - 2*(n/2)*1 + 1
      n/2 = 2**(k+1)
      (n/2)*(n/2) = (2**(k+1))*(2**(k+1)) = 2**((k+1)+(k+1))
       = 2**((k+2+k)) = (2**(k+2))*(2**k) = n*(2**k)
      2*(n/2) = n
      x**2 = n*(2**k) + n + 1 
      Thus, Rem(x**2,n) = 1.  This x is in s1
  (d) x = n/2 + 1.  Similarly to (c), x is in s1.
**** if x is in s1, then x is in s2.
  Assumption 1<=x<n and Rem(x*x,n) = 1.
  n = 2**(k+2) = 2**((k+1)+1) = (2**(k+1))*(2**1) = 2*m
  Let y = Rem(x,m).  Thus, 
  There is q with 
   x = m*q + y, and 0<=q and y<m.
  Rem(y*y,m) = Rem(x*x,m).
  Since Rem(x*x,n) = 1 and
   since m|n, also Rem(x*x-1,m) = 0, or Rem(x*x,m) = 1.
  Thus, Rem(y*y,m) = 1.
  The condition x < n imposes constraints on q - namely q can only be 0 or 1
   m*q + y < n.  If 2<=q, then m*q + y <= m*2 + y = n + y.
   Now y != 0, since Rem(y*y,m) = 1.  
   Thus, if 2<=q, then m*q + y > n, i.e., x > n, contrary to assumption.

  By inductive hypothesis, y is one of s2(m) = {1, m-1, m/2 - 1, m/2 + 1}
  For each of these values of y, we show the corresponding values of x are in 
   s2  = {1, n-1, n/2-1, n/2+1} = {1, n-1, m-1, m+1}.
  
  Note, Since 1<=k, 1 < 2**(k+1), i.e. 1<m.
***** If y = 1 , then  x = 1 or m+1, so x in s2.
  x = m*q + y = m*q + 1.
  x < n,  m*q + 1 < n . What values of q are possible?
  q = 0.  Then x = y = 1, so x is in s2
  q = 1. x = m+1.  So x is in s2.
***** if y = m-1, then x = m-1 or n-1, so x is in s2
  x = m*q + (m-1),  
  q = 0.  x = m-1.  So x is in s2.
  q = 1. x = m + m - 1. 
           = 2*m - 1 = n - 1 
   So this case for q does not generate an x.
***** If y = m/2 - 1, then Rem(x*x,n) != 1
      x = m*q + 1 = m*q + (m/2) - 1.
******  Case q = 0 not possible as Rem(x*x,n) != 1
   Then x = (m/2) - 1.
   x*x = (m/2)*(m/2) - m + 1
   m/2 = (2**(k+1))/2 = 2**k
   (m/2)*(m/2) = (2**k)*(2**k) = 2**(k+k) = (2**(k+1))*(2**(k-1)) 
     = m*(2**(k-1))
   x*x = m*( (2**(k-1)) - 1) + 1.
   Now 2<=k so 1<=k-1. So 2**(k-1) != 1.  Thus 2 does not divide  2**(k-1) - 1
   Thus n does not divide x*x - 1.
   Thus Not Rem(x*x,n) = 1.
******  Case q = 1, as Rem(x*x,n) != 1
   Let u = m/2 = 2**k
   m = 2*(m/2)
   x = m + (m/2) - 1. = 3u - 1
    x*x = 9u*u - 6u + 1.  Is it possible that  n | x*x - 1 ?
    x*x - 1 = 9*u*u - 6u - 2.
    u*u = (2**k)*(2**k) = 2**(k+k).
    Since 2<=k,
     k+k = (k+2) + (k-2) 
     2**(k+k) = (2**(k+2)) * (2*(k-2)) =  n*(2*(k-2))
    Thus x*x - 1 = 9*n*(2*(k-2)) - (2*(3u+1))
    Thus, n | (x*x - 1) Iff n | (2*(3u+1)).
    But n = 2m, so n|(2*(3u+1)) iff m | (3u+1)
    If m | (3u+1), then (since 2|m) we would have 2|(3u+1).
    But, since u is even, then also 3u is even.  Thus 3u+1 is odd;
    so 2 does not divide 3u+1.
    Thus n does not divide 2*(3u+1).
    
     
    6u = 3*(2*u) = 3*m. Now gcd(3*m,n) = gcd(3*m,2*m) = m.
***** If y = m/2 + 1, then Rem(x*x,n) != 1
   x = m*q + y = m*q + (m/2) + 1
******  Case q = 0 not possible as Rem(x*x,n) != 1
   Then x = (m/2) + 1.
   x*x = (m/2)*(m/2) + m + 1
   m/2 = (2**(k+1))/2 = 2**k
   (m/2)*(m/2) = (2**k)*(2**k) = 2**(k+k) = (2**(k+1))*(2**(k-1)) 
     = m*(2**(k-1))
   x*x = m*( (2**(k-1)) + 1) + 1.
   Now 2<=k so 1<=k-1. So 2 | 2**(k-1)  Thus 2 does not divide  2**(k-1) + 1
   Thus n does not divide x**2 - 1.
   Thus Not Rem(x*x,n) = 1.
  
******  Case q = 1 Then Rem(x*x,n) != 1
   x = m*q + y = m + (m/2) + 1.
   Let u = m/2 = 2**k
   m = 2*(m/2) = 2*u
   x = m + (m/2) + 1 = 3u + 1
   x*x - 1 = 9u*u + 6u 
   Is it possible that  n | x*x - 1 ?    
    u*u = (2**k)*(2**k) = 2**(k+k).
    Since 2<=k, k+k = (k+2) + (k-2). Thus
    u*u =  2**(k+k) = (2**(k+2)) * (2*(k-2)) =  n*(2*(k-2))
    Thus, n | u*u.
   Is it possible that n | 6u ? No
    6u = 3*2*u = 3*m; Recall that n = 2*m
    Does 2*m | 3*m?  No. 
     Suppose 3*m = 2*m*t for some 0<=t in N
     Thus, 3 = 2*t.  But this is not possible.
 
**** Thus, if x is in s1 for every value of y, x is in s2. T 
**** Thus s1 = s2. QED

*** By induction, 2<=k implies eqn(k).
** if n is a prime, then roots(n) = {1,n-1}
 Let p = n. Thus 1<p.
 Thus 0 != 1 (mod p).
 Thus 0 is not in roots(p).
*** if 1 < x < (p-1), then x is not in roots(p)
   Proof: then x*x != 1 (mod p):
   x*x = 1 so (x-1)*(x+1) = 0 (mod p). 
   Thus p divides (x-1)*(x+1).  
   By Corollary 2 to Euclid's lemma, p | (x-1) OR p | (x+1).
   Since 1<x<p-1,  then 1-1 < x-1 < p-2. So 0 < x-1 and x-1 < p. 
    Since x-1 < p,  p does not divide x-1.
   Since x < p-1, also x+1 < p.  and also 0 < x+1.  Thus p does not divide x+1.
*** Thus only 1 and p-1 are in roots(p). QED
** if n is a prime, then NprodSet(roots(n)) = -1 (mod n)
** if n = p^k where p is a prime, p!=2 and 1<=k, then roots(n) = {1,n-1}
  Assume 1<=k and p is an odd prime and n = p^k.
*** if x is in roots(n) and x != 1, then (n | (x-1)) OR (n | (x+1))
  Assume x in roots(n) and x != 1.
  Let e = (x**2 - 1)
    0 < x < n and n | e, since x in roots(n).
    e = (x-1)*(x+1).
   p | n. Thus p | e.  
   Since p is prime, p|(x-1) or p|(x+1).
  if p |(x-1) and p|(x+1), then p|2 (since x+1 = (x-1) + 2); 
    but p does not divide 2, since p is a prime and p != 2.
  Thus p does not divide both (x-1) and (x+1).
**** if p|(x-1), then n | (x-1).
   We know p does not divide x+1.
   Let s = {i: 1<=i<=k and p^i | (x-1)}.  s is finite.
   Since p|(x-1), 1 is in s, so s is not empty.
   Let m = max(s). So m is in s.  So 1<=m<=k and p^m | (x-1).
   If m = k, then n | (x-1) as was to be proved.
   But the assumption m != k  leads to a contradiction, as follows.
    First, m < k  (since m<=k and m!= k).
    Thus k is not in s, since m = max(s).
    Thus p^k does not divide x-1.
    Let a = Quo(x-1,p^m).
    x-1 = p^m * a, since p^m | (x-1)   
    Let b = Quo((x-1)*(x+1),p^k)
    (x-1)*(x+1) = p^k * b, since p^k | (x-1)*(x+1).
    The assumption that  p | a leads to a contradiction.
     Let r = Quo(a,p).
     1<=r and a = p*r, since p|a and 0 < p.
     (x-1) = p^m * a
           = p^m * p * r = p^(m+1) * r. 
     Thus p^(m+1) | (x-1). 
     Now 1 <= m+1 <= k, since 1 <= m < k.
     Thus m+1 is in s,
     m < m+1, contrary to choice of m as max(s).
    Thus, p does not divide a.
 
    Let j = k-m. 
    0 < j and k = m + j, since m < k.
    
    p^k = p^m * p^j
    (x-1)*(x+1) = p^k * b
    (x-1) = p^m * a
    p^m * a * (x+1) = p^m * p^j * b
    a * (x+1) = p^j * b
    p^j | a * (x+1)
    p | p^j since 1<=j
    Thus, p | a * (x+1).
    p | a or p | (x+1), since p is a prime
    But p divides neither a nor x+1.
    This is the contradiction.

**** if p|(x+1), then n | (x+1).
   We know p does not divide x-1.
   Let s = {i: 1<=i<=k and p^i | (x+1)}.  s is finite.
   Since p|(x+1), 1 is in s, so s is not empty.
   Let m = max(s). So m is in s.  So 1<=m<=k and p^m | (x+1).
   If m = k, then n | (x+1) as was to be proved.
   But the assumption m != k  leads to a contradiction, as follows.
    First, m < k  (since m<=k and m!= k).
    Thus k is not in s, since m = max(s).
    Thus p^k does not divide x+1.
    Let a = Quo(x+1,p^m).
    x+1 = p^m * a, since p^m | (x+1)   
    Let b = Quo((x-1)*(x+1),p^k)
    (x-1)*(x+1) = p^k * b, since p^k | (x-1)*(x+1).
    The assumption that  p | a leads to a contradiction.
     Let r = Quo(a,p).
     1<=r and a = p*r, since p|a and 0 < p.
     (x+1) = p^m * a
           = p^m * p * r = p^(m+1) * r. 
     Thus p^(m+1) | (x+1). 
     Now 1 <= m+1 <= k, since 1 <= m < k.
     Thus m+1 is in s,
     m < m+1, contrary to choice of m as max(s).
    Thus, p does not divide a.
 
    Let j = k-m. 
    0 < j and k = m + j, since m < k.
    
    p^k = p^m * p^j
    (x-1)*(x+1) = p^k * b
    (x+1) = p^m * a
    (x-1)* p^m * a = p^m * p^j * b
 
    a * (x-1) = p^j * b
    p^j | a * (x-1)
    p | p^j since 1<=j
    Thus, p | a * (x-1).
    p | a or p | (x-1), since p is a prime
    But p divides neither a nor x-1.
    This is the contradiction.

**** Thus, n | (x-1)  OR (n | (x+1))Since (p | (x-1)) OR (p | (x+1))
*** If x is in roots(n) and x != 1, then n does NOT divide x-1.
    0 < x < n, so 0 <= x-1 < n.  
    0 != x-1,  ince x != 1
    0 < x-1 < n.
    Thus, n does not divide x-1.
*** If x is in roots(n), then x = 1 or x = n-1.
   Assume x is in roots(n).
   Thus 0 < x < n.
   Assume x != 1 and show x = n-1.
   Thus, n | (x+1). Let q = Quo(x+1,n).
   x+1 = n*q and  0 < q.
   1 < x+1 < n+1
   1 < n*q < n+1.
   If 1 < q, we get contradiction:
    1 < q
    2 <= q
    n*2 <= n*q < n+1
    n*2 = n + n
    n + n < n + 1
    n < 1
    n = 0
    Contradicting assumption 1<=n
   Thus q = 1
   x + 1 = n*1 = n
   x = n - 1.

** if n = p^k where p is a prime, p!=2 and 1<=k, then NprodSet(roots(n)) = -1 (mod n)
* Gauss-Wilson Theorem
  For For 2<=n, let rp(n) = rpprod(n) = Rem(NprodSet(relprimes(n)),n)
  Let roots(n) = {x: 0<=x<n and  x^2 = 1 (mod n)}
** rp(n) = Nprodset(roots(n)).
 Consider the group (G,e,*) = (relprimes(n),1,mutliplication modulo n).
 This is a finite abelian group.
 Note rp(n) = prodSet(G).
 Let G0 = {x: x in relprimes(n) and x*x = 1 (mod n)}.
 prodSet(G) = prodSet(G0), by Wilson theorem for finite abelian groups
 Further G0 = roots(n).
  If x in relprimes(n), then 0 < x < n  (since 2<=n)
  Thus G0 is a subset of roots(n)
  Suppose x is in roots(n). We show: x is in relprimes(n)
   We must show: 1<=x<=n and gcd(x,n) == 1
   0<=x<n and x*x = 1 (mod n).
   Thus, there is 0<=y such that x*x = n*y + 1.
   If x = 0, then 0 = 1 (mod n), which is false since 2<=n.
   Thus 0 < x < n.
   Thus 1<=x<=n.
   Let I = gcdIdeal(x,n).
   Since 1<=x and 0<=y and x*x = n*y + 1, then 1 is in gcdIdeal(x,n).
   Since 1<=x and 1<=n, NidealQ(gcdIdeal(x,n)).  Hence,
   gcd(x,n) = NMin(gcdIdeal(x,n)) and 1<=gcd(x,n).
   Since 1 is in gcdIdeal(x,n), NMin(gcdIdeal(x,n)) <= 1.
   Thus gcd(x,n) = 1.

** miscellany
*** 0a. The wilson partition Q of relprimes(n)
  Define function s: relprimes(n) -> subsets of relprimes(n) by
   s(x) = {x,inverse(x)}  for x in relprimes(n).
   Here inverse(x) is that element of relprimes(n) such that n | x*inverse(x).
   (see theorem 3 of relprimes).
  Q = range(s).  If a is in s(x) and s(y), then s(x) = s(y).
   Proof: If a = x and a = y, then x = y.
   if a = x and a = inverse(y), then inverse(a) = y so s(x) = s(y).
   etc. QED.
  Q is a partition of relprimes(n). We may call it the Wilson partition.
*** Example n = 7
   relprimes(7) = {1,2,3,4,5,6}
   inverse(x) is in relprimes(7) and x*inverse(x) = 1 (mod 7)
   inverse(1) = 1  1*1 = 1 (mod 7)
   inverse(2) = 4  2*4 = 1
   inverse(3) = 5
   inverse(4) = 2
   inverse(5) = 3
   inverse(6) = 6
   Q = { {1}, {2,4}, {3,5}, {6}}
   NprodSet(relprimes(7)) = 1*2*3*4*5*6 
     = NprodSet({1}) * NprodSet({2,4}) * NprodSet({3,5}) * NprodSet({6}) =
   Applying rem(_,7) (Let a#b = Rem(a*b,7))
     rp(7) = 1 # 1 # 1 # 6 = 6
*** Example n = 8
   relprimes(8) = {1,3,5,7}
   for x in relprimes(8), 
     inverse(x) is in relprimes(8) and x*inverse(x) = 1 (mod 8)
   inverse(1) = 1
   inverse(3) = 3
   inverse(5) = 5
   inverse(7) = 7
   So Q = {{1}, {3}, {5}, {7}}
   NprodSet(relprimes(8)) =  1*3*5*7
     
*** Example n = 16
   relprimes(16) = {1,3,5,7,9,11,13,15}
   x*x = 1 (mod 16) when x in {1,7,9,15}
   1*7*9*15 = 1*63*15 = 1*-1*-1 (mod 16) = 1
*** Example n = 32 = 2^5
   relprimes(32) = {x,1<=x<=32, x = 2*y+1 where 0<=y<=15}
   0<=y<=15) and (2*y + 1)*(2*y + 1) = 4*y*y + 4*y + 1 = 1(mod n) iff
   (4*y)*(y+1) = 0 (mod 32) iff 
** OBSOLETE 0b : rpprod(n) = Rem(NprodSet({x in relprimes(n): x = inverse(x)}),n)
  Each element of Q has either 1 element (when x = inverse(x)) or
  two elements when x!=inverse(x).
  Define function f:Q->N by f(q) = NprodSet(q). 
     So if q = s(x) and x = inverse(x), then f(q) = x.  
        if x != inverse(x), then f(q) = x*inverse(x) = 1 (mod n).
     Thus, Q partitions into two pieces Q1 = {q in Q, NCard(q) = 1}
       Q2 = {q in Q, NCard(q) = 2}.
  Let m = NCard(Q).
  Let g : m -> Q be an enumeration of Q. (i.e. a bijection)
  Then NprodSet(relprimes(n)) = NprodSeq(f#g) (function composition).
  Let g1 : m1 -> Q1 be an enumeration of Q1, 
  and g2 : m2 -> Q2 an enumeration of Q2.
  Then NprodSeq(f#g) = NprodSeq(f#g1)*NprodSeq(f#g2).
   and f#g2(i) = x*inverse(x) = 1 (mod n),
   So NprodSeq(f#g2) = 1.
   Thus NprodSeq(f#g1) = 
    NprodSet(x: x in relprimes(n) and x = inverse(x)).

  
** 1a : rpprod(4) = -1; rpprod(2) = 1
  For 1<=n, rpprod(n) = product (modulo n) of relprimes(n).
  If n = 4, then rpprod(n) = -1.
   Proof: relprimes(4) = {1, 3}.  rpprod(4) = 1*3 = 3 (mod 4) = -1 (mod 4).
  if n = 2, then rpprod(n) = 1
   Proof: relprimes(2) = {1}. 
** 1b : if n=2**k where 3<=k, then rpprod(n) = 1
   prod(relprimes(2**(k+1))) = 1 (mod 2**(k+1)) if 2<=k 
 
  We showed above (for m=2**j, 3<=j) and 0 < x < m that 
   {x in relprimes(m): m | (x^2 -1)} = {1,m-1,m/2-1,m/2+1}
   
   Thus (by 0c),  rp(n) = Rem(1*(n-1)*(n/2 - 1)*(n/2 + 1), n) 
   Example: k = 5. n = 2^k = 32. n/2 = 2^4 = 16. 
    (16-1)*(16+1) = 16*16 - 1 = -1 (mod 32).
   Let m = n/2 = 2**k
   (m-1)*(m+1) = m*m - 1 .
   m*m = (2**k)*(2**k) = 2**(k+k) 
   And, k+1 <= k+k, so n | m*m.
   Thus, Rem((n/2 + 1)*(n/2 - 1), n) = 0
   Thus Rem((m-1)*(m+1),n) = -1
   Thus,Rem(1*(n-1)*(n/2 + 1)*(n/2 - 1),n) = Rem(1*-1*-1,n) = 1.
   Thus, rp(n) = 1 (mod n).

** 1c : if n=p where p is prime and !=2, then rpprod(n) = -1
  If n is a prime, then rpprod(n) = -1 
  By Wilson's theorem, (n-1)! = -1 (mod n).
  Also, relprimes(n) = {1,...,n-1} since n is prime.
  So rpprod(n) = (n-1)! (mod n).
** 1d : if n = p**k where p is prime, p!=2 and 1<=k, then rpprod(n) = -1
 prod(relprimes(p**k)) = -1 if p is an odd prime and 1<=k.
 Case k = 1 is Wilson's Theorem.
 We Have shown {x in relprimes(n): n | (x^2 -1)} = {1,n-1}.
 Thus, by 0c, rpprod(n) = Rem(NprodSet({1,n-1}),n) = Rem(1*(n-1),n) = n-1.
** 2a : gcd(m,n) = 1, 1<m, 1<n, then CRF(m,n)(rpprod(m*n)) = (rpprod(m)**ephi(n), rpprod(n)**ephi(m))
  Let F = CRF(m,n) be the Chinese remainder isomophism: m*n -> carprod(m,n).
  Then, F(rpprod(m*n)) = (rpprod(m)**ephi(n), rpprod(n)**ephi(m))
  Let X = m*n.
  By statement (9) of CRF theorem above,
  image(F,relprimes(X)) = carprod(relprimes(m),relprimes(n)) 
   rpprod(X) = prod(relprimes(X))  by definition of rpprod
   F(rpprod(X)) = F(prod(relprimes(X)))
     = prod(image(F,relprimes(X)))  since F is ring morphism [Needs lemma!]
     = prod(carprod(relprimes(m),relprimes(n)))
     = (prod(relprimes(m))**NCard(relprimes(n)),
        prod(relprimes(n))**NCard(relprimes(m)))
     = (rpprod(m)**ephi(n), rpprod(n)**ephi(m))
         by definitions of rpprod ephi.
       
** 2b : Statement of Gauss-Wilson Theorem
https://sites.math.washington.edu/~morrow/336_09/papers/Andrew.pdf

  This states rpprod(n) for cases of n
  a) n = 1, rpprod(1) = 0 (mod 1); 
    Note: this is same as rpprod(1) = 1 (mod 1)
   n=2, rpprod(2) = 1

  b) n = 4, rpprod(4) = n-1 (mod n) = -1 (mod n) in Nring(n)
  c) n = p^k where p is an odd prime and 1<=k, rpprod(p^k) = -1 (mod n)
  d) n = 2*(p^k) where p is an odd prime and 1<=k, rpprod(2*(p^k)) = -1 (mod n)
  e) n other than above, rpprod(n) = 1. (mod n)
** 3a : rpprod(1) = 0; rpprod(2) = 1
  relprimes(1) = {1}. rpprod(1) = Rem(1,1) = 0.
  relprimes(2) = {1}. rpprod(2) = NprodSet({1}) = 1
** 3b : rpprod(4) = -1
  relprimes(4) = {1,3}. rpprod(4) = Rem(1*3,4) = 3 
** 3c : rpprod(p^k) = -1 if p is odd prime and 1<=k
  Proof at 1d
** 3d : rpprod(2*(p^k)) = -1 if p is odd prime and 1<=k
  Since p is odd prime, gcd(2,p^k) = 1.
  Let F = CRF(2,p^k).
  By 2a, F(rpprod(2*(p^k))) = (rpprod(2)^ephi(p^k), rpprod(p^k)^ephi(2))
   = (1^ephi(p^k), (-1)**ephi(2))  by 3a
   = (1,(-1)**1) = (1,-1)
   = -(1,1) 
   = F(-1), since F is ring homomorphism
  Thus rpprod(2*(p^k)) = -1, since F is injection (ring isomorphism)
** 3e1: rpprod(n) = 1 if n is odd, n!=1 and n not a prime power
  Thus (?) n is a product of 2 or more relatively prime powers.
*** Case n = a*b where a and b are prime powers and gcd(a,b) = 1.
  Let F = CRF(a,b). By 2a,
   F(rpprod(n)) = (rpprod(a)**ephi(b),Rpprod(b)**ephi(a))
      = ((-1)**ephi(b),(-1)**ephi(a))  By 3c applied to a and to b
      = (1,1) since
              ephi(a) is even (see #3 under ephi multiplicativity)
              ephi(b) is even, similarly.
   Also F(1) = (1,1), since F is ring homomorphism.
   Thus, rpprod(n) = 1 (since F is injective)
*** General case by induction on number of relatively prime prime powers in n.
   n = q1*...*qm  (qi a prime power, gcd(qi,qj) = 1 if i!=j) 2<=m.
   Case m = 2 shows in previous section.
   Inductive assumption rpprod(n) = 1
   n1 = n*r (r a prime power, relatively prime to all qi)
   Thus, gcd(n,r) = 1  (By Euclid Lemma Corollary 3, perhaps extended inductively)
   Let F = CRF(n,r). 
    F(rpprod(n1)) = (rpprod(n)**ephi(r), rpprod(r)**ephi(n))
      = (1**ephi(r), rpprod(r)**ephi(n))  inductive assumption
      = (1**ephi(r), (-1)**ephi(n))   by 3c
      = (1,(-1)**ephi(n)))
      = (1,1)  ephi(n) is even since n is odd and 3<=n
   Also F(1) = (1,1) F a ring homomorphism
   This rpprod(n1) = 1 since F is injective.

** 3e2: rpprod(2*n) = 1 when n is odd but n!=1 and n not a prime power
  gcd(2,n) = 1.
  Let F = CRF(2,n).
  By 2a, F(rpprod(2*n)) = (rpprod(2)**ephi(n), rpprod(n)**ephi(2))
   = (1**ephi(n), (1)**ephi(2))  by 3e1
   = (1,1**1) = (1,1) since ephi(2) = 1
  Also F(1) = (1,1) since F is ring homomorphism
  Thus rpprod(2*n) = 1, since F is injection (ring isomorphism)
** 3e3: rpprod(4*n) = 1 when n is odd but n!=1 and n not a prime power
  gcd(4,n) = 1.
  Let F = CRF(4,n).
  By 2a, F(rpprod(4*n)) = (rpprod(4)**ephi(n), rpprod(n)**ephi(4))
   = ((-1)**ephi(n), (1)**ephi(4))  by 3b
   = ((-1)**ephi(n), 1) 
   = (1,1)  ephi(n) is even since n is odd (ephi multiplicativity #3)
  Also F(1) = (1,1) since F is ring homomorphism
  Thus rpprod(4*n) = 1, since F is injection (ring isomorphism)

** 3e4a: rpprod((2^k)*n) = 1 when 3<=k and n is odd and n!=1 and n not a prime power
  gcd(2^k,n) = 1 since n is odd.
  Let m = 2^k
  Let F = CRF(m,n).
  By 2a, F(rpprod(m*n)) = (rpprod(m)**ephi(n), rpprod(n)**ephi(m))
   = (1**ephi(n), (rpprod(n))**ephi(m))  by 1b
   = (1,(rpprod(n))**ephi(m)) 
   = (1,1**ephi(m)) by 3e1
   = (1,1)
   Also F(1) = (1,1) since F is ring homomorphism
  Thus rpprod(2*n) = 1, since F is injection (ring isomorphism)
  
** 3e4b: rpprod((2^k)*n) = 1 when 3<=k and n is odd and n!=1 and n is a prime power
  gcd(2^k,n) = 1 since n is odd and n!=1 and n is a prime power
  Let m = 2^k
  Let F = CRF(m,n).
  By 2a, F(rpprod(m*n)) = (rpprod(m)**ephi(n), rpprod(n)**ephi(m))
   = (1**ephi(n), (rpprod(n))**ephi(m))  by 1b
   = (1,(rpprod(n))**ephi(m)) 
   = (1,(-1)**ephi(m)) by 3c , since n is a prime power
   = (1,1) Since ephi(m) is even (property 11 of ephi)
   Also F(1) = (1,1) since F is ring homomorphism
  Thus rpprod(m*n) = 1, since F is injection (ring isomorphism)
** 3e4 : rpprod((2^k)*n) = 1 when 3<=k and n is odd and n!=1
   From 3e4a and 3e4b
** 
* Cosets of subgroup partition the group (Lagrange)
 G any group, H any subgroup.
 For x in G, define Coset(x,H) = {x*y for y in H}
 Let C = Cosets(H) = {Coset(x,H) for x in G}.
 Coset(x,H) is subset of G and contains x*e = x, so is not empty.
** (a) if y in G, and x is in Coset(y,H) and c is in H, then x*c is in Coset(y,H)
 Choose u in H with x = y*u.  Then 
 x*c = (y*u)*c = y*(u*c), and u*c is in H
 Thus, y*(u*c) is in Coset(y,H). Hence x*c is in Coset(y,H)
** (b) if y in G and x in Coset(y,H), then leq(Coset(x,H),Coset(y,H))
   easily from (a)
** (c) if x and y in G, and z in Coset(x,H) and Coset(y,H), then leq(Coset(x,H),Coset(y,H))
 Choose u in H with z = x*u and choose v in H with z = y*v.
  So, x*u = y*v, so x = y*v*inverse(u).  

  Since H is a subgroup, v*inverse(u) is in H.
  Thus, y*(v*inverse()) is in Coset(y,H).
  Thus, x is in Coset(y,H).
 By (b), conclude leq(Coset(x,H),Coset(y,H))
** (d) if x and y in G, and z in Coset(x,H) and Coset(y,H), then eq(Coset(x,H),Coset(y,H))
  Corollary of (c)
** (e) If c1 and c2 are in C, and isect(c1,c2)!= 0, then c1 = c2.
  From (d)
 Now if a is in Coset(x,H), choose c in H with a = x*c.
** union(C) = G.
 Finally, if x is in G, then e is in H so x*e is in Coset(x,H).
 So, union(C) = G.
** Thus, C is a partition of G

* Corollary: If H is subgroup of finite group G, then NCard(H) | NCard(G)
 Proof: Since C is partition of G, Sum(NCard(c): c in C) = NCard(G)
 Also if c is in C, then NCard(c) = NCard(H)
  Choose x in G so c = Coset(x,H).
  Define f: H -> c by f(h) = x*h.
  Then f is a bijection.
 Thus, NCard(H) = NCard(c).
 Also, C is finite.
 Thus NCard(C)*NCard(H) = Sum(NCard(c): c in C) = NCard(G).
 So NCard(C) divides Ncard(G).
* order of finite group element, groupPrimRootQ, groupPrimRoots of a finite group
 We know that relprimes(n) is a group (under multiplication modulo n) for 1<=n.
 And relprimes(n) is finite, of order ephi(n).
 Consider a finite group (G,e,*) (not necessarily abelian)
 group multiplication. And define 'exponentiation' ** in G by
 x**0 = e, x**(k+1) = x*(x**k) (for 0<=k).
  So x**1 = x*(x**0) = x*e = x, and x**2 = x*x.
** (0a) x**(j+k) = (x**j)*(x**k)
** (0b) x**(j*k) = (x**j)**k
** -----------------------------
** orders(x,G) = S(k, 1<=k and x**k = e) is an Nideal
 Let S = orders(x,G).
 define function f: N* -> G  by f(k) = x**k.
 Since G is finite, f is not injective.  Choose 1<=j < k so that
 f(j) = f(k), thus x**j = x**k.
 Let i be the element of N* such that j+i = k
  Then x**k = (x**j)*(x**i).
  Thus x**j = (x**j)*(x**i),  Thus x**i = e.
  Thus i is in S.
 Thus S is not empty.
 If j and k are in S, then x**(j+k) = (x**j)*(x**k) = e*e = e, so j+k is in S.
 If j is in S, k in N* and j+k in S, then
  x**j = e, x**(j+k) = e.  So x**k = e. Thus k is in S.
 Thus, NidealQ(orders(x,G)).
** Define order of x in G = ord(x,G) = Nmin(orders(x,G))
** Define groupPrimRootQ(x,G) and groupPrimRoots(G)
   groupPrimRootQ(x,G) iff x in G and ord(x,G) = NCard(G) (i.e., x is a primitive root of G)
   groupPrimRoots(G) = {x, groupPrimRootQ(x,G)}.   
   For some groups (e.g., (relprimes(15),Nprod(15),1)),  there are NO primitive roots of G.
*** If x is in G, then groupPrimRootQ(x,G) Iff gen(x) = G
** -----------------------------
** (1a) ord(x,G) is in orders(x,G)
** (1b) 1 <= ord(x,G)
** (1c) x**ord(x,G) = e
** (1d) if k in orders(x,G), then ord(x,G) | k
** (1e) if 1<=k and ord(x,G) | k, then k is in orders(x,G)
** (1f) if 1<=k, then k is in orders(x,G) iff ord(x,G) | k.
** -----------------------------
** (2)  if 0<=k, x**k = x**Rem(k,ord(x,G))
   Let ox = ord(x,G)
   By division of k by ox in N, k = ox*q + r,
    where q = Quo(k,ox) and r = Rem(k,ox).
   Now x**k = x**(ox*q + r) = (x**(ox*q)) * x**r = ((x**ox)**q) * x**r =
            = (e**q) * (x**r) = e * (x**r) = x**r. QED.
** (2a) if 1 <= j < k <= ord(x,G), then x**j != x**k.
    Suppose x**j = x**k. 
     Derive a contradiction
     Set i = k-j. 
     1 <= i < ox
     x**j = x**k
          = x**(i+j) = (x**i) * (x**j).
     Thus x**i = e. 
     Thus i in orders(x,G). 
     Thus Nmin(orders(x,G)) <= i.
     i.e. ox <= i.
     Contradicting i < ox
    Thus x**j != x**k
** (2b) if 1 <= j <= ord(x) and 1 <= k <= ord(x) and x**j = x**k, then j = k.
   Apply (2a) twice.
** (2c) if 0 <= j < ord(x) and 0 <= k < ord(x) and x**j = x**k, then j = k.
   Case: 0 < j and 0 < k.
    By (2b).
   Case: j = 0
    Then x**k = x**j = x**0 = e.
    If k != 0, then k is in orders(x,G), so ox < k, contrary to assumption.
    So k = 0.
    So j = k.
   Case k =  0,
    Then x**j = x**k = x**0 = e.
    If j != 0, then j is in orders(x,G), so ox < j, contrary to assumption.
    Thus j = 0.
    Thus j = k.
** (3a) if 0<=j and 0<=k, then x**j = x**k iff Rem(j,ox) = Rem(k,ox)
   Let r = Rem(j,ox) and s = Rem(k,ox). 
   0 <= r < ox
   0 <= s < ox
   x**j = x**r, by (2)
   x**k = x**s, by (2)
*** If r = s, then x**j = x**k
*** if x**j = x**k, then r = s
    x**r = x**s.
    r = s, by (2c)
** (3b) if 1<=k,  x**k = e iff ox divides k.
   See (1f)

** (3c) if 1<=k,  x**(k+1) = x Iff ox divides k.
   Proof: by 3b,  x**k = e iff ox divides k.
   x**(k+1) = (x**k) * (x**1) = (x**k) * x.
    If x**(k+1) = x, then e*x = (x**k)*x, so x**k = e
    if x**k = e, then x**(k+1) = e*x = x.
   Thus, x**(k+1) = x iff x**k = e.
   So x**(k+1) = x iff ox divides k
** -----------------------------
** (4) Define : Group G is cyclic iff there is x in G with ord(x) = NCard(G).
** (5) Define : for x in G, gen(x) = {x**k for k in N}. 
** (5a0) gen(x) = S(x**k, 1<=k<=ord(x))
   Let gen1(x) = S(x**k, 1<=k<=ord(x)).
   If y is in gen1, then choose 1<=k<=ox with y = x**ox. k is in N. y in gen.
   if y in gen, choose k in N with y = x**k. 
    Set r = Rem(k,ox). Then 0<=r<ox. and x**k = x**r (3a).
    if r = 0, then y = x**0 = x**ox; so y is in gen1.
    if r != 0, then 1<=r<=ox so y is in gen1.
    Thus y is in gen1.
   Thus gen1 = gen.
** (5a1) NCard(gen(x)) = ord(x,G).
   f: T = {k, 1<=x<=ord(x)} -> gen(x):   f(k) = x**k.
   By 5a0, range f = gen(x).
   Using (3a), we see the f is injective.
   Thus, f is bijection.
   Thus NCard(T) = NCard(gen(x)).
   And NCard(T) = ord(x).
   QED.
** (5a) if x in G, then gen(x) is a subgroup of G
   Recall G is finite group.
          Since x**ord(x,G) = e, thus e in gen(x).
          and x**(k1+k2) = (x**k1) * (x**k2)), thus gen(x) is closed under *.
          Let y in gen(x). 
          choose 1<=k<=ox so that y = x**k (5a0)
          If k = ox, then y = e, and inv(y) = y, so inv(y) in gen(x)
           if 1<=k<ox, let j = ox - k;  
             Thus 1<=j<=ox and
             (x**k) * (x**j) = x**ox = e, so inv(x) = x**j and x**j in gen(x).
         Thus gen(x) is closed under inverses.
         Thus gen(x) is a subgroup of G.
** (5b) if 1<=m and gcd(m,ox) = 1, then gen(x**m) = gen(x).
*** a. x**m is in gen(x)
     Since m in N.
*** b. x is in gen(x**m)
   Let o = ord(x,G)
   By Bezout theorem, we may choose 1<=a and 0<=b so that  
   m*a = o*b + gcd(m,o)
   m*a = o*b + 1, since gcd(m,o) = 1.
   (x**m)**a  
        = x**(m*a) 
        = x**(o*b + 1)
        = (x**(o*b)) * (x**1)
        = ( (x**o)**b) * x
        = ( e**b ) * x
        = e * x
        = x
   Thus, x is gen(x**m).
*** gen(x**m) = gen(x)
   Some general argument. If y is in gen(z), then gen(y) is subset of gen(z).

** (5c) if 1<=m and gen(x**m) = gen(x), then gcd(m,ox) = 1.
  Since x is in gen(x), x is in gen(x**m)
  Choose 1<=k with x = (x**m)**k = x**(m*k) 
  Also x**1 = x.  Thus x**1 = x**(m*k).
  By (3a), Rem(1,ox) = Rem(m*k,ox).
*** case 1: ox = 1
  Thus, gcd(m,ox) = gcd(m,1) = 1
*** case 2: ox != 1
  Thus, 1<ox.
  1 = ox*Quo(1,ox) + Rem(1,ox).
  Quo(1,ox) = 0, since 1 < ox.
  Rem(1,ox) = 1.
  Rem(m*k,ox) = 1.
  So m*k = ox*q + 1 where q = Quo(m*k,ox).
  So 1 in gcdIdeal(m,ox).
  Thus, NMin(gcdIdeal(m,ox)) = 1.
  Thus, gcd(m,ox) = 1, since gcd(m,ox) = NMin(gcdIdeal(m,ox)), by Bezout.
** (5d) if x is in G, then NCard({y in G with gen(y) = gen(x)}) = ephi(ord(x))
   Let S = {y in G with gen(y) = gen(x)}.
   To show: NCard(S) = ephi (ord(x,G))
   Let S1 = {x**m for m in relprimes(ox)}.
*** a. if y is in S, then y is in S1
   Since y is in gen(y), then also y is in gen(x).
   There is m  with 1 <= m <= ox and y = x**m.
   gen(x**m) = gen(x). 
   gcd(m,ox) = 1, by (5c).
   m is in relprimes(ox).  
   y is in S1.
*** b. If y is in S1, then y is in S
   Choose m in relprimes(ox) so that y = x**m.
    Thus 1 <= m <= ox and gcd(m,ox) = 1. 
    gen(x**m) = gen(x), by (5c).
    gen(y) = gen(x).
    y is in S.
*** S = S1 
   from a, b.
*** NCard(S) = NCard(S1).
*** if m and n are in relprimes(ox), and x**m = x**n, then m = n.
    1 <= m <= ox,  gcd(m,ox) = 1
    1 <= n <= ox,  gcd(n,ox) = 1
    x**m = x**n, by assumption
    if 1 <= m <= ord(x) and 1 <= n <= ord(x) and x**m = x**n, then m = n (2b)
    m = n.
**** case m < n not possible
   choose k in N* so m+k = n.  Since 1<=m<=ox and 1<=n<=ox, then
    0 < k < ox.  
    x**n = x**(m+k) = (x**m)*(x**k). So x**k = e. 
    But this contradicts the minimality of ox.  
**** Similarly, n < m not possible.
**** Thus m = n.
*** NCard(relprimes(ox)) = NCard(S1) 
   Define function f: relprimes(ox) -> S1 defined by f(m) = x**m
   range(f) = S1.
   f is injective (previous section)
   f is bijection.
   Thus NCard(relprimes(ox)) = NCard(S1)
*** NCard(S) = ephi(ox)

** (6) ord(x,G) divides NCard(G).
  NCard(gen(x)) = ord(x,G) (5a1)  
  gen(x) is a subgroup of G.  (5a)
  NCard(gen(x)) divides NCard(g), by Lagrange theorem on Coset partitions
  ord(x,G) divdes NCard(G).
  
** (7) if G has a primitive root, then NCard(groupPrimRoots(G)) = ephi(NCard(G)).
   Assume x is a primitive root of the group G.
   Thus, x is in G and ord(x,G) = NCard(G).
   Thus, gen(x) = G.  By 5d, groupPrimRoots(G) = {x**m for m in relprimes(NCard(G))}
   And the cardinality of this set is NCard(relprimes(NCard(G))) which is also known as
   ephi(NCard(G)).
** (8)  carprod(G,H) is not cyclic iff G and H are finite groups of size m and n, and gcd(m,n) = 1
  Let G and H be finite groups, of size m and n.
  Let K = carprod(G,H) have the product group structure.
  Note NCard(K) = m*n.
  When is K cyclic?
  Let e1 be the identity in G, and e2 the identity in K.
  Let e be the identify in K, so e = (e1,e2).
*** (1) If c is in K and 1<=l and m|l and n|l, then c**l == e.
  There are a in G and B in H with c = (a,b)
  Let r = Quo(l,m) and s = Quo(l,n).
  1<=r and l = m*r
  1<=s and l = n*s
  c**l = (a**l,b**l)
  a**m = e1, since ord(a,G) | m
  b**n = e2, since ord(b,H) | n
  a**l = a**(m*r) = (a**m)**r = e1**r = e1
  b**l = b**(n*s) = (b**n)**s = e2**s = e2
  Thus c**l = (e1,e2) = e.
*** (2) if c is in K, the c**lcm(m,n) = e
  1<=lcm(m,n), and m | lcm(m,n) and n | lcm(m,n)
  c**lcm(n,n) = e, from (1)
*** (3) If gcd(m,n) != 1 then K is NOT cyclic.
  Let d = gcd(m,n). Let l = lcm(m,n).
  (a) l*d = m*n, by the least common multiple theorem.
  (b) 1 < d, by assumption
  l < m*n, by (a) and (b)
  If c is in K,then ord(c,K) < NCard(K):
   c**l = e, by (2)
   ord(c,K) <= l, defn of order of group element.
   ord(c,K) < m*n, since l < m*n
   ord(c,K) < NCard(K), since NCard(K) = m*n.
  Thus, there is no element c in K such that ord(c,K) = NCard(K)
  Thus, K is not cyclic.
  
* -------------------------------------------------------------
* primitive roots
* -------------------------------------------------------------
* Primitive root defined with examples
 Ref: https://en.wikipedia.org/wiki/Multiplicative_group_of_integers_modulo_n
 We know that relprimes(n) is a group (under multiplication modulo n) for 1<=n.
 A generator of this group is called a primitive root modulo n.
 Theorem (Gauss) relprimes(n) is a cyclic group iff
  n = 2,4, p^k or 2*(p^k)  (for p an odd prime and 1<=k)
 Trivial cases:
 n = 2.  relprimes(2) = [1]. Primitive root = 1
 n = 4.  relprimes(4) = [1,3]. Primitive root = 3
 n = 3.  relprimes(3) = [1,2]. Primitive root = 2
 n = 5.  relprimes(5) = [1,2,3,4] primitive root =  2 or 3
 n = 6.  relprimes(6) = [1,5] primitive root = 5
 n = 7.  relprimes(7) = [1,2,3,4,5,6] primitive roots: [3, 5]
 n = 8.  relprimes(8) = [1,3,5,7]  NO PRIMITIVE ROOTS
 n = 9.  relprimes(9) = [1,2,4,5,7,8] primitive roots = 2,5
 n = 10. relprimes(10) =  [1, 3, 7, 9] primitive roots: [3, 7]
 n = 11. relprimes: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] primitive roots: [2, 6, 7, 8]
 n = 12. relprimes: [1, 5, 7, 11] no primitive roots
 n = 13. 13 has 4 primitive roots: [2, 6, 7, 11]
         14 has 2 primitive roots: [3, 5]
     15. relprimes: [1, 2, 4, 7, 8, 11, 13, 14] no prim. roots
     20 has 0 primitive roots: []
** code to get primitive roots
from numtheory1 import *
# relprimes,

def testpr(n,dbg=False):
 rp = relprimes(n)
 nrp = len(rp)
 if dbg: print('(%s) relprimes: %s' %(nrp,rp))
 numpr = 0
 primroots = []
 for k in rp:
  e = eltOrder(k,n)
  if e == nrp:
   if dbg: print('order of %s = %s (mod %s)  primitive root' %(k,e,n))
   numpr = numpr + 1
   primroots.append(k)
  else:
   if dbg: print('order of %s = %s (mod %s)' %(k,e,n))
 if dbg: print('%s has %s primitive roots: %s' %(n,numpr,primroots))
 return primroots
* relprimes(p) has a primitive root if p is a prime.
 Recall definition of relprimes(n), defined for 1<=n.
  relprimes(n) =  S(k, 1<=k<=n and  gcd(k,n) = 1).
  By this definition, relprimes(1) = {1}
  If 1 < n, then relprimes(n) = S(k, 1<=k<n and gcd(k,n) = 1).
  And thus, if 1<n we may consider relprimes(n) to be a subset of 'n',
  and may apply the mod-n arithmetic to it.  In this case,
  relprimes(n) is the set of multiplicatively invertible elements.
  and relprimes(n) is a group under mod-n multiplication.
 NOTE: some of the following may not make sense for n=1.
 However, it is useful to include relprimes(1), with cardinality 1
 so that ephi(1) = 1 is defined.

 Let G = relprimes(n). (G,NProd(n),1) is a finite group.
   For a in G and k in N, a**k may be intepreted as NPower(n)(a,k)
 Let ord(a,n) = ord(a,G).
 Let primRootQ(r,n) = GroupPrimRootQ(r,G)
 Let primRoots(n) = GroupPrimRoots(G).

** (1) If a is in G, then there is 1<=u with a**u == 1 (mod n).
   Since G is a finite group
** (1a) 1<=a and 1<=n and gcd(a,n) = 1, then there is 1<=u with a**u == 1 (mod n).
   This is just a rephrasing of (1), p
   a  = n*Quo(a,n) + Rem(a,n),  0<=Rem(a,n) < n
*** Case Rem(a,n) = 0  Take u = 1
    Thus n | a.
    Thus gcd(a,n) = n, so n = 1.
    1 == 0 (mod n), since n | (1 - 0) (i.e. 1 | 1)
    n | (a - 0), So a == 0 (mod n)
    Thus, a == 1 (mod n)
    a**1 = a.
    Thus a**1 == 1 (mod n)
    So take u = 1.
*** Case Rem(a,n) != 0
   (d|a and d|n)  Iff  (d|Rem(a,n) and d|n)
   So gcd(a,n) = gcd(R(a,n),n)
   Let b = Rem(a,n). 
   Thus, 1 <= b < n, and gcd(b,n) = 1 
   b is in G.
   G is a finite group.
   Set u = ord(b,G).
   Then 1<=u and b**u == 1 (mod n)
     More exactly, Let Npow(n) be the m
   But b**u == a**u (mod n)

** (2) If a is in G, properties of ord(a,n)
   1 <= ord(a,n) and a**ord(a,n) = 1 (mod n) 
   if 1<=k and a**k = 1 (mod n), then ord(a,n) | k.
** (4) If a is in G, then ord(a,n) divides NCard(G) = ephi(n)
 The result follows from (6) of 'order of finite group element'.
** (5) eltsOfOrder(d,n)
  1<=n. 
  eltsOfOrder(d,n) = {a in G and ord(a,n) = d}.
  If eltsOfOrder(d,n) is not empty, then d divides ephi(n).
  Even if d divides ephi(n), it MAY be true that eltsOfOrder(d,n) is empty.
  Example: n = 12. relprimes(12) = {1,5,7,11}, ephi(12) = 4, 4|4, eltsOfOrder(4,12) = empty set
    [(k,eltOrder(k,12)) for k in relprimes(12)]
       [(1, 1), (5, 2), (7, 2), (11, 2)]  
    So eltsOfOrder(1,12) = {1},  eltsOfOrder(2,12) = {5,7,11}. 
    eltsOfOrder(d,12) = {} if d!=1 and d!=2.
** (6) eltsOfOrderF(n)
  eltsOfOrderF(n) is a function from divisors(ephi(n)) to subsets of relprimes(n)
  defined by formula eltsOfOrderF(n)(d) = eltsOfOrder(d,n).
  If d1!=d2 are divisors of ephi(n), then eltsOfOrder(n,d1) and eltsOfOrder(n,d2)
  are disjoint.
  Also, if a is in relprimes(n), then eltOrder(a,n) divides ephi(n)
  and a is in eltsOfOrder(n,eltOrder(a,n))

  So relprimes(n) = union(range(eltsOfOrderF(n)))
  Examples: 
   n=7. relprimes(7) = {1,2,3,4,5,6}, ephi(7) = 6. divisors(ephi(7)) = {1,2,3,6}
    eltsOfOrderF(7) = {1: [1], 2: [6], 3: [2, 4], 6: [3, 5]}
   n=12. relprimes(12) = {1,5,7,11}. ephi(12) = 4. divisors(ephi(12)) = {1,2,4}
    eltsOfOrderF(12) = {1: [1], 2: [5, 7, 11], 4: []}
** (7) If 1<=n, define function eltsOfOrderSizeF(n) : divisors(ephi(n)) ->  N
  Recall ephi(n) = NCard(relprimes(n)).
  Function from divisors(ephi(n)) to N defined by formula
  val(eltsOfOrderSizeF(n),d) = NCard(eltsOfOrder(d,n)).
  Example: eltsOfOrderSizeF(12)  {1: 1, 2: 3, 4: 0}
** (8) If 1<=n, then divisorsum(eltsOfOrderSizeF(n), ephi(n)) = ephi(n)
  This is because range(eltsOfOrderF(n)) is a disjoint cover of relprimes(n).
   [It is not a partition, since it may contain the empty set 
     e.g. val(eltsOfOrderF(12),4) = empty]
** (9) If n is prime, then divisorsum(eltsOfOrderSizeF(n), ephi(n)) = n-1
  Since ephi(n) = n-1.
** (10a) if n is a prime and d | ephi(n), then NCard(roots(X**d -1)) = d.
    This is proved as a corollary to Fermat's little theorem.
    The idea is that there is a polynomial g so that (X**(n-1) - 1) = (X**d - 1)*g.
       (the coefficients are in NRing(n))
    Fermat's little theorem says there are n-1 roots (i.e. {1,...,n-1}) of
    X**(n-1) - 1.  Thus there are d roots of (X**d - 1) (and (n-1)-d roots of g).
** (10) if n is a prime and d | ephi(n) and ord(a,n) = d, then roots(X**d -1) = gen(a)
  Assumptions imply 1<=d. 
  Implicitly assume a in relprimes(n).
  Let f = X**d - 1 (polynomial with mod n arithmetic).
  H = roots(f) = {x, 0 <= x < n and  x**d = 1 (mod n)}
    If fact x in H implies 1<=x.
  NCard(H) = d, by 10a.
*** H is a subgroup of relprimes(n).
   This would be true for any abelian group G  with H = {x in G: x*d =1} and d|NCard(G).
   If b and c are in H, then 
    b**d = 1 and c**d = 1 (mod n)
    (b*c)**d = (b**d)*(c**d) = 1*1 = 1 (mod n).
    So b*c is in H.
   1**d = 1. So 1 is in H
   if b is in H and c in relprimes(n) is the inverse of b, then
    b**d = 1 and b*c = 1 (mod n) 
    (b*c)**d = 1**d = 1.
    (b*c)**d = (b**d)*(c**d) = 1 * (c**d) = c**d.  [since multiplication is abelian]
    So c**d = 1. Thus c is in H.
*** a is in H
  a**d = 1, since ord(a,n) = d
  a is in H.
*** gen(a) is a subset of H
  if x is in gen(a), then there is 1<=k<=d with x = a**k.
   a**k is in H, since H is a group.
   x is in H.
  Thus, gen(a) is a subset of H.
*** NCard(gen(a)) = ord(a,n) = d = NCard(H).
***  Thus, gen(a) = H.
** (11) If n is a prime and d | ephi(n), then NCard(eltsOfOrder(d,n)) <=  ephi(d)
  Assume n is a prime.
  Assume d | ephi(n)
  Let H = roots of X**d - 1 in Nring(n).
  Let E = eltsOfOrder(d,n).
  To prove: NCard(E) <= ephi(d)
*** Case i: If E is empty set, then NCard(E) <= ephi(d)
   Thus, NCard(E) = 0.
   0 <= ephi(d)
   Thus NCard(E) <=  ephi(d)
*** Case ii: If E is not empty, then NCard(E) <= ephi(d)
     Choose a in E
     Let K = {b, b in relprimes(n) and gen(b) = gen(a)}
**** If a is in E, then H = gen(a)
    a is in relprimes(n) and ord(a,n) = d.
    H = gen(a), by (10)
**** (#) if b is in E, then H = gen(b) 
    b is in relprimes(n) and ord(b,n) = d.
    H = gen(b), by (10)
**** E is a subset of K
    Assume b is in E: 
     H = gen(b), by (#).
     b in gen(a), since H = gen(a).
     gen(b) = gen(a), since both are equal to H.
     Thus b is in K.
**** K is a subset of E
    Assume b is in K:
     b in relprimes(n) and gen(b) = gen(a).
     ord(b,n) = NCard(gen(b)), by 5a1 of 'order of finite group element' above.
       = NCard(gen(a)), since gen(b) = gen(a)
       = ord(a,n), by 5a1 of 'order of finite group element' above.
       = d, since a is in E.
     Thus b is in E.
**** E = K
    Since each is a subset of the other
**** NCard(E) <=  ephi(d)
   NCard(E) = NCard(K)
    = ephi(ord(a,n))   By section (5d) of section 'order of finite group element' above
    = ephi(d)
   So, in particular, NCard(E) <=  ephi(d).
*** NCard(E) <= ephi(d)
   Case i and ii together show that always NCard(E) <=  ephi(d).
** (12) If 1<n, then divisorsum(ephi,n-1) = n-1.
   This is Gauss's theorem applied to n-1.
** (13) if n is a prime, then divisorsum(ephi,n-1) = n-1.
  Since 1<n.
** (14) if D is finite set, f:D->R* and g:D->R* and sum(f) = sum(g) and A(i,f(i)<=g(i)), then f=g
   i.e., A(i, f(i) = g(i)).

   Here, R* is the set of non-negative real numbers.
   sum(f) = f(D0) + ... f(Dm) where D0,...,DM is some enumeration of D.

   consider h = g-f. Then g:D->R and sum(h) = sum(g)-sum(f) = 0.
   And also A(i,0<=h(i)).  
   Suppose k in D and 0 < h(k)
    Then 0 < h(k) <= sum(h) = 0. So 0 < 0, which is false.
   Thus A(i, 0 = h(i) = g(i) - f(i)) QED
** (15) if n is a prime and d divides n-1, then NCard(eltsOfOrder(d,n)) = ephi(d).
  Let m = NCard(relprimes(n)), let D = divisors(m).
  Let sum(h) = divisorsum(h,m) for a function h defined on D.
  m = ephi(n) = n-1 since n is prime.
  Let f = eltsOfOrderSizeF(n), so f(d) = NCard(eltsOfOrder(d,n))  for d in D.
  Let g be the function from D to N defined by g(d) = ephi(d).
  By (9), sum(f) = n-1 
  By (12), sum(g) = n-1
  By (11), for all d in D, f(d) <= g(d).
  D is finite.
  By (14), A(d in D, f(d) = g(d))
  QED.
** (16) if n is a prime and d divides n-1, then roots(X^d - 1) is cyclic.
 Assume: n is a prime
 Assume: d | n-1.
 Let E = eltsOfOrder(d,n)
  By (15), NCard(E) = ephi(d). 
  0 < ephi(d) since 1<=d.
  0 < NCard(E)
  E is not empty.
 Thus, there is a in E.
  Thus a is in relprimes(n) and ord(a,n) = d. 
  By (10), roots(X^d - 1) = gen(a).
  gen(a) is cyclic.
  roots(X^d - 1)
 QED
** (17) if n is a prime, then relprimes(n) is a cyclic group.
  Proof: 1<n.
  relprimes(n) = {1,...,n-1}.
  0 < n-1.
  So n-1 divides n-1.  
  By (16), roots(X^(n-1) - 1) is a cyclic group.
** (17a) If n is a prime, then there is a primitive root x for n.
   From (17) and definition of primRootQ
** (18a) if n is prime and primRootQ(x,n), then primRoots(n) = {x**k (mod n), for k in relprimes(n)}
  by 5d of the group result
** (18) if n is a prime, then NCard(primRoots(n)) = ephi(ephi(n))
  By 17a, primRoots(n) is not empty.
  Thus NCard(primroots(n)) = ephi(NCard(G))  (by (7) of groupPrimRootQ section above).
  And NCard(G) = ephi(n), since G = relprimes(n) and also definition of ephi.
  So NCard(primroots(n)) = ephi(ephi(n)).
* CODE: primitive roots 
  from numtheory1 import primRoots, primRootQ

** primRootQ(14,29) example:
  primRootQ(14,29) == True
  primRootQ(14,29**2) == False
  primRootQ(14+29,29**2) == True
  primRootQ(14+29,29**3) == True
    Theory says primRootQ(14+29,29**k) == True for 3<=k

* if 1 < n and relprimes(n) is cyclic and gcd(2,n) = 1, then relprimes(2*n) is cyclic
 Proof:
 Since gcd(2,n) = 1, relprimes(2*n) is isomorphic to group product
   relprimes(2) X relprimes(n)  (See Proof of 'ephi is multiplicative', under
   Chinese remainder theorem).
 But relprimes(2) = {1}.  So relprimes(2*n) is isomorphic to relprimes(n).
 So relprimes(2*n) is cyclic.
* relprimes(2) and relprimes(4) are cyclic
  relprimes(2) = {1}
  relprimes(4) = {1,3} and 3**2 = 1 (mod 4), so relprimes(4) = gen(3)
* relprimes(p**k) and ephi(p**k) for p a prime and 1 <= k
  relprimes(p**k) = {p*i + j, with 0 <= i < p**(k-1), and 1 <= j < p}
  So ephi(p**k) = (p**(k-1)) * (p-1)
  Note: ephi(p**(k+1)) = p * ephi(p**k)
  if k < j, then relprimes(p**k) is a subset of relprimes(p**j)
* if 3<=n, then ephi(n) is an even number 
**  (1) Case n a power of 2: n = 2**k.  Since 3<=n, then 2<=k.
  ephi(n) = ephi(2**k) = 2**(k-1).  
  2 | 2**(k-1), since 1<=k-1
   2 | ephi(n)
** Case n not a power of 2. Then there are p, k, and m such that
     p is an odd prime,
     1<=k, 1<=m,  n = (p**k)*m and gcd(p,m) = 1.
   Thus gcd(p**k,m) = 1.
   Since ephi is multiplicative,
     ephi(n) = ephi((p**k)*m) = ephi(p**k)*ephi(m)
   ephi(p**k) = (p**(k-1)) * (p-1)
   (p-1) | ephi(p**k)
   so (p-1) | ephi(n).  
   2 | (p-1) since p is odd
   2 | ephi(n)
* If 3<=k, then relprimes(2**k) is NOT cyclic.
 Let G = relprimes(2**k)
 if 1<=k, then  G = {2*i + 1, with 0 <= i < 2**(k-1)}
 ephi(2**k) = 2**(k-1)
 Also, G = {x: 1 <= x <= 2**k and x is odd}
** (1) if 3<=k and x is odd, then x**(2**(k-2)) = (1 mod 2**k)
  See below for two proofs of (1)
** if x is in G, then gen(x) != G.
  Suppose x is in G.
  Thus x is odd.
  order(x,2**k) is the smallest power of x which is 1 mod(2**k).
  order(x,2**k) <= 2**(k-2), since by (1), the power (2**(k-2)) of x is 1.
  2**(k-2) < 2**(k-1)
  order(x,2**k) < 2**(k-1), from previous 2 statements
  order(x,2**k) < NCard(G), since 2**(k-1) = NCard(G)
  NCard(gen(x)) = order(x,2**k) [ there are order(x,G) elements in gen(x) ]
  gen(x) != G
** G is not a cyclical group
   By definition of cyclical group
** (1) is proved by induction on k.
  Assume x is odd. 
  To show: if 3<=k, then x**(2**(k-2)) = 1 (mod 2**k) 
*** Case x = 1
   Assume 3 <= k.
   Let j = k-2,  n = 2*j
   1 <= j
   2 <= n
   x**(2**(k-2)) = 1**n 
    = 1 
    = 1 (mod 2**k), since 1 < 2**k
*** Case 1<x
**** Case k = 3:
  2**k = 8.
  k-2 = 1
  2**(k-2) = 2**1 = 2
  Choose j with x = 2*j + 1, since x is odd.
  j != 0,  since 1 < x
  x**2 = (2*j)*(2*j) + 2*(2*j) + 1*1
       = 4*j*j + 4*j + 1 
       = 4*(j*(j+1)) + 1.
  j*(j+1) is even, since either j or j+1 is even
  Choose i so that j*(j+1) = 2*i
  x**2 = 4*(2*i) + 1 
     = 8*i + 1 = 1 (mod 8).
  x**2 = 1 (mod 2**k)
**** Inductive step
  Inductive assumption for k: 
   (a)  x**(2**(k-2)) = 1 (mod 2**k)
  To prove the k+1 equation: x**(2**((k+1)-2) = 1 (mod 2**(k+1))
   Let lhs = x**(2**((k+1)-2)
   To prove: lhs = 1 (mod 2**(k+1))
   (k+1) - 2 = (k-2) + 1
***** lhs = (x**(2**(k-2)))**2
   2**((k+1)-2) = 2**((k-2)+1) 
      = (2**(k-2))*(2**1) 
      = (2**(k-2))*2
   lhs = x**((2**(k-2))*2) 
       = (x**(2**(k-2)))**2   law of exponents: x**(i*j) = (x**i)**j 
***** Choose m with x**(2**(k-2)) = (2**k)*m + 1  
    by the inductive assumption
***** lhs = ((2**k)*m)**2 + 2*((2**k)*m)*1 + 1 
   1<=m since 1<x
   lhs = ((2**k)*m + 1)**2 
       = ((2**k)*m)**2 + 2*((2**k)*m)*1 + 1 
***** ((2**k)*m)**2  = 0 (mod 2**(k+1)) 
   ((2**k)*m)**2 = ((2**k)**2) * (m**2)  [ (a*b)**2 = (a**2) * (b**2) ]
   (2**k)**2 = 2**(k*2)  [ (a**i)**j = a**(i*j) ]
       = 2**((k+1) + (k-1)) [ k*2 = (k + k) = ((k+1) + (k-1)) ]
       = (2**(k+1)) * (2**(k-1))  [ a**(i+j) = (a**i) * (a**j) ]
   ((2**k)*m)**2 = ((2**(k+1)) * (2**(k-1))) * (m**2) = 
   ((2**k)*m)**2 = 0 (mod 2**(k+1))
***** 2*((2**k)*m)*1 = 0 (mod 2**(k+1))
   2*((2**k)*m)*1 = 2*((2**k)*m) 
       = (2*(2**k)*m)
       = ((2**1)*(2**k))*m 
       = (2**(1+k))*m = (2**(k+1))*m
    So  2*((2**k)*m)*1 = 0 (mod 2**(k+1))
***** lhs = 1 (mod 2**(k+1))
    So lhs = 0 + 0 + 1 (mod 2**(k+1)) by previous 2 steps
    This completes the proof for k+1.
**** By induction, the formula holds for all 3<=k.
  QED.
** (1) alternate proof
   Suppose a is odd and 1<=n, then a**(2**n) = 1 (mod 2**(n+2))
   a = 2*q + 1, where q = Rem(a,2),  since a is odd.
*** case n = 1
    2**(n+2) = 2**3 = 8
    2**n = 2**1 = 2. 
    a**2 = (2*q + 1)**2
         = 4*(q**q) + 4*q + 1 = 4*(q*(q+1)) + 1
    q*(q+1) is even, since either q or q+1 is even And a
    q*(q+1) = 2*j where j = Quo(q*(q+1),2)
    a**2 = 4*(2*j) + 1 
      = 8*j + 1
      = 1 (mod 8)  8 = 2**(1+2) 
      = 1 (mod 2**(n+2))
*** Inductive step
   Inductive hypothesis: Choose j so that
   a**(2**n) = 1 + j*(2**(n+2))
   Let lhs = a**(2**(n+1)). 
   To show lhs = 1+u*(2**(n+3)) for some u
    Let C = 2**(n+3)
    To show: lhs = u*C + 1 for some u
    2**(n+1) = (2**n)*2 
   lhs = a**((2**n)*2)
       = (a**(2**n))**2  [ a**(i*j) = (a**i)**j ]
       = (1 + j*(2**(n+2)))**2 , inductive hypothesis
       = (j*(2**(n+2)))**2 + 2*(j*(2**(n+2)))*1 + 1**2
       = (j**2)*((2**(n+2))**2) + 2*j*(2**(n+2))) + 1 =  [ (x*y)**2 = (x**2)*(y**2) ]
               A                +        B        + 1
          2*(2**(n+2)) = 2**(n+3) = C
          B = j*C
         (2**(n+2))**2 = (2**(n+2)) * (2**(n+2))  [ x**2 = x*x ]
            = 2**((n+2) + (n+2))  [ (x**I) * (x**J) = x**(I + J) ]
            = 2**((n+3)+(n+1))  (n+2) + (n+2) = (n+3) + (n+1) 
	    = (2**(n+1))*C  [ x**(I + J) = (x**J)(x**I) ]
          A = (j**2)*(2**(n+1))*C  
            = v*C, where v = (j**2)*(2**(n+1))
    lhs = v*C + j*C + 1
        = (v + j)*C + 1 = u*C + 1, where u = v + j.
*** The result follows for 1<=n by induction on n.
* if m > 2 and n > 2, and gcd(m,n) = 1, then relprimes(m*n) has no primitive element.
  K = relprimes(m*n), G = relprimes(m), H = relprimes(n).
  group K is isomorphic to carprod(G,H), by Chinese remainder theorem, since gcd(m,n) = 1
  NCard(G) = ephi(m) and NCard(H) = ephi(n).
  2 | ephi(m), since 3<=m, by theorem above
  2 | ephi(n), since 3<=n, by theorem above
  2 | NCard(G)
  2 | NCard(H)
  2 <= gcd(NCard(G),NCard(H)), since 2 divides both NCard(G) and NCard(H)
  gcd(NCard(G),NCard(H)) != 1, definition of gcd
  carprod(G,H) is not cyclic (theorem 8 of 'finite group element...' above)
  K is not cyclic, since K isomorphic to carprod(G,H).
  i.e., K has no primitive element.
* Binomial theorem
** Factorial
  0! = 1,  if 0 <= n, (n+1)! = (n+1)*n!
  n! = NCard(Perm(n))  (number of permutations of (the finite set) n.
  1! = 1
  2! = 2
** C(n,k) 
  C(n,k) = n!/k!*(n-k)!   (0<=k<=n)
  C(0,0) = 1
  C(1,0) = 1,
  C(1,1) = 1
  C(n,0) = 1
  C(n,1) = n
  C(n,2) = (n*(n-1))/2
  C(n,n) = 1
** Binomial theorem:
  if 1 <= n, then (a+b)**n = sum(C(n,k)*(a**(n-k))*(b**k), 0<=k<=n)
  We need to have a**0 = 1 for any a, even a = 0!
  a and b need to be in a commutative ring.
** If 2<=n, and a,b in N, then (a+b)**n = a**n + n*(a**(n-1))*b (mod b**2)
   
** if 3<=n, and a,b in N, then (a+b)**n = a**n + n*(a**(n-1))*(b**1) + C(n,2)*(a**(n-2))*(b**2) + (mod b**3)
* if p is an odd prime and 1<=k, then p**k has a primitive root.
   case k=1 is proved above, since p is a prime.
NOTE: Another proof is given under (18) of a section below
  relprimes(p**2) = {p*i + j, with 0 <= i < p**(2-1), and 1 <= j < p}
                  = {p*i + j, with 0 <= i < p, and 1 <= j < p}
  relprimes(p**3) = {p*i + j, with 0 <= i < p**2, and 1 <= j < p}
  
  relprimes(3**2) = {3*i + j, with 0 <= i < 3, and 1 <= j < 3}
                    { 3*0 + 1, 3*0 + 2, 3*1 + 1, 3*1 + 2, 3*2 + 1, 3*2 + 3}
                    {1,2,4,5,7,8}
  Let p2 = p**2 
  Suppose a is in relprimes(p2). 
   Then  1 <= a < p2 , and gcd(a,p2) = 1.
   Let d = ord(a,p2).  So a**d = 1 (mod p2), and 1<=d and
   1<=k<d implies a**k != 1 (mod p2).
   'a' is a primitive root of p2 if d = p*(p-1).
  Notations:
    a|b for a divides b (in N)
    PR(r,n) r is a primitive root of n.
  ephi(p2) = ( p**(2-1)) * (p-1) = p*(p-1)
** (0) if p is a prime, then there is r so that PR(r,p)
  Proved above
** (1a) if p is prime and 1<=k and PR(r,p**k) then ephi(p**k) | ord(r,p**(k+1)) | ephi(p**(k+1))
   Let pk = p**k, pk1 = p**(k+1).
   By assumption, r in relprimes(pk).
   relprimes(pk) is a subset of relprimes(pk1).
   r in relprimes(pk1).
   Let e = ephi(pk), e1 = ephi(pk1)
   Let o = ord(r,pk), o1 = ord(r,pk1)
   o = e, since PR(r,pk).
   o1 | e1 since r in relprimes(pk1)
   To show: e | o1 
    r**e = 1 (mod pk), since r in relprimes(pk)
    r**o1 = 1 (mod pk1)
    r**o1 = 1 + m1*pk1  for some m1
    pk1 = pk*p
    r**o1 = 1 + (m1*p)*pk
    r**o1 = 1 (mod pk)
    o | o1, since PR(r,pk)
    e | o1, since e = o
** (1b) if p is prime and a | b | p*a, then b = a or b = p*a
    b = a*q
    p*a = b*r
        = (a*q)*r
        = (q*r)*a
    p = q*r
    Either (q = 1, r = p) OR (q = p, r = 1)  since p is prime
    If q = 1, then b = a
    if r = 1, then b = p*a
** (1c) if p is prime and 1<=k and PR(r,p**k), then ord(r,p**(k+1)) = ephi(p**k) or = ephi(p**(k+1))
   Let pk = p**k, pk1 = p**(k+1).
   By assumption, r in relprimes(pk).
   relprimes(pk) is a subset of relprimes(pk1).
   r in relprimes(pk1).
   Let e = ephi(pk), e1 = ephi(pk1)
   Let o = ord(r,pk), o1 = ord(r,pk1)
   e | o1 | e1, by (1a)
   e1 = p*e, since p a prime
   e | o1 | p*e, since e1 = p*e
   o1 = e or o1 = p*e, by (1b)

** (1d) if p is a prime and PR(r,p), then ord(r,p2) = (p-1) or = p*(p-1)
   ephi(p**1) | ord(r,p2) | ephi(p2) by (1a) with k = 1
   ephi(p**1) = p-1
   ephi(p2) = p*(p-1)
   (p-1) | ord(r,p2) | p*(p-1).
   ord(r,p2) = (p-1) or ord(r,p2) = p*(p-1), by (1b) with a = p-1 and b = ord(r,p2)
** (2) if p is a prime and a|e and e|a*p, then e = a or e = a*p [duplicate of (1b)]
   Proof: Restatement of (1b)
** (3) if p is a prime and PR(r,p) and r**(p-1) != 1 (mod p2), then PR(r,p2).
   r is in relprimes(p), since PR(r,p)
   relprimes(p) is subset of relprimes(p2)
   r is in relprimes(p2)
   Let o1 = ord(r,p2)
   By (1d), either o1 = (p-1) or o1 = p*(p-1).
   If o1 = (p-1), then r**(p-1) = 1 (mod p2), contrary to assumption.
   Thus, o1 = p*(p-1), which is the size of relprimes(p2). 
   Thus, r is a primitive root for p2
** (4) if p is a prime and r is in relprimes(p), then r+p is in relprimes(p2)
   To show 1 <= (r+p) < p*p and gcd(r+p,p*p) = 1
   1 <= r < r+p.
   r + p < p + p, since r < p
   r + p < 2*p, since p+p = 2*p
         <= p*p  (since 2<=p)

   Let d divide r+p and p*p.  
    d divides p, since p is prime
    d divides r, since d | r+p and d | p
    d = 1 or d = p
    p does not divide r, since p is prime and 1<=r<p
    d = 1.
   Thus gcd(r+p,p*p) = max(divisors(r+p,p*p)) = max({1}) = 1.
** (5) if p an odd prime, and a,b in N, then (a+b)**(p-1) = (a**(p-1)) + (p-1)*(a**(p-2))*b (mod p2)
  Apply special case of binomial theorem in N (i.e., a,b are in N)
     If 2<=n, then (a+b)**n = a**n + n*(a**(n-1))*b (mod b**2)
   with n = p-1  (Note since p is an odd prime, 2<=(p-1))
** (6) if p is odd prime and PR(r,p) and r**(p-1) = 1 (mod p2), then (r+p)**(p-1) != 1 (mod p2).
   1<=r<p.  
   (r+p)**(p-1) 
     = (r**(p-1)) + (p-1)*(r**(p-2))*p (mod p2)     , by (5) with a = r and b = p
     = 1 + (p-1)*(r**(p-2))*p (mod p2)              , by assumption
     = 1 + p*(r**(p-2))*p - 1*(r**(p-2))*p (mod p2) , by distributivity
     = 1 - (r**(p-2))*p (mod p2)                    , since p*(r**(p-2))*p = 0 (mod p2)
   r is in relprimes(p) , since PR(r,p)
   Thus, gcd(r**(p-2),p) = 1. 
   So p does not divide r**(p-2). 
   p2 does not divide (r**(p-2))*p.
   So (- (r**(p-2))*p)  != 0 (mod p2).
   Thus, 1 - (r**(p-2))*p != 1 (mod p2).
   Thus, (r+p)**(p-1) != 1 (mod p2).
** (7) if p is odd prime and PR(r,p) and NOT PR(r,p2), then PR(r+p,p2)
   r is in relprimes(p), by definition of PR(r,p)
   r is in relprimes(p2), since relprimes(p) is subset of relprimes(p2)
   r+p is in relprimes(p2), by (4)
   Let e = ord(r,p2). 
   e = p-1 OR e = p*(p-1), by (1d).
   If e = p*(p-1), then PR(r,p2), which we are assuming is not the case.
   e = (p-1).
   r**(p-1) = 1 (mod p2), by (3) since Not PR(r,p2).
   (r+p)**(p-1) != 1 (mod p2) , by (6) 
   Let f = ord(r+p,p2).
   We must show f = p*(p-1).
*** if f = (p-1) then (r+p)**(p-1) = 1 (mod p2)
    f = (p-1)  Assume
    (r+p)**f = (r+p)**(p-1)
    (r+p)**f = 1 (mod p2) (defn. of ord). 
    (r+p)**(p-1) = 1 (mod p2)
*** f != (p-1)
    Since we have above shown (r+p)**(p-1) != 1 (mod p2)
*** f | p*(p-1)
   By defn. of ord, f is the smallest positive integer k such that (r+p)**k = 1 (mod p2).
   f | p*(p-1), since p*(p-1) = NCard(relprimes(p2)).
*** (p-1) | f
    (r+p) = r (mod p)
    (r+p)**(p-1) = r**(p-1) (mod p)  Since 1<p.
    r**f = (r+p)**f 
    r**(p-1) = 1 (mod p) , since ord(r,p) = (p-1).
    (r+p)**(p-1) = 1 (mod p)
    (r+p)**f = 1 (mod p2) , since f = ord(r+p,p2)
    (r+p)**f = 1 (mod p)  , since p divides p2)
    r**f = 1 (mod p) , since r**f = (r+p)**f (mod p)
    ord(r,p) | f , by property of order in group
    (p-1) | f, since ord(r,p) = p-1
*** PR(r+p,p2):
    f = (p-1) or f = p*(p-1), by (1b) since (p-1) | f | p*(p-1)
    f = p*(p-1), since f != p-1
    Thus (r+p) is primitive element for p2.
** (8) if p is odd prime and PR(r,p), then PR(r,p2) or PR(r+p,p2).
   Immediate from (7)
** (9) if p is an odd prime, then there exists s so that PR(s,p2)
   We know that p has a primitive root r.  Thus p2 has a primitive root, by (8)

** (10a) if p is prime and 1<=k and PR(r,p**k) and r**ephi(p**k) != 1 (mod p**(k+1)), then PR(r,p**(k+1))
   Assume:
    p a prime
    1<=k
    Let pk = p**k, pk1 = p**(k+1).
    PR(r,pk)
    r**ephi(pk) != 1 (mod pk1)
   ord(r,pk1) = ephi(pk) OR ord(r,pk1) = ephi(pk1), by (1c)
   ephi(pk) < ephi(pk1)
   NCard(relprimes(pk1)) = ephi(pk1)
   r**ord(r,pk1) = 1 (mod pk1), by definition of order.
   if ord(r,pk1) = ephi(pk), then r**ephi(pk) = 1 (mod pk1)
   Thus ord(r,pk1) != ephi(pk)
   Thus ord(r,pk1) = ephi(pk1).
   Thus, PR(r,pk1)
** TODO (10b) if p is an odd prime and PR(r,p**2), then PR(r,p**3).
   p is odd prime.
   2 < p
   Let p2 = p**2, p3 = p**3, p1 = p**1 = p.
   Let e1 = ephi(p1), e2 = ephi(p2), e3 = ephi(p3)  
   PR(r,p2)
   r is in relprimes(p2), by PR(r,p2)
   r is in relprimes(p3), since relprimes(p2) is a subset of relprimes(p3).
   Let(o2) = ord(r,p2)
   Let(o3) = ord(r,p3)
   o2 = e2, by PR(r,p2)
   To show: o3 = e3.
   e1 = p-1
   e2 = p*(p-1)  = e1*p
   e3 = p2*(p-1) = e2*p
   e1 < e2, since 2 < p by assumption
 ?  r**e1 != 1 (mod p2), since o2 = e2.
   Suppose we can show r**e2 != 1 (mod p3):
  
** (10) if p is an odd prime and PR(r,p2), then A(k, 2<=k implies PR(r,p**k))
   Proof by induction on k>=2. 
   By assumption, 1<=r<p2 and gcd(r,p2) = 1. 
   r is in relprimes(p**j) for all j with 2<=j

   Let e = ord(r,p2). So e is smallest positive integer such that r**e = 1 (mod p2)
   By the PR(r,p2) assumption, e = Card(relprimes(p2)) = ephi(p2) = p*(p-1).
   Since p-1 < p*(p-1), r**(p-1) != 1 (mod p2).
   Choose 2<=k.
   Let pk0 = p**(k-1), pk = p**k, pk1 = p**(k+1)
   Let p0 = p-1.
   Let e = ephi(pk), e1 = ephi(pk1), e0 = ephi(pk0)
   Let o = ord(r,pk), o1 = ord(r,pk1)

*** Inductive hypothesis: 2<=k and PR(r,pk). To show PR(r,pk1).
   Assume:
    2<=k
    PR(r,pk).
   By (10a), it suffices 
   TO SHOW: r**ephi(pk) != 1 (mod pk1)
   ephi(pk) = (p**(k-1))*p0 = pk0*p0. So we must show
      r**(pk0*p0) != 1 (mod pk1)
   o = e, since PR(r,pk)
   e = e0*p,  e1 = p*e.
   e0 = (p**(k-2))*p0.
**** (X) r**((p**(k-2))*p0) != 1 (mod pk)
   e0 < e
   r in relprimes(pk) since 2<=k.
   r**e0 != 1 (mod pk) , since PR(r,pk) and e0 < o
   r**((p**(k-2))*p0) != 1 (mod pk)
**** TODO r**(pk0*p0) = 1 (mod pk)
     e = pk0*p0.
     o = pk0*p0
     r**(pk0*p0) = 1 (mod pk)
**** TODO To prove for k+1:  r**((p**((k+1)-2))*p0) != 1 (mod pk1).
     i.e., r**(pk0*p0) != 1 (mod pk1)
**** if 2 < k, then r**((p**(k-2))*p0) = 1 (mod pk0)
   2 <= (k-1)
   r is in relprimes(p2), by assumption
   relprimes(p2) is subset of relprimes(pk0), since 2 <= k-1
   r is in relprimes(pk0)
   r**NCard(relprimes(pk0)) = 1 (mod pk0) (Euler's generalization of Fermat's little theorem)
   NCard(relprimes(pk0)) = ephi(pk0)
   ephi(pk0) = (p**(k-2))*p0
   r**((p**(k-2))*p0) = 1 (mod pk0)
**** if 2 = k, then r**((p**(k-2))*p0) = 1 (mod pk0)
   pk0 = p**(2-1) = p**1 = p
   (p**(k-2))*p0 = (p**0)*p0 = 1*p0 = p-1
   Is r**p0 = 1 (mod p)  IFF  r**((p**(k-2))*p0) = 1 (mod pk0)
   r in relprimes(p2), since PR(r,p2)
   gcd(p,r) = 1
   r**p0 = 1 (mod p) [Fermat's little theorem]
   r**((p**(k-2))*p0) = 1 (mod pk0)
**** r**((p**(k-2))*p0) = 1 (mod pk0)
  2<=k by assumption. So 2 < k or 2 = k.
  previous two cases together show the conclusion.
**** Choose a with gcd(p,a) = 1 and (eqn) r**((p**(k-2))*p0) = 1 + a*pk0 
   Choose a with r**((p**(k-2))*p0) = 1 + a*pk0, since r**((p**(k-2))*p0) = 1 (mod pk0)
   Assert: p does not divide a.
    Assume the contrary, that p | a. There is b, with a = p*b.
    Then  r**((p**(k-2))*p0) = 1 + p*b*pk0 = 1+b*pk = 1 (mod pk), 
     which is contrary to a previous statement (X) 
**** Let lhs = r**((p**(k-2))*p0) and rhs = 1 + a*pk0. So, lhs = rhs
**** lhs**p = r**(pk0*p0)
    lhs**p = (r**((p**(k-2))*p0))**p 
      = r**((p**(k-2))*p0)*p, [ (x**i)**j = x**(i*j) ]
      = r**((p**(k-2))*p*p0), associativity/commutativity of multiplication
      = r**((p**(k-1))*p0)
      = r**(pk0*p0), defn. of pk0
**** (Z) if 2<=k and 3<=p, then (k+1) <= (k-1)*p 
     Induction on k
      Case k = 2.
        (2+1) <= (2-1)*p IFF 3 <= p
      induction
       Assume  (k+1) <= (k-1)*p
         To show: ((k+1)+1) <= ((k+1)-1)*p
         (k+1)+1 <= (k-1)*p + 1 
                 <= (k-1)*p + p since 1<=p
                  = k*p
                  = ((k+1)-1)*p
**** if 2<=k and 2<=j, then k <= (k-1)*j
  Induction on k
   k = 2:   2 <= (2-1)*j = 1*j = j
   Assume k <= (k-1)*j
   to prove (k+1) <= ((k+1)-1)*j 
        k+1 <= (k-1)*j + 1 <=? k*j
            0 <= k-1 < k
            0 < j
            (k-1)*j < k*j
            (k-1)*j + 1 <= k*j
**** (Y) if 2<=k and 2<=j and 1<=p, then (p**(k+1)) | p*(p**((k-1)*j)) 
    By previous, k <= (k-1)*j.
    Thus p**k | p**((k-1)*j)
    Thus p*(p**k) | p*(p**((k-1)*j))
    p*(p**k) = (p**(k+1)).
    Thus (p**(k+1)) | p*(p**((k-1)*j)) 
**** rhp**p = 1 + a*pk (mod pk1)
    rhs**p = (1 + (a*pk0))**p = (Binomial theorem)
     (x+y)**p = sum(C(p,j)*(x**(p-j))*(y**j), 0<=j<=p)
     x = 1, y = a*pk0
       Let t(j) = C(p,j)*((a*pk0)**j) = C(p,j)*(a**j)*(pk0**j)   [ (u*v)**j = (u**j)*(v**j) ]
       = sum(t(j), 0<=j<=p)
***** t(0) = C(p,0)*((a*pk0)**0) = 1
***** t(1) = a*pk 
       t(1) = C(p,1)*(a**1)*(pk0**1)
            = p*a*pk0
            = a*pk
***** if 2 <= j < p, then pk1 | t(j)
       pk0**j = (p**(k-1))**j 
              = p**((k-1)*j),  [ (x**I)**J = x**(I*J) ]
       Since 2<=k and 2<=j, k <= (k-1)*j [ See (Y) above ]
        Thus p**k | p**((k-1)*j).
        Thus p**k | pk0**j.
       p | C(p,j)  since 0 < j < p.
       p*(p**k) | C(p,j) * (pk0**j)
       pk1 = p*(p**k)
       pk1 | C(p,j) * (pk0**j) | t(j)
       pk1 | t(j)
***** if j = p, then pk1 | t(j)
       t(p) = C(p,p)*(a**p)*(pk0**p)  
       pk0**p = (p**(k-1))**p = p**((k-1)*p)  
       (k+1) <= (k-1)*p, [ by (Z), since 2<=k and 3<=p ]
       pk1 | p**(k-1)*p
       pk1 | pk0**p
       pk1 | t(p)
***** (X4) if 2 <= j <= p, then pk1 | t(j)
      Combine two previous
***** rhs**p = 1 + a*pk (mod pk1)  
      rhs**p = 1 + a*pk + sum(t(j),2<=j<=p)
      sum(t(j),2<=j<=p) = 0 (mod pk1) from (X4)
      rhs**p = 1 + a*pk (mod pk1)
**** a*pk != 0 (mod pk1)
   Since gcd(p,a) = 1 and pk1 = p*pk
**** rhs**p != 1 (mod pk1)
**** lhs**p != 1 (mod pk1)
   Since lhs = rhs
**** r**(pk0*p0) != 1 (mod pk1)
   Since lhs**p = r**(pk0*p0)
**** AS WAS TO BE SHOWN
** (11) DUPLICATE ?if p is an odd prime and 1<=k, then there is s so that PR(s,p**k).
   Case k=1:  See (0) above.
   Case 2<=k:  Choose r so that PR(r,p2), by (9).
    Then PR(r,p**k) by (10).
   QED.
* numerical
2<=k and r**((p**(k-2))*(p-1)) != 1 (mod p**k).

 p = 3, r= 2.  (p-1) = 2.)
  k = 2: r**(p-1) = 2**2 = 4 = 1 (mod p).   
         r**(p-1) != 1 (mod p**2)
            2**2 = 4 != 1 (mod 9)
  Try for k+1
  r**2 = 1 (mod p) Euler
  r**(p-1) = 1 + 1*3
  (r**(p-1))**p = (1 + 1*3)**3 = (1 + a*p)**3 = 1 +
  (a+b)**3 = a**3 + 3 a**2 * b + 3 a * b**2 + b**3
  (1+b)**3 = 1**3 + 3 1**2 * b + 3 1 * b**2 + b**3
  (1+b)**3 = 1 + p*(a*p) + x*((a*p)**2) + (a*p)**3
  
  (1+a
  k = 3. r**((p-1)*p) = 2**6 = 64 = 1 (mod 3**2 = 9)
          2**6 != 1 (mod 27)  (64 = 10 (mod 27))
         r**((p-1)*p) = 1 (mod p)
 r**(p-1) = 1 
  (1+b)**p = 1**n + p*(1**(p-1))*b (mod b**2)
           = 1 + p*b (mod b**2)
  b = a*pk0  k = 2
  b = a*p
  (1+(a*p))**p = 1 + p*(a*p) (mod (a*p)**2))  

* if p is prime and 2<p and 1<=n, then there is a primitive root for p**n (i.e. relprimes(p**n) is cyclic group)
from http://ramanujan.math.trinity.edu/rdaileda/teach/f20/m3341/lectures/lecture16_slides.pdf
Assume a,n,etc are in N* (1<=a, etc)
Let 1<=n.
Let G = relprimes(n) = {a, 1<=a<=n and gcd(a,n) = 1}.
  If 1 < n, then G = {a, 1<=a<n and gcd(a,n) = 1}, since gcd(n,n) = n != 1.
   Let R = {a, 0<=a<n}.  Let addition and multiplication be modulo n.
   1 = multiplicative identity in R.
   Units(R) = {a, a in R and E(b, b in R and a*b = 1 (mod n))}

**  (1) Units(R) = G.
   (a) a in Units(R). Note a != 0. Choose b in R and a*b = 1 (mod n).
      Note n | (a*b - 1). Le q be the Quotient:  n*q = a*b - 1.
      Then a*b = 1 + n*q.
      Let d | a and d | n.  Then d|1 so d = 1. Thus gcd(a,n) = 1. Thus a is in G.
   (b) a in G.  Then 1<=a<n and gcd(a,n) = 1.
      There are (Variation of Bezout Theorem) b and c so that
      1<=b and 0<=c and 
      a*b = 1 + n*c.  Thus a*b = 1 (mod n). So a is a Unit.
**  (2) Units(R) is a group (under multiplication mod n)
      Let a,b in U = Units(R).
      Choose c,d in R so that a*c = 1 and b*d = 1 (mod n)
      Then (a*b)*(c*d) = 1*1 = 1 (mod n)
      so (a*b) is in Units(R).
      1 is the multiplicative identity/
      Similarly. Let a in U.  Choose b in U so a*b = 1 (mod n).
      Thus b is the inverse of a.  Since b*a = 1 (mod n), then b is also in U.
**  (3) G is a group (under multiplication mod n)
    By (2), Since G = Units(R)
**  (4) If a in G and b in G, then gcd(a*b,n) = 1.
     G is a group. So a*b (mod n) is in G. Thus gcd(a*b,n) = 1.
**  (5) G is a finite set, NCard(G) = ephi(n)
     definition of ephi
**  (6) If a is in G, then a**ephi(n) = 1 (mod n) (Euler's Totient Theorem)
   See proofs of Fermat little theorem
   Proof sketch: G is a finite abelian group.
   Let P = product of the elements of G.  Let m = NCard(G).
    Choose an ordering  x1, x2, ..., xm of the elements of G.
    Then P = x1*x2*...*xm.
    Let f: G->G be multiplication by a. Then x1*a,...,xm*a is also an enumeration of G.
    Since G is abelian, P = (x1*a)*...*(xm*a) 
    and also (x1*a)*...*(xm*a) = (x1*...*xm)*(a*...*a) = P*(a**m)
    Since G is a group, a**m = 1.
**  (6a) If 1<=n and 1<=a and gcd(a,n) = 1, then a**ephi(n) = 1 (mod n) (Euler's Theorem)
    By (6), if a<=n, then a is in G and the result follows.
    Case n = 1: Then a**ephi(1) = a**1 = a = 1 (mod 1), SO done.
    Case n != 1:
     a = n*Quo(a,n) + Rem(a,n) = n*q + r, and 0 <= r < n.
     If r = 0, then a = n*q.  Thus q != 0.  Thus gcd(a,n) = gcd(n*q,n) = n.
       Thus n = 1, contrary to assumption.
     Thus, r != 0. Thus 1 <= r < n. 
     gcd(a,n) = gcd(n*q + r,n) = gcd(r,n)  [See comdivs theorems above]
     Thus r is in G. So r**ephi(n) = 1 (mod n) by (6) applied to 'r'.
     a = r (mod n).
     So, a**ephi(n) = r**ephi(n) (mod n).  
     So a**ephi(n) = 1 (mod n)
**  (7) If p is a prime and 1<=k, then ephi(p**k) = (p-1)*(p**(k-1)h)
**  (8) if 1<=n  and  gcd(a,n) = 1, Define Nord(a,n) = min(k, 1<=k and a**k = 1 (mod n))
    Note when n = 1 and 1<=a,  Nord(a,n) = 1.
    Let r = Rem(a,n).  Then a = r (mod n), and 0<=r<n.  And Also r != 0.
    And gcd(r,n) = gcd(a,n).  Thus, r is in relprimes(n).  Thus, by (6),
    1<=NCard(G) and a**NCard(G) = 1 (mod n).  So Nord is well-defined.
**  (9) if gcd(a,n) = 1 and 1<=m and a**m = 1 (mod n), then Nord(a,n) | m.
    Let S = {k, 1<=k and a**k = 1 (mod n)}. Then S is an Nideal, i.e.,
      j in S and k in S implies j+k is in S.
      j in S and 1<=k and j+k in S implies k is in S.
    Thus S = {k*min(S): 1<=k} = {k, 1<=k and Nord(a,n) | k}.
**  (9a) if gcd(a,n) = 1 then Nord(a,n) | ephi(n).
    By (6), a**ephi(n) = 1 (mod n)
    By (9), with m = ephi(n),  we conclude Nord(a,n) | ephi(n)
**  (9b) if 1<=n  and  gcd(a,n) = 1 and 1<=u and A(k,1<=k implies ((a**k = 1 (mod n)) IFF  u|k)) => u=Nord(a,n)
    S = {k, 1<=k and a**k = 1 (mod n)}. Since k is an N ideal and Nord(a,n) = min(S),
    S = all multiples of Nord(a,n). In particular, Nord(a,n) is in S, so
    1<=Nord(a,n) and a**Nord(a,n) = 1 (mod n); thus u|Nord(a,n).
    Now 1<=u implies ((a**u = 1 (mod n)) IFF  u|u).  Since u|u,  a**u = 1 (mod n).
    Thus, u is in S.  So also Nord(a,n)|u.  
    Thus, u = Nord(a,n)
**  (10) if m | n and gcd(a,n) = 1, then Nord(a,m) | Nord(a,n).
   Proof: If d | a and d | m, then d|a and d|n, so d = 1.  Thus, gcd(a,m) = 1.
   So a**Nord(a,b) = 1 (mod n).
   Now n | (a**Nord(a,n) - 1).  Thus m | (a**Nord(a,n) - 1).  Thus a**Nord(a,n) = 1 (mod m).
   Now by (9), Nord(a,m) | Nord(a,n)
**  (11) gen(a,n) = {a**k (mod n), 1<=k} This makes sense for 1<=a, 1<=n.
**  (12) Define: pr(a,n) iff 1<=a, 1<=n, gcd(a,n) = 1 and and gen(a,n) = G.
      Close to this Author's definition of "a is a primitive root modulo n"
**  (13) If p is prime and a in relprimes(p), then Nord(a,p)|(p-1).
   Proof: NCard(relprimes(p)) = ephi(p) = p-1, since p is a prime.
   Now apply (9a).
**  (14) 1<=m<n, gcd(a,n) = 1 => Nord(a**m,n) = Nord(a,n)/gcd(m,Nord(a,n)).
  Let b = a**m. Let d = Nord(a,n). Let  e = Nord(b,n). Let g = gcd(m,d).
  Let f = Quo(d,g).  To show: e = f.
  Apply 9b:  If 1<=n and gcd(b,n) = 1 and 1<=f and 
             A(k, 1<=k implies ((b**k = 1 (mod n)) IFF  f|k))  implies  f = e
   Now gcd(b,n) = 1  (since G is a group)
   Now g|d, so 1<=f and d = g*f and gcd(g,f) = 1.
   Assume 1<=k.  
   b**k = (a**m)**k = a**(m*k).
   Let M = Quo(m,g).  So 1<=M and m = g*M and gcd(g,M) = 1.
*** Suppose b**k = 1 (mod n). To show f|k.
       So d | m*k.
     g*f | m*k so g|m*k.  
     So g*f | g*M*k ; so f|M*k.    
       Claim gcd(f,M) = 1 
         Suppose x|f and x|M.  To show: x = 1
         d = g*f and gcd(g,f) = 1.
         m = g*M and gcd(g,M) = 1.
            Thus, x|d and x|m.  Thus x|g
            Since x|f and x|g, then x|gcd(g,f), so x|1,  so x = 1.
        Thus, gcd(f,M) = 1.
    So, f|k.
*** Suppose f|k. To show: b**k = 1 (mod n). 
    Say q = Quo(f,k), so k = f*q.
    m*k = m*f*q = g*M*f*q = (g*f)*(M*q) = d*(M*q)
    Thus, d|m*k.  Hence, a**(m*k) = 1 (mod n)
    Thus b**k = 1 (mod n)
*** Now, by 9b, f = e.
  
**  (15) If p is prime and a in relprimes(p) and f = X**d - 1 (mod p), then roots(f) = {a**1,...,a**Nord(a,p)}
   Let d = Nord(a,p).  So d | (p-1).
   The ring R = {0,1,...,p-1} with (mod p) operations is a Field, since p is a prime.
   Let f = polynomial X**d - 1 in (mod p).
   Since R is a field, NCard(roots(f)) <= d.
   Consider T = {a**k, 1<=k<=d}.  By definition of Nord(a,p), T has 'd' elements,
   Further if 1<=k, then (a**k)**d = a**(k*d) = 1 (mod p) (see (9)).
   Thus T is subset of roots(f).  Thus NCard(roots(f)) = d (and T = Roots(f))

**  (16) if p is prime and a in relprimes(p), then ephi(Nord(a,p)) = NCard({b in relprimes(p) and Nord(b,p) = Nord(a,p)})
   Let T = {b in relprimes(p) and Nord(b,p) = Nord(a,p)}   
   Let d = Nord(a,p).  
   To show ephi(d) = NCard(T).
   Recall ephi(d) = NCard(relprimes(d)).
   
   Choose 1<=m<=d and set b = a**m and e = Nord(b,p).
   Let g = gcd(m,d).
   By (14), e = d/g.  Thus, e = d Iff g = 1 Iff m in relprimes(d)

   Thus, the formula m -> a**m defines a function F from relprimes(d) to T.
   And F is a bijection.
   Thus NCard(relprimes(d)) = NCard(T). QED.
**  (17) If p is prime and a in relprimes(p) and Nord(a,p) = p-1, then Nord(a,p**2) is p-1 or p*(p-1).
     Set d = Nord(a,p**2). 
     a is in relprimes(p**2). NCard(relprimes(p**2)) =  p*(p-1).
     So d | p*(p-1).
     Apply (10): if p | p**2 and gcd(a,p**2) = 1, then Nord(a,p) | Nord(a,p**2)
     So, Nord(a,p)|d.  So, by assumption, (p-1)|d.
     Let q = Quo(d,p-1).  Thus d = (p-1)*q.
     So q | p.  Since p is prime, either q=1 or q=p.
     So either d=(p-1) or d = (p-1)*p.
**  (18) If p is prime and 2<p and pr(a,p), then either pr(a,p**2) or pr(a+p,p**2)
    By assumption, a in relprimes(p) and Nord(a,p) = p-1.
    NCard(relprimes(p**2)) = ephi(p**2) = p*(p-1).
    Now a is in relprimes(p**2). And also gcd(a+p,p**2) = 1, so a+p is in relprimes(p**2).
    Thus, pr(a,p**2) iff Nord(a,p**2) = p*(p-1)
      and pr(a+p,p**2) Iff Nord(a+p,p**2) = p*(p-1)
    If Nord(a,p**2) = p*(p-1), then we are done.
    Suppose Nord(a,p**2) != p*(p-1).  To show: Nord(a+p,p**2) = p*(p-1).
      By (17), Nord(a,p**2) is p-1 or p*(p-1).
      Thus Nord(a,p**2) = (p-1).  So a**(p-1) = 1 (mod p**2)
      Apply (10): if p | p**2 and gcd(a+p,p**2) = 1, then Nord(a+p,p) | Nord(a+p,p**2)
      Since a+p = a (mod p), also Nord(a+p,p) = Nord(a,p) = p-1.
      Also by (17)(? NOT QUITE!) Nord(a+p,p**2) is p-1 or p*(p-1)
      TO SHOW: (a+p)**(p-1) != 1 (mod p**2)
       Apply Binomial theorem: If 2<=n, then (a+b)**n = a**n + n*(a**(n-1))*b (mod b**2) with n = p-1, b = p
       By assumption, 2<p, so 2<=(p-1).
       So (a+p)**(p-1) = a**(p-1) + (p-1)*(a**((p-1)-1))*p (mod p**2)
                      = a**(p-1) - (a**(p-2))*p (mod p**2)
                      = 1 - (a**(p-2))*p (mod p**2)
       Thus, (a+p)**(p-1) = 1 (mod p**2) implies (a**(p-2))*p = 0 (mod p**2)
        implies p | a**(p-2). But, we assume gcd(a,p) = 1, so does not divide any power of 'a'.
        Thus, (a+p)**(p-1) != 1 (mod p**2).
**  (19) If p is prime and 2<p and 3<=n and pr(a,p**(n-1)), then pr(a,p**n)
    Since pr(a,p**(n-1)), a is in relprimes(p**(n-1)).
     So 1<=a and gcd(a,p**(n-1))=1, and also a<p**(n-1).
     Nord(a,p**(n-1)) = NCard(relprimes(p**(n-1))) 
                      = ephi(p**(n-1)) = (p-1)*(p**(n-2)) since p is prime.
    To show pr(a,p**n), require
     (a) 1<=a<=p**n : true since a<p**(n-1) and p**(n-1) < p**n.
     (b) gcd(a,p**n) = 1: true since p is prime and gcd(a,p) = 1.
     (c) Nord(a,p**n) = ephi(p**n)  THIS IS TO BE SHOWN
     Since p is prime, ephi(p**n) = (p-1)*(p**(n-1)), so we must show
         Nord(a,p**n) = (p-1)*(p**(n-1))
    Let d = Nord(a,p**n).   Note a**d = 1 (mod p**n). 
*** (a1) IF a**((p-1)*(p**(n-2))) != 1 (mod p**n), then  d = ephi(p**n)
    By (9a), d | ephi(p**n); and ephi(p**n) = (p-1)*(p**(n-1))
     so d | (p-1)*(p**(n-1))
    Apply (10):  if p**(n-1) | (p**n) and gcd(a,p**n) = 1, then Nord(a,p**(n-1)) | Nord(a,p**n)
     so Nord(a,p**(n-1)) | d.
    So, (p-1)*(p**(n-2)) | d | (p-1)*(p**(n-1))
       Let x = p**(n-2). So (p-1)*x | d | (p-1)*x*p. So Quo(d,(p-1)*x) | p
       So Quo(d,(p-1)*x) is 1 or p, since p is prime.
       If Quo(d,(p-1)*x) = 1, whence d = (p-1)*(p**(n-2)) We must show this case does not occur.
       If Quo(d,(p-1)*x) = p, whence d = (p-1)*(p**(n-1)) In this case, the conclusion d=ephi(p**n) is proved.
   Let us show that a**((p-1)*(p**(n-2))) != 1 (mod p**n), as this implies d != (p-1)*(p**(n-2))
*** (b1) Choose k so that a**((p-1)*(p**(n-3))) = 1 + k*(p**(n-2))
    Apply Euler's theorem (6a) :
     We have 1<=p**(n-2) and 1<=a and gcd(a,p**(n-2)) = 1,
      conclude:  a**ephi(p**(n-2)) = 1 (mod p**(n-2))
      Now, Since 3<=n, 1<=n-2. So ephi(p**(n-2)) = (p-1)*(p**(n-3))
     So a**((p-1)*(p**(n-3))) = 1 (mod p**(n-2))
     Thus we may choose k as indicated.
*** (b2) p does not divide k
   Suppose a**((p-1)*(p**(n-3))) = 1 (mod p**(n-1)).
    Then  Nord(a,p**(n-1))  <= (p-1)*(p**(n-3))   (by defn of Nord)
    So  (p-1)*(p**(n-2)) <= (p-1)*(p**(n-3)) 
    But 0 <= n-3 < n-2, so p**(n-3)  < p**(n-2)
    And 0 < (p-1), so (p-1)*(p**(n-3))  < (p-1)*(p**(n-2))
    Having arrived at a contradiction, we may conclude
   a**((p-1)*(p**(n-3))) != 1 (mod p**(n-1))
    Thus 1 + k*(p**(n-2)) != 1 (mod p**(n-1))
    Thus k*(p**(n-2)) != 0 (mod p**(n-1))
    Thus p**(n-1) does not divide k*(p**(n-2))
    Thus p*(p**(n-2)) does not divide k*(p**(n-2))
    Thus 
  p does not divide k.
*** let lhs = (a**((p-1)*(p**(n-3))))**p = a**((p-1)*(p**(n-2)))
  Take pth power of  = 1 + k*(p**(n-2)):
   Set lhs = (a**((p-1)*(p**(n-3))) ** p) = (1 + k*(p**(n-2)))**p  = rhs
   u = ((p-1)*(p**(n-3))), v = p
   lhs = (a**((p-1)*(p**(n-3))) ** p) = (a**u)**v = a**(u*v)
   x = p-1, y = p**(n-3).   u = x*y.   u*v = (x*y)*v = x*(y*v)
   y*v = (p**(n-3))*p = p**((n-3)+1) = p**(n-2)
   u*v = (p-1)*(p**(n-2))
  lhs = (a**((p-1)*(p**(n-3))) ** p) = a**((p-1)*(p**(n-2)))
*** (a2) if lhs != 1 (mod p**n), then d = ephi(p**n).

   From (a1) and previous formula.
*** (a3) let rhs = (1 + k*(p**(n-2)))**p = 1 + k*(p**(n-1)) (mod (k**2)*(p**(2*(n-2))))
  By Binomial theorem: If 2<=n, then (a+b)**n = a**n + n*(a**(n-1))*b (mod b**2)
  Let b = k*(p**(n-2)). 
   example n = 3.  p**(3-2) = p**1 = p
           b = k*p,  b**2 = k*k*(p**2) = k*k*(p**(n-1))
   example n = 4. p**(4-2) = p**2
           b = k*p, b**2 = k*k*(p**4) = k*k*(p**n)
  Since 2 <= p,
   rhs = (1+b)**p = 1**p + p*(1**(p-1))*b (mod b**2) = 1 + p*b (mod b**2)
       = 1 + k*(p**(n-1)) (mod b**2)
   Now b**2 = k*k*(p**(n-2))*(p**(n-2)) = (k**2)*(p**(2*(n-2)))
    
   rhs = 1 + k*(p**(n-1)) (mod (k**2)*(p**(2*(n-2))))
*** (b3) if rhs != 1 (mod p**n), then d = ephi(p**n)
   lhs = rhs from (b1). Then result follows from (a2)
*** (b4) if 4<=n, then rhs != 1 (mod p**n)
    Assume 4<=n.
    Assume rhs = 1 (mod p*n) and search for contradiction.
    Thus p**n | (rhs - 1)
    Now there is j so that 
    rhs - 1 = k*(p**(n-1)) + j*(k**2)*(p**(2*(n-2)))
     n <= 2*(n-2) IFF n <= n+n-4) Iff 0 <= n-4 Iff 4<=n
    So, assuming 4<=n, we have n <= 2*(n-2)
    so p**n | p**(2*(n-2))
    Thus p**n | k*(p**(n-1))  Thus p|k, contradicting (b2).
    Thus rhs != 1 (mod p*n).
*** (b5) if 4<=n, then d = ephi(p**n)
    From (b3) and (b4)
*** (b6) if n = 3, then d = ephi(p**n)
    We must show rhs != 1 mod (p**3).

  By Binomial theorem: if 3<=n, then (a+b)**n = a**n + C(n,1)*(a**(n-1))*(b**1) + C(n,2)*(a**(n-2))*(b**2) + (mod b**3)
  b = k*(p**(n-2))  Apply with n = p. We are assuming 3<=p.
  rhs =   (1+b)**p = 1**p + C(p,1)*(1**(p-1))*(b**1) + C(p,2)*(1**(p-2))*(b**2) + (mod b**3)
             = 1 + p*b + C(p,2)*(b**2) + j*(b**3) (for some j).
  b = k*p.
             = 1 + k*(p**2) + C(p,2)*(k**2)*(p**2) + j*(k**3)*(p**3)
  C(p,2) = (p*(p-1))/2  and is divisible by p. So there is u
             = 1 + k*(p**2) + u*(k**2)*(p**3) + j*(k**3)*(p**3)
  Thus rhs = 1 + k*(p**2) (mod p**3).
  Now if rhs = 1 (mod p**3), then k*(p**2) = 0 (mod p**3), so p**3 | k*(p**2), so p | k, which is not true by (b2).
  Thus rhs != 1 (mod p**3)
***
*** (b7) if 3<=n, then d = ephi(p**n)  THIS COMPLETES THE PROOF
    from (b5) and (b6)

**  (20) If p is prime and 2<p and pr(a,p) and pr(a,p**2) and 2<=n, then pr(a,p**n)
    Induction on n:  A(n, 2<=n implies pr(a,p**n))
    Case n = 2. Assumed
    Inductive assumption: pr(a,p**n)
    To show: pr(a,p**(n+1)).
    Proof: Apply (19).
**  (21) if p is prime and 2<p and pr(a,p) and pr(a+p,p**) and 2<=n, then pr(a+p,p**n)
   Similar to proof of (20)
** (22) If p is prime and 2<p and 1<=n, then there is 'a' so that pr(a,p**n).
   Case n=1. We have proved that there is 'a' so that pr(a,p).
   Case n=2. We know there is 'a' so that pr(a,p). By (18), either pr(a,p**2) or pr(a+p,p**2)
   case n<=2. Use case n=2 and (20) and (21).
* if gcd(m,n) = 1 and 3<=m and 3<=n, then relprimes(m*n) is not cyclic
   if 3<=n, then ephi(n) is even (proved above)
   Similarly, ephi(m) is even; also ephi(m*n) is even. 
   Let q = Quo(ephi(m*n),2). so ephi(m*n) = 2*q
    Suppose a is in relprimes(m*n). We will show a**q = 1 mod (m*n).
    Thus Nord(a,m*n) <= q < ephi(m*n), so a is NOT a primitive root of m*n.
   Now show a**q = 1 (mod m*n).
   Now, gcd(a,m*n) = 1, so also gcd(a,m) = 1 and gcd(a,n) = 1.
   Also, ephi(m*n) = ephi(m)*ephi(n).
   Let j = Quo(ephi(m,2)) and k = Quo(ephi(n),2). So
   ephi(m) = 2*j, ephi(n0 = 2*k.
   2*q = ephi(m*n) = ephi(m)*ephi(n) = 2*j*2*k 
   q = (2*j)*k = ephi(m)*k
   Similarly, q = ephi(n)*j
   Apply Euler theorem to m:  Since gcd(a,m) = 1, a**ephi(m) = 1 (mod m)
   Thus, a**q = (a**(ephi(m)))**k = 1**k (mod m) = 1 (mod m).
   Similarly, a**q = 1 (mod n)
   Now, m | (a**q - 1) and n | (a**q - 1).
   Since gcd(m,n) = 1,  we conclude m*n | (a**q - 1).
   Thus, a**q = 1 (mod m*n).
   As above, we now know that a is not a cyclic generator of relprimes(m*n).
   Thus, relprimes(m*n) is not cyclic.


* if p is prime, 2<p and q is prime, 2 < q, p!=q and p*q | k, then relprimes(k) is not cyclic.
  We can write k = (p**j)*k, where 1<=j, 3<=k, gcd(p,k)=1. Now previous theorm applies.
* if p is prime, 2<p, 2<=j and 1<=k, then relprimes((2**j)*(p**k)) is not cyclic.
  3<=2**j, 3<=p**k and gcd(2**j,p**k) = 1. Conclusion follows from prior theorem.
* numerical experiments for primitive roots of p**k (2<p a prime)
** Case p = 3
  primitive roots of 3 = {2}.  
  r = 2.  
  k = 2.  r**(p-1) = 2**2 = 4 != 1 (mod 3**2).  2 is primroot of 3**2.
  k = 3   r**(p*(p-1)) = 2**(3*2) = 64 = 10 (mod 3**3)
          ephi(3**3) = 18.  eltOrder(2,3**3) = 18. So 2 is prim root of 3**3)
  k = 4   r**((p*p)*(p-1) = 2**(18) (mod 3*3*3*3) = 28.  ephi(3**4) = 54.  eltOrder(2,3**4) = 54
  So, 2 appears to be a primitive root for 3**k for all 2<=k
** Case p = 5
  primitive roots of 5 = {2,3}
  r = 2. 2**(5-1) = 2**4 = 16 != 1 (mod 5**2).  ephi(5**2) = 20. eltOrder(2,5**2) = 20.  2 a prim root of 5**2
   k = 3  r**(p*(p-1)) = 2**(5*4) = 76 (mod 5**3) ephi(5**3) = 100. eltOrder(2,5**3) = 100. 2 a prim root of 5**3
   k = 8  r**((p**6)*(p-1) = 2**((5**6)*4) = 234376 != 1 (mod 5**8).  ephi(5**8) = 312500. eltOrder(2,5**8) = 312500. 2 pr of 5**4
  r = 3. 3**(5-1) = 81 = 6 != 1 (mod 5**2)  eltOrder(3,5**2) = 20. So 3 is prim root of 5**2
   k = 8 r**((p**6)*(p-1) = 3**((5**6)*4) = 78126 != 1 (mod 5**8).  ephi(5**8) = 312500. eltOrder(3,5**8) = 312500.
  So, 3 appears to be a primitive root for 5**k for all 2<=k.
** Case p = 7
  primitive roots of 7 = {3,5}
  r = 3. r**(p-1) = 3**6 (mod 7**2) = 7 (mod 7**2) != 1 so expect 3 to be a primitive root of 7**k for 2<=k.
  r = 5. r**(p-1) = 5**6 (mod 7**2) = 43 (mod 7**2) != 1, so expect 5 to be a prim root of 7**k for 2<=k
  Validated that 3 and 5 are among the primitive roots for 7**4
** Case p = 11
  primitive roots of 11 = {2,6,7,8}
  For all prim roots r, r**10 != 1 (mod 11**2)
  r = 2. r**(p-1) = 2**10 (mod 11**2) = 7 (mod 7**2) != 1 so expect 3 to be a primitive root of 7**k for 2<=k.
** Case p = 13
  primitive roots of 13 = {2,6,7,11}
  For all prim roots r, r**12 != 1 (mod 13**2)
** Case p = 17
primRoots(17) = [3, 5, 6, 7, 10, 11, 12, 14]
** Case p = 29  PR(14,29), not PR(14,29**2), PR(14+29,29**2)
  primitive roots of 29 = [2, 3, 8, 10, 11, 14, 15, 18, 19, 21, 26, 27]
  Case r = 14
  eltOrder(14, 29**2) = 28 (= (p-1))
  ephi(29**2) = 812
  So r is NOT a primitive root for 29**2
  r1 = r+29 = 43 eltOrder(43,29**2) = 812, so r1 IS a primitive root of 29**2.
** Case p = 37
  primitive roots of 37 = [2, 5, 13, 15, 17, 18, 19, 20, 22, 24, 32, 35]
  Case r = 18
  eltOrder(18,37**2) = 36  ephi(37**2) = 1332.  Thus 18 is NOT a primitive root of 37**2
  r1 = 18 + 37 = 55. eltOrder(55,37**2) = 1332.  so, r1 IS a primitive root of 37**2
  Also eltOrder(55,37**3) = 49284   = ephi(37**3), so r1 is a primitive root of 37**3
  Also eltOrder(55,37**4) = 1823508 = ephi(37**4), so r1 is a primitive root of 37**4
  
* ==================================================================
* indexes in finite groups
Following http://ramanujan.math.trinity.edu/rdaileda/teach/f20/m3341/lectures/lecture17_slides.pdf
http://ramanujan.math.trinity.edu/rdaileda/index.shtml
http://ramanujan.math.trinity.edu/    San Antonio, Texas.
* ==================================================================
* NdiffIdeal(I,J) where NidealQ(I) and NidealQ(J)
  NdiffIdeal(I,J) = {c, E[a,E[b, in(a,I) & in(b,J) and a>b and c = a-b}
  Note: When Nlt(a,b), a-b is that element d of N such that b+d = a.
  Of course, when a and b are viewed as elements of Z,  then a-b can be
  viewed as subtraction in Z.
  Theorem: if NidealQ(I) and NidealQ(J), then NidealQ(NdiffIdeal(I,J))
  Proof: Let K = NdiffIdeal(I,J).
  Let a0 = NMin(I). So I = {k*a0: 1<=k}. Note a0 is in I, and 1<=a0.
  Let b0 = NMin(J). So J = {k*b0: 1<=k}. Note b0 is in J, and 1<=b0.
  Clearly, K is a subset of N*.
** K is not empty.
  Proof: Set k = b0+1. Then 1<=k. So k*a0 is in I; also b0 is in J.
   k*a0 = (b0+1)*a0 = b0*a0 + 1*a0 = b0*a0 + a0.
   Since 1 <= a0 and 1<=b0,  b0*1 <= b0*a0, so b0 <= b0*a0.
   Also 0 < a0. So b0*a0 < b0*a0 + a0.
   b0 < b0*a0 + a0,  so k*a0 > b0.
   Since thus, k*a0 - b0 is in K.
   So K is not empty.
** if c1 and c2 are in K, then c1+c2 is in K.
  Proof:  
  Choose a1 in I, b1 in J so that a1>b1 and c1 = a1-b1.
  Choose a2 in I, b2 in J so that a2>b2 and c2 = a2-b2.
  Let c3 = c1 + c2.
  Set a3 = a1 + a2, and b3 = b1 + b2.
  Since I is an ideal, a3 is in I.
  Since J is an ideal, b3 is in J.
  Since a1 > b1 and a2 > b2, then also a1+a2 > b1+b2, or a3>b3.
  Further, (e.g. by Z arithmetic):  c3 = (a1-b1)+(a2-b2) = (a1+a2)-(b1+b2).
  Thus, c3 is in K.
** Lemma 1: if 1 <= u and 0 <= v, then (v+1)*u > v

   (v+1)*u =  v*u + u
           >  v*u since u > 0
           >= v  since u >= 1 (and v >= 0)
** Lemma 2: if 1<=i1, 1<=i2, 1<=b0, and x >= i2+1, then i1 + x*b0 > i2.
Proof: 
 i1 + x*b0  >= i1 + (i2+1)*b0 since b0 >= 0
            >= (i2+1)*b0 since i1 >= 0
             >  i2 by Lemma 1
** if c2 is in K and c2 is in K and c1 > c2, then c1-c2 is in K.
  Proof:  This proof is much less obvious. 
  Choose a1 in I, b1 in J so that a1>b1 and c1 = a1-b1.
  Choose a2 in I, b2 in J so that a2>b2 and c2 = a2-b2.
  Let c3 = c1 - c2.  Note c2 > 0, by assumption.
  We must find a3 in I and b3 in J so that a3>b3 and c3 = a3 - b3.
  Comment:  If we take a4 = a1-a2 and b4 = b1-b2, then (with Z arithmetic)
   a4 - b4 = (a1-a2) - (b1-b2) = (a1-b1) - (a2-b2) = c1 - c2 = c3,
   However,  we do not know a4 is in I and b4 in J, since
   we do not know that a1>a2 and b1>b2.
   Thus, a more complex procedure is required.
   Here is one such procedure.

  Since NidealQ(I) and a1 is in I, there is 1<=i1 so that a1 = i1*a0.
   Since a2 is in I, there is 1<=i2 so that a2 = i2*a0.
  Since NidealQ(J) and b1 is in J, there is 1<=j1 so that b1 = j1*b0.
   Since b2 is in J, there is 1<=j2 so that b2 = j2*b0.
  
  By Lemma 2, if we choose x = max(i2+1,j2+1), then
    i1 + x*b0 > i2 and j1 + x*a0 > j2
  NOTE: A simpler choice that works is x = max(i2,j2).
  Now set i3 =  i1 + x*b0 - i2, so 1<=i3.
  and set j3 = j1 + x*a0 - j2, so 1<=j3.
  And set a3 = i3*a0, so a3 is in I.
  and set b3 = j3*b0, so b3 is in J.
  The next uses Z-arithmetic for simplicity:
  Then a3 - b3 = (i1 + x*b0 - i2)*a0 - (j1 + x*a0 - j2)*b0
       = i1*a0 + x*b0*a0 - i2*a0 - (j1*b1 + x*a0*b0 - j2*b0)
       = i1*a0 + x*b0*a0 - i2*a0 - j1*b1 - x*a0*b0 + j2*b0
       = i1*a0 - i2*a0 - j1*b1 + j2*b0  since x*b0*a0 - x*a0*b0 = 0
       = a1 - a2 - b1 + b2 = (a1-b1) - (a2-b2) = c1 - c2 = c3.
  Also, a3 > b3 since c3 > 0.
  Thus,  c3 is in K. QED.
** NidealQ(K)
  We have shown that K satisfies the properties required.
  QED.
* TODO: NgenIdeal(S) The Nideal generated by non-empty subset S of N*.
  Define this as the intersection of all ideals I that contain S.
  Let U = {I, NidealQ(I) and leq(S,I)} (set of all ideals containing S)
  NgenIdeal(S) := isect(U)
  Since NidealQ(N*) and leq(S,N*), N* is in U, so U is not empty.
  Thus, a is in NgenIdeal(S) iff A(I, in(I,U) implies in(a,I)).
  NOTE:  There may be some technical detail regarding isect(U) ?
  Theorem: if leq(S,N*) and S!= 0, then 
   a) NidealQ(NgenIdeal(S)) 
   b) leq(S,NgenIdeal(S))
   c) in(I,U) implies leq(S,I)
* TODO 1: NlcIdeal(S)  Alternate description of NgenIdeal(S) when S is finite.
  Let S be a finite non-empty subset of N*.
  Let F = functionSet(S,N*).
** dp(f,g)  'dot product' of functions
  If f and g are in F, we can form the sum over s in S of
  the product f(s)*g(s); this sum is an element of N*. Let's use the
  temporary notation dp (for dotproduct):
   dp(f,g) = Sum(s in S, f(s)*g(s)).
** lc(f) linear combination of elements of S with coefficients in N*
  Let Id = identity(S), the identify function on S.
  Thus, in(Id,F).
  Use temporary notation 
   lc(f) = dp(f,Id(S)), for f in F
   So, lc(f) = Sum(s in S, f(s)*s)
  Thus, if in(f,F), then in(lc(f),N*)
** pointwise addition in F.
   in(f,F), in(g,G).  (f+g)(s) = f(s) + g(s), for s in S. 
** Lemma 1: lc(f+g) = lc(f) + lc(g)
   lc(f+g) = Sum(s in S, [(f+g)(s)]*s) 
           = Sum(s in S, [f(s)+g(s)]*s)
           = Sum(s in S, (f(s)*s) + (g(s)*s))
           = Sum(s in S, f(s)*s) + Sum(s in S,g(s)*s)
           = lc(f) + lc(g)
** LC = {a, E(f, in(f,F) and a = lc(f))}
** Lemma1a: if in(f,F), then in(lc(f),LC)
   proof: trivial
** Lemma 2: leq(LC,N*)
   proof 'obvious'
** Lemma 3: if in(a,LC) and in(b,LC), then in (a+b,LC).
   Choose f in F with a = lc(f); choose g in F with b = lc(g).
  Then a+b = lc(f) + lc(g) = lc(f+g)
** NlcIdeal(S) = {c such that E(a,E(b, in(a,LC) and in(b,LC) and a>b and c=a-b))}
   We will show that NlcIdeal(S) = NgenIdeal(S).
** Let M = NlcIdeal(S). 
** Lemma4a: leq(M,N*)
   Let c in M. Choose in(a,LC) and in(b,LC) with a>b and c=a-b.
   Now a in N*, b in N* and a>b.  Thus, a-b in N*. So c in N*.
** Lemma4b: leq(S,M).
   Choose x in S.
   Define f in F by
    f(s) = 2 if s = x
    f(s) = 1 if s in S and s != x.
   Define g in F by
    g(s) = 1 for s in S.
   Thus, in(f,F) and in(g,F).
   Thus lc(f) is in LC, and lc(g) is in LC
   lc(f) = x + Sum(s in S, s)
   lc(g) = Sum(s in S, s)
   Thus lc(f) > lc(g), and
   lc(f) - lc(g) = x
   Thus x is in M.
** Lemma4c: M != 0
   Since S is not empty, choose x in S.  Then in(x,M). Thus M != 0.
** Lemma4d: if in(c1,M) and in(c2,M), then in(c1+c2,M)
   choose a1 and b1 in LC with a1>b1 and c1 = a1-b1.
   choose a2 and b2 in LC with a2>b2 and c2 = a2-b2.
   Set c3 = c1+c2.  We must show c3 is in M.
   Set a3 = a1+a2, b3 = b1+b2.
   Then in(a3,LC) and in(b3,LC) and a3 > b3.
   and a3-b3 = (a1+a2) - (b1+b2) 
             = (a1-b1) + (a2-b2)
             = c1 + c2 = c3
   Thus, in(c3,M).
** Lemma4e: if in(c1,M) and in(c2,M) and c1>c2, then in(c1-c2,M)
   choose a1 and b1 in LC with a1>b1 and c1 = a1-b1.
   choose a2 and b2 in LC with a2>b2 and c2 = a2-b2.
   Let c3 = c1 - c2. We must show c3 is in M.
   Choose f1 in F with a1 = lc(f1).
   Choose f2 in F with a2 = lc(f2).
   Choose g1 in F with b1 = lc(g1).
   Choose g2 in F with b2 = lc(g2).
   Define function h on S by h(s) = max(f2(s),g2(s)) for s in S.
   Then h in F.
   Define function f3 on S with values in Z by
    f3(s) = f1(s) + h(s) - f2(s) 
          >= f1(s) + f2(s) - f2(s)
          = f1(s)
          > 0
   So, in(f3,F)
   Similarly, define function g3 on S with values in Z by
    g3(s) = g1(s) + h(s) - g2(s)
          >= g1(s) + g2(s) - g2(s)
          = g1(s)
          > 0
   So, in(g3,F).
   Set a3 = lc(f3). So in(a3,LC).
   Set b3 = lc(g3). So in(b3,LC)
   Then,
    a3 - b3 = Sum(s in S, (f1(s) + h(s) - f2(s))*s)
            - Sum(s in S, (g1(s) + h(s) - g2(s))*s)
            = Sum(s in S, f1(s)*s + h(s)*s - f2(s)*s - g1(s)*s - h(s)*s + g2(s)*s)
            = Sum(s in S, f1(s)*s - f2(s)*s - g1(s)*s + g2(s)*s)
            = lc(f1) - lc(f2) - lc(g1) + lc(g2)
            = a1 - a2 - b1 + b2
            = (a1 - b1) - (a2 - b2)
            = c1 - c2
            = c3
    Since c1>c2, we know c1 - c2 > 0.
    Thus a3 - b3 > 0.
    Thus a3 > b3.
    So we have in(a3,LC), in(b3,LC), a3>b3, and c3 = a3-b3.
    Thus, c3 in M
**
** Theorem: NidealQ(M)
   Proof: From Lemma4a, Lemma4c, Lemma4d, and Lemma4e.
** TODO M = NgenIdeal(S)
* ************************************************************
* Gauss Lemma 1 on primitive polynomials.
* ************************************************************
* polynomial terminology  CRUDE SUMMARY
   Z[X] polynomials with integer coefficients
   Q[X] polynomials with rational coefficients
   Maybe think of a polynomial f in R (R[X]) as a sequence f:N->R
   such that f(k) = 0 for all sufficiently large k.
   Then deg[f] = Max(S(k, k in N and f(k)!=0)). 
    When f has no non-zero coefficients, then deg[f] could be taken as 0.
   f = 0 means f(k) = 0 for all k in N.
   For k in N, we have the set of all pairs (i,j) in N such that i+j = k.
   f*g(k) = sum(f(i)*f(j) for i+j = k).
* divisors(f) and content(f) for f in Z[X]
   For k in N, we have the set of all pairs (i,j) in N such that i+j = k.
   f*g(k) = sum(f(i)*f(j) for i+j = k).
** divisors(f) defined for f in Z[X] 
   divisors(f) = {d, d in N* and A(i, if i in N,  then d | f(i))
** divisors(f) is a subset of N*.
** divisors(0-poly) = N*.
** 1 in divisors(f) 
   since f(i) in Z, 1 | f(i)   A(i)
** if f != 0, then divisors(f) is finite
   Choose i in N with f(i) != 0.
   Choose d in divisors(f).
    d|f(i)
    d in divisors(f(i)).
   divisors(f) is a subset N-divisors(f(i)) 
*** N-divisors(f(i)) is finite:
    f(i) is in Z and f(i) != 0.
    Let A =  Abs(f(i)) + 1.  
    A in N.
    If d in N-divisors(f(i)), then d in A
      i.e., d in N and d | f(i) in Z.
      In particular d <= Abs(f(i)). 
      Abs(f(i)) in N, since f(i) in Z
      Abs(f(i)) < A
      d < A.
      d in A   (subsets of N)
    N-divisors(f(i)) is subset of A.
    A is finite, since A is an element of N.
    N-divisors(f(i)) is finite  (since a subset of the finite set A)
*** divisors(f) is finite 
    Since a subsite of the finite set N-divisors(f(i))
** content(f) is an element of divisors(f)
   The max of a finite nonempty subset D of N is an element of D.
** content(f) in N* 
   Since content(f) is in divisors(f)
** if i in n, then content(f) | f(i))
   Since content(f) is in divisors(f)
** if d in divisors(f), then d <= content(f)
* Gauss Lemma 1 on primitive polynomials: 'elementary' proof
** content(f) != 1 IFF there is a prime p in divisors(f)
   Let c = content(f), D = divisors(f)
*** if c != 1, then there is a prime p in D.
   1 < c
   c in N
   there is a prime p which divides c.
   1 <= p, defn of prime
   if i in N, then p | f(i)
    c | f(i)  , since c in D
    p | f(i)
   p in D
*** if p is a prime and p in D, then c != 1.
  p in D
  c = NMax(D)
  p <= c , property of NMax(D)
  1 < p, since p a prime
  1 < c.
  c != 1
** if d in N* and d not in divisors(f), then there is i in N with Not (d | f(i))
** (GAUSS) If content(f) = 1 and content(g) = 1, then content(f*g) = 1. 
   Let h = f*g .
   Assume content(h) != 1 (and derive a contradiction)
   choose a prime p in divisors(h).
   p is not in divisors(f), since content(f) = 1
   p in N*, defn of prime
   Let I = S(i, i in N, p does not divide f(i))
   I is a non-empty subset of N.
   Let r = NMin(I)
   r in I.  
   p does not divide f(r)
   if i < r, and f(i) != 0, then p | f(i).
   Similarly,
   Let J = S(j, j in N with g(j) != 0 and p does not divide g(j))
   s = NMin(J)
   s in J
   p does not divide g(s)
   p does not divide f(r)*g(s), since p is prime and divides neither factor.
   if j < s, and g(j) != 0, then p | g(j)
   
   Let S = {(i,j), i in N, j in N,  i+j = r+s, f(i)*g(j)}
   h(r+s) = Sum(S), by definition of polynomial product
   p | h(r+s)  since p in divisors(h)
   Let S1 = {(i,j) in S and i < r} 
   Let S2 = {(i,j) in S and i = r}
   Let S3 = {(i,j) in S and i > r}
   S = Union(S1,S2,S3) and S1, S2, S3 are pairwise disjoint
   Note S1 may be empty or S3 may be empty.
   Let s1 = 0 if S1 is empty and Sum(f(i)*g(j) for (i,j) in S1) if S1 is not empty
   Let s3 = 0 if S3 is empty and Sum(f(i)*g(j) for (i,j) in S3) if S3 is not empty
   Let s2 = Sum(f(i)*g(j) for (i,j) in S2)
*** TODO h(r+s) = s1 + s2 + s3
   Seems clear, but
   Some infrastructure required for a formal proof.
*** if (i,j) in S1, then p | f(i)*g(j) 
   Since p | f(i)
*** if (i,j) in S3, then p | f(i) * g(j)
    j < s.  Thus p | g(j)
*** p | s1
    If S1 is empty, s1 = 0 and p | 0
    If S1 is not empty, then p | Sum(f(i)*g(j) for (i,j) in S1)
    Since p divides each summand
*** p | s3
    If S3 is empty, then s3 = 0 and p | 0.
    If S3 is not empty, then p | Sum(f(i)*g(j) for (i,j) in S3)
    Since p divides each summand
*** p | s2
    Since p | h(r+s) and p | s1 and p | s3 and h(r+s) = s1 + s2 + s3.
*** S2 = singleton (r,s). 
*** s2 = f(r)*g(s)
*** p | f(r)*g(s)   CONTRADICTION
    Since p | s2 and s2 = f(r)*g(s)

** Theorem 1: if 1<=a and 1<=b, then divisors(a*b) = {x such that x = d*e where d|a and e|b}. 
   Assume all numbers (a,b, etc.) are positive integers.
   Let lhs(a,b) = divisors(a*b) = {x where x|a*b}
   Let rhs(a,b) = {d*e where d|a and e|b}
   Let thm(a,b) = lhs(a,b) == rhs(a,b).
*** 0. rhs(a,b) is subset of lhs(a,b)
   Let z in rhs(a,b). Choose d|a and e|b so that z = d*e.
   To show d*e|a*b,
    let x = Quo(a,d), y = Quo(b,e). Thus, a = d*x, b = e*y.
    a*b = (d*x)*(e*y) = (d*e)*(x*y). Thus d*e|a*b
   Thus, z in lhs(a,b).
*** 1. thm(a,b) iff thm(b,a)
   clear, since multiplication is commutative.
*** 2. thm(1,b)
   lhs(1,b) = divisors(1*b) = divisors(b)
   rhs(1,b) = {d*e where d|1 and e|b}
            = {1*e where e|b}  since d|1 iff d = 1
            = {e where e|b} = divisors(b)
   Thus, lhs(1,b) = rhs(1,b)
*** 3. if p is prime, then thm(p,b).
   Let x in lhs(p,b). So, x | p*b.
   To show x in rhs(p,b).
   We search for d,e where d*e = x and d|p and e|b
**** Case p|x.
    Choose d = p.  So d|p.
    Choose e = Quo(x,p), so x = p*e = d*e.
    Thus, p*e | p*b.  Since 1<=p, thus e|b.
**** Case p does not divide x.
    Thus, gcd(p,x) = 1.
    Choose y so p*b = x*y.
    Now p | x*y.
    Thus, p|y (Corollary to Euclid lemma on divisors)
    Let z = Quo(y,p), so y = p*z.
    Thus p*b = x*y = x*(p*z) = p*(x*z).
    Thus, b = x*z. So, x|b.
    Choose d = 1, e = x.
    Thus, d*e = 1*x = x, and d|p, and e|b.
    QED.
***
   Case x|p.
    Take d = x and e = 1.  Then d*e = x*1 = x, and d|p ane e|b.
   Case x does NOT divide p.
    Then x = 1 or x = p, since p is prime.
    Case x = 1. 
     Take d = 1 and e = 1. 
    Case x = p.
     Take d = x and e = 1
   Assume a,b in N*.
   lhs = divisors(a*b), rhs = {d*e where d|a and e|b}.
   Clearly,  rhs is a subset of lhs.
   Prove lhs is a subset of rhs by induction on a.
   Case a = 1. divisors(1*b) =  divisors(b)
    {d*e where d|1 and e|b} = {1*e where e|b} = divisors(b).
   Let x in lhs.  So x | a*b. to find d,e so x = d*e where d|a and e|b.
   Case x a prime.
    Let p be a prime p divide a*b, where p is a prime.
    Then p|a or p|b (Euclid lemma corollary).
    Case p|a. Choose d = p and e = 1. Then d*e = p and d*e in rhs.
    Case p|b. Choose d = 1 and e = p. Then d*e = p and d*e in rhs.
   Case x !=1 and x not a prime.
   Let p be a prime divisor of x: p|x.
   x = p*q for 1<q<x.
   a*b = x*y for some y.
   a*b = p*q*y.  
   Now let a be arbitrary, but a!=1 and a not a prime.
    Choose a prime p so p|a.
    Choose y so a = p*y.
   Assume 1 < a and for any 1<=c<a, divisors(c*b) = {d*e where d|c and e|b}.
   Case where a is a prime p.
   lhs = divisors(p*b). rhs = {d*e where d|p and e|b}.
   Let r | p*b. So p*b = r*x for some x in N.
   Not p divides r*x.
*** 4. if p is prime, then thm(a,p).
    thm(p,a) by (3)
    thm(a,p) by (1)
*** 5. thm(a,b)
   By induction on a.  Case a=1 is by (2)
   Assume A(c, c<a implies thm(c,b)) (inductive hypothesis)
   To show: lhs(a,b) is subset of rhs(a,b).
****   Case a = 1 is Case 2.
****   Case a != 1.
     Choose x in lhs(a,b), so x|a*b, 
     There is a prime p such that p|a.
     Let c = Quo(a,p). 
     a = p*c since p | a
     a*b = (p*c)*b = p*(c*b)
     Let so x|p*(c*b).
     By (3), there are y,z so that x = y*z and y|p and z|c*b.
     c < a, since 1 < p and a = p*c.
     By inductive hypothesis, thm(c,b) is true.
      z is in lhs(c,b) since z|c*b.
      there are u and v so that z = u*v and u|c and v|b.
      Now, x = y*z = y*(u*v) = (y*u)*v.
      And y*u | p*c = a.
      take d = y*u and e = v.  Then
      x = d*e and d|a and e|b.  
      Thus, x in rhs(a,b).
    This completes the inductive step.
**** Now thm(a,b) by induction

** Theorem 2: gcd(a*b,a*c) = a*gcd(b,c).
  This is Result 5 of Bezout Theorem corollaries
** define primitive polynomial : f in Z[X] and f != 0 and content(f) = 1.
** content(a*f) = a*content(f) if a in Z, 0 < a and f in Z[X], f != 0.
  Proof: Let c = content(f) 
  Let g = a*f.  g in Z[X] 
  g(i) = a*f(i) for all i in N.
  g != 0
  Let e = content(g). 
  To show: e = a*c.
  e = max(divisors(g)), by defn of content
*** a*c in divisors(g)
  if i in N, then a*c | g(i)
   c | f(i). Thus a*c | a*f(i)
   Thus a*c | g(i)
  a*c in divisors(g)
*** a*c <= e.
  since e = max(divisors(g)) and a*c in divisors(g)
*** (i) if p is prime, 1<=a then divisors(p*a) = union(divisors(a),p*divisors(a))
  D(x) = divisors(x)
  p*D(x) = {p*d where d in D(x)}
  lhs = D(p*a)
  rhs = union(D(a),p*D(a))
  d in rhs => d in lhs
   d in D(a) => d|a => d|p*a => d in lhs
   d in p*D(a).  d = p*x & x | a => p*x | p*a => d in lhs
  d in lhs => d in rhs
   d | p*a
   if p | d, then d = p*Quo(d,p);  p*Quo(d,p) | p*a ; Quo(d,p) | a; Quo(d,p) in D(a); d in p*D(a)
      so d in rhs
   if Not p | d, then gcd(p,d) = 1 (since p is prime).  Thus d | a. Thus d in D(a)
      so d in rhs
***
*** (ii) if x in D(b) and x in a*D(c), then x in a*D(b)   [D(n) = divisors(n) n in N]
    a | x,  since x in a*D(c)
    x = a * Quo(x,a)
    a * Quo(x,a) | b, since x | b
    Quo(x,a) | b,  
    Quo(x,a) in D(b)
    x in a*D(b)
*** if p is prime, 1<=a and 1<=b,  then Max(I(D(p*a),D(p*b))) = p*Max(I(D(a),D(b)))
    Let D(x) = divisors(x)
    Let U(x,y) = union(x,y)
    Let I(x,y) = intersection(x,y)
    Assume 1<=a, 1<=b
    Assume p is prime.
    D(p*a) = U(D(a),p*D(a)), since p is prime by (i)
    D(p*b) = U(D(b),p*D(b))

    I(D(p*a),D(p*b)) = U(I(D(a),D(b)), I(D(a),p*D(b)),  I(p*D(a),D(b)), I(p*D(a),p*D(b)))  
     leq(I(D(a),p*D(b)) , I(D(a),p*D(b)))  by (ii)
     leq(I(p*D(a),D(b)) , I(D(a),p*D(b)))  by (ii)
    eq(I(D(p*a),D(p*b)), U(I(D(a),D(b)), I(p*D(a),p*D(b)))
     If d in I(D(a),D(b)), then p*d is in I(p*D(a),p*D(b)) and d < p*d  (since 1 < p)
    Thus Max(I(D(p*a),D(p*b))) = Max(I(p*D(a),p*D(b)))
     
    Finally (?), Max(I(p*D(a),p*D(b))) =  p*Max(I(D(a),D(b))).
    Thus, Max(I(D(p*a),D(p*b))) = p*Max(I(D(a),D(b)))
*** If 1<=c, 1<=a and 1<=b then Max(I(D(c*a),D(c*b))) = c*Max(I(D(a),D(b)))
  start here
    Proof by induction on c
    Trivial when c = 1.
    Inductive hypothesis ...
    Assume 1<c.  Choose prime p so that p | c.
    c = p*q.
    Since 1 < p, q < c
*** Assume g is a finite sequence
*** e in divisors(g)
  if a*c < e:   
  Assume a is a prime.

  e = max(d, A(i, d | g(i)))
  e | g(i) for all i
  There are x and y so that e = x*y and x | a and y | f(i) (Theorem 1)
  Since a is prime, either x = 1 or x = a
  Case x = a:
   then a | e
  Case x = 1
   Then e | f(i) 
    Suppose there is z so that e = a*z and z | f(i)
    
  if i in N and d | g(i) and g(i) != 0, 
   then d in divisors(a*f(i))
   and f(i) != 0.  
   There are x and y so that d = x*y and x | a and y | f(i) (Theorem 1)
   Claim a*y in divisors(g(i))
    a*y | a*f(i))
   a = x*u, f(i) = y*v
   There is w  a*f(i) = d*w
   d*w = x*u*y*v = x*y*u*v = d*(u*v)
   w = u*v

* Gauss Lemma 1 on primitive polynomials:  abstract proof
Ref: https://planetmath.org/gaussslemmai
f,g primitive in Z[X] implies f*g is primitive.
Let h = f*g.
Otherwise, there is a prime p in Z that divides all coefficients of h.
I=<p>  is the ideal of Z generated by p.
W = Z/I is the Quotient ring.  Which we know to be a field.
An element of Z/I is the coset x+I = {x+i, i in I}, where x is in Z.
The function r: Z->Z/I is x->x+I; it is a surjective ring homomorphism.
r 'induces' a function R of polynomial rings Z[X] -> W[X] so that, for
any f in Z[X], R(f) is in W[X] and for any index i, R(f)(i) = r(f(i)).
R is also a ring surjection.
Also: W[X] is an integral domain. 
 For if f1,f2 in W[X] and f1 != 0 and f2 != 0.  
 Let m1 = deg(f1), m2 = deg(f2).
 So in W, f1(m1) != 0 and f2(m2) != 0.
 Since W is an integral domain, f1(m1)*f2(m2) != 0 in W.
 Now, by definition of polynomial multiplication,
  (f1*f2)(m1+n1) = f1(m1)*f2(m2).
  Thus, (f1*f2)(m1+n1) != 0 in W.
 Thus, f1*f2 != 0 in W[X].

Now, back to assumption that f,g in Z[X] are primitive.
Assume that in fact f*g is NOT primitive.
Then, choose a prime 'p' so that p divides all (non-zero) coefficients of f*g.
 The existence of p is very close to the definition of primitive polynomial.
 We identify 'p' with the zero-degree polynomial P, where P(0) = p.
 Proceed as above R(f*g) = R(f)*R(g). Now R(f*g) = 0  in W[X].
 So also R(f)*R(g) = 0 in W[X].  Since W[X] is integral domain, R(f)=0 or
 R[g] = 0 in W[X].
 If R(g) = 0 in W[X], then for all i, g(i) + I = 0 + I, so g(i) in I, i.e.,
 p divides g(i).  Thus, 1<p is a common divisor of coefficients of g,
 So, g is not primitive, contrary to assumption.
 Similarly, if R(f) = 0 in W[X], then f is not primitive.
 Thus, we have a contradiction to the assumption that f,g are primitive.
 QED.
* more to come
* ************************************************************
* Quadratic reciprocity
* ************************************************************
* Quadratic residue QR(a,p), Euler criterion
** define QR(a,p):
  QR(a,p) iff p is odd prime, a is in N*, gcd(a,p) = 1 and there
    is x in N* such that x**2 = a (mod p)
** primitive root criterion for quadratic residue
  If p is odd prime and r is primitive root for p, and 1<=k then
   QR(r**k,p) iff k is even.
  Proof: 
  Set j = NQuo(k,2)
*** if k is even, then QR(r**k,p)
   k = 2*j, r**k = (r**j)**2 . 
*** if QR(r**k,p), then k is even
    Choose x in N so r**k = x**2 (mod p)
    Choose i, 1<=i so x = r**i (mod p)
    Thus r**k = r**(2*i) (mod p)
    Thus k = 2*i (mod (p-1))
    So k = 2*i + j*(p-1) 
    Since p is odd, 2 | p-1.  Thus, 2 | k
** If p is odd prime, a is in N*, gcd(a,p) = 1, then a**((p-1)/2) = 1 or -1 (mod p)
  Assume  p is odd prime, a is in N*, gcd(a,p) = 1.
  Let p1 = p-1
  Let p2 = (p-1)/2 = Quo(p-1,2).  Since p is odd, p-1 is even.
  Thus p1 = 2*p2
  Let x = a**p2
  x**2 = a**(p2+p2) = a**p1
  a**p1 = 1, by  Fermat's little theorem
  So x**2 = 1 (mod p)
  So x is a root of polynomial X**2 - 1 in Nring(p).
  Nring(p) is a field since p is prime.
  2 = degree of polynomial X**2 - 1 
  Note there are at most 2 roots of polynomial X**2 - 1 in Nring(p),
    by Legendre theorem on number of roots of a polynomial over a field.
  1 and p-1 are roots of X**2 - 1 in Nring(p)
   
** Euler criterion for quadratic residue
  QR(a,p) iff p is odd prime, a is in N*, gcd(a,p) = 1 and
   a**((p-1)/2) = 1 (mod p)
  Proof:
  Assume  p is odd prime, a is in N*, gcd(a,p) = 1.
  Let p1 = p-1
  Let p2 = (p-1)/2 = Quo(p-1,2).  Since p is odd, p-1 is even.
  Thus p1 = 2*p2

*** If QR(a,p), then  a**p2 = 1 (mod p)
  Choose x with x**2 = a (mod p).
  So x != 0.  If p | x, then p | a;  Thus gcd(x,p) = 1.
  By Fermat's little theorem, x**p1 = 1 (mod p)
  a**p2 = (x**2)**p2 
   = x**(2*p2) 
   = x**p1 
   = 1 (mod p)  Fermat little theorem
*** If a**p2 = 1 (mod p), then QR(a,p)
  Choose r a primitive root for p (since p is a prime)
  Choose k so that r**k = a (mod p).
  1 = a**p2 
    = (r**k)**p2 
    = r**(k*p2).
  Thus p1 | k*p2, since r is primitive root
  Thus 2*p2 | k*p2
  Thus 2 | k.
  Thus QR(a,p), by primitive root criterion for quadratic residue.
** define QRs(p)
   Assume p is odd prime.
   QRs(p) = {a in relprimes(p) and QR(a,p)}
** Number of quadratic residues
   Assume p is odd prime.
   Card(Qrs(p)) = (p-1)/2.
** Proof 1
   Let r be a primitive root for p.
   Let S = {k, 1<=k<p and QR(r**k,p)}
   Then k in S iff k is even, by primitive root criterion
   Since p is odd, Card{k, 1<=k<p and k even} = (p-1)/2.
   Thus, Card(S) = (p-1)/2>
   QRs(p) = {Rem(r**k,p) 1<=k<p and k even}.
   Card(Qrs(p)) = (p-1)/2>
** Proof 2
   Let p2 = (p-1)/2
   QRs(p) = {a in relprimes(p) and a**p2 = 1 (mod p)}, Euler criterion.
   x**(p-1) = 1 has p-1 distinct solutions, Fermat little theorem.
   x**(p-1) = (x**p2 + 1)*(x**p2 - 1) Factor polynomials in NRing(p).
   x**p2 - 1 has p2 solutions and x**p2 + 1 has p2 solutions.
   Thus Card(QRs(p)) = p2 
* Legendre Symbol
  Assume p is odd prime and gcd(a,p) = 1.
  Legsym(a,p) = 1 iff QR(a,p)
  Legsym(a,p) = -1 iff Not QR(a,p)
  By '-1' we mean the additive inverse of '1' in Nring(p),
    i.e., the element p-1 of Nring(p).
**  Legsym(a,p) = a**Quo(p-1,2) in Nring(p)
**  Case QR(a,p):
    Legsym(a,p) = 1
    a**Quo(p-1,2) = 1 in Nring(p)  (Euler criterion)
    Thus, Legsym(a,p) = a**Quo(p-1,2) in Nring(p)
**  Case Not QR(a,p)
    Legsym(a,p) = -1 in Nring(p)
    a**Quo(p-1,2) = 1 or a**Quo(p-1,2) = -1 in Nring(p)
    Iff QR(a,p) a**Quo(p-1,2) = 1  (Euler criterion)
    Thus, a**Quo(p-1,2) != 1
    Thus, a**Quo(p-1,2) = -1 in Nring(p)
    Thus Legsym(a,p) = a**Quo(p-1,2) in Nring(p)
* Gauss Lemma (Quadratic residue criterion)
  Assume p is odd prime and gcd(a,p) = 1.
  Let p1 = p-1, p2 = p1/2. So p1 = 2*p2 (since p odd)
  Let S0 = {k in relprimes(p) and k<=p2} = {1,...,p2}.  NCard(S0) = p2 
  Let Q2 = {k in S0 and NRem(a*k,p) > p2}
  Let n2 = NCard(Q2)
  Then Legsym(a,p) = (-1)**n2 (in NRing(p))
 Proof:
  Let Q1 = {k in S0 and NRem(a*k,p) <= p2}
  union(Q1,Q2) = S0, and isect(Q1,Q2) = 0
  Note: Either Q1 or Q2 may be empty. 

  Define function F from S0 to N whose value at k in S0 is 
   F(k) = NRem(a*k,p) if k is in Q1
        = p - NRem(a*k,p) if k is in Q2
   Let P0 = NRem(1*...*p2,p) = NProd(S0) in NRing(p)
   Ea = NRem(a**p2,p)
   Pa = Nrem((a*1)*...(a*p2),p) in NRing(p)
   Let PF = NRem(F(1)*...*F(p2),p).
   Let n1 = NCard(Q1), 
   n1 + n2 = NCard(S0) and NCard(S0) = p2.
   Let PF1 = NProd(image(F,Q1)) in NProd(p)
   Let PF2 = NProd(image(F,Q2)) in NProd(p)

** E(a) = 1 iff 'a' is a quadratic residue of p (Euler criterion)
** Prod(Q1)*Prod(Q2) = P0
   since union(Q1,Q2) = S0 and isect(Q1,Q2) = 0
** Pa = Ea * P0 in Nring(p)
   By commutativity and associativity etc.
   Example: p = 7
   (a*1)*(a*2)*(a*3) = (a**3)*(1*2*3)
** F is a permutation of S0.
   Let u = NRem(a*k,p). 
   gcd(k,p) = 1. So u is in relprimes(p)
   if u <= p2, then u is in S0.
   if u >= p2, then p-u is in S0.
   Thus, F is a function from S0 to S0.
*** F is injection from S0 to S0
   Let also j in S0, and suppose F(j) = F(k). We must show j = k
   Set v = NRem(a*j,p). 
   if v <= p2, then F(j) = v;  if v > p2, then F(j) = p-v.
   There are 4 cases:
**** if u <= p2 and v <= p2, then j = k
   Thus u = v.
   We know i -> NRem(a*i,p) is a bijection of relprimes(p), since p is prime.
   Thus j = k
**** Case u <= p2 and v > p2 cannot happen since F(j) = F(k)
    Thus u = p - v, since F(j) = F(k)
    So u + v = p. 
     But u + v <= p2 + p2 = p1 = p-1 < p.
    Thus a contradiction
**** Case u > p2 and v <= p2 cannot happen since F(j) = F(k)
    Thus p - u = v since F(j) = F(k)
    Thus u + v = p
     But u + v <= p2 + p2 = p1 = p-1 < p.
    Thus a contradiction
**** Case u > p2 and v > p2
    Thus, p - u = p - v
    Thus u = v
   We know i -> NRem(a*i,p) is a bijection of relprimes(p), since p is prime.
   Thus j = k
*** F is bijection from S0 to S0
   F is a 1-1 function from the finite set S0 to itself.
   Thus, F is a bijection
** PF = PF1 * PF2 in Nring(p)
   Since F is permutation of S0, and union(Q1,Q2) = S0, and isect(Q1,Q2) = 0
** PF = P0 in Nring(p)
   Since F is a permutation of S0
** PF1 = (a**n1)*Prod(Q1)
   For k in Q1, F(k) = NRem(a*k,p)
   Thus PF1 = product of a*k when k is in Q1 
** PF2 = ((-1)**n2) * (a**n2) * Prod(Q2)
   For k in Q2, F(k) = p - k = -k in Nprod(p)
** PF = ((-1)**n2) * Ea * P0
   PF = PF1 * PF2, from above
    = (a**n1)*Prod(Q1) * ((-1)**n2) * (a**n2) * Prod(Q2)  from above
    = ((-1)**n2) * [(a**n1) * (a**n2)] * [Prod(Q1) * Prod(Q2)], assoc., comm.
    = ((-1)**n2) * a**(n1+n2)  * P0
    = ((-1)**n2) * Ea * P0
**
** ((-1)**n2) * Ea = 1 (mod p)
   P0 = PF = ((-1)**n2) * Ea * P0
   Cancel P0 in Nring(p)
** Ea = ((-1)**n2) (mod p)
   ((-1)**n2) * Ea = 1 (mod p)
   ((-1)**n2) * ((-1)**n2) * Ea = ((-1)**n2)  (mod p)
   ((-1)**n2) * ((-1)**n2) = 1 (mod p)
   Ea = ((-1)**n2)  (mod p)
** Legsym(a,p) = ((-1)**n2) in Nring(p)
  Legsym(a,p) = a**Quo(p-1,2) in Nring(p) = Ea = ((-1)**n2) in Nring(p)
* consequences of Gauss Lemma on quadratic residues
** Criterion for QR(2,p)
  Theorem: If p is an odd prime, then QR(2,p) iff p = +1 or -1 (mod 8).
  Note gcd(2,p) = 1 since p is odd. 
  Let p1 = p-1, p2 = p1/2. So p1 = 2*p2 (since p odd)
  Let S0 = {k in relprimes(p) and k<=p2} = {1,...,p2}.  NCard(S0) = p2 
  Let Q2 = {k in S0 and NRem(2*k,p) > p2}
  Let n2 = NCard(Q2)
  Then Legsym(2,p) = (-1)**n2 (in NRing(p))
  For k in s2, 2*k <= 2*p2 = p1 < p, So NRem(2*k,p) = 2*k.
  Thus, Q2 = {k, 1<=k<=p2 and 2*k > p2}
  Q1 = {k, 1<=k<=p2 and 2*k <= p2}
*** Q1 = {k, 1<=k<=Quo(p2,2)}
   Let q = Quo(p2,2). 
   To show: if 1 <= k, then 2*k <= p2 Iff k <= q
   Let r = Rem(p2,2)
   p2 = 2*q + r, and r < 2.   
   So r = 0 or r = 1
**** Case r = 0.
   Assume 1 <= k and r = 0
   p2 = 2*q
   Thus 2*k <= p2 Iff 2*k <= 2*q Iff k <= q
**** Case r = 1
   Assume 1 <= k and r = 1
   p2 = 2*q + 1
   2*k <= p2 Iff 2*k <= 2*q + 1
***** if k <= q, then 2*k <= 2*q + 1
   Assume k <= q.
   Thun 2*k <= 2*q
            <= 2*q + 1
***** if 2*k <= 2*q + 1, then k <= q
   Assume 2*k <= 2*q + 1.
   Assume Not (k<=q) and derive a contradiction
    Thus k > q. 
    Let j = NDif(k,q), so
     k = q + j and 0 < j
     2*k = 2*(q + j) = 2*q + 2*j 
    So 2*q + 2*j <= 2*q + 1
    So 2*j <= 1.
    But 1<=j, so 2*1 <= 2*j
    Thus 1 < 2 <= 2*j which contradicts 2*j <= 1.
   Thus, k<=q.
*** n1 = Quo(p2,2), n2 = p2 - Quo(p2,2)
*** QR(2,p) iff p2 - Quo(p2,2) is even.


   
   
